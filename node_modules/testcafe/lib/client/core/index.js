// NOTE: We should have the capability to initialize scripts with different contexts.
// This is required for iframes without the src attribute because Hammerhead does not
// inject scripts into such iframes. So, we wrap all scripts in initialization functions.
(function () {
    function initTestCafeCore(window, isIFrameWithoutSrc) {
        var document = window.document;

        // This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"pinkie": {
		"index.js": function (exports, module, require) {
			

			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

			var PENDING = 'pending';
			var SETTLED = 'settled';
			var FULFILLED = 'fulfilled';
			var REJECTED = 'rejected';
			var NOOP = function NOOP() {};
			var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';

			var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
			var asyncQueue = [];
			var asyncTimer;

			function asyncFlush() {
				// run promise callbacks
				for (var i = 0; i < asyncQueue.length; i++) {
					asyncQueue[i][0](asyncQueue[i][1]);
				}

				// reset async asyncQueue
				asyncQueue = [];
				asyncTimer = false;
			}

			function asyncCall(callback, arg) {
				asyncQueue.push([callback, arg]);

				if (!asyncTimer) {
					asyncTimer = true;
					asyncSetTimer(asyncFlush, 0);
				}
			}

			function invokeResolver(resolver, promise) {
				function resolvePromise(value) {
					resolve(promise, value);
				}

				function rejectPromise(reason) {
					reject(promise, reason);
				}

				try {
					resolver(resolvePromise, rejectPromise);
				} catch (e) {
					rejectPromise(e);
				}
			}

			function invokeCallback(subscriber) {
				var owner = subscriber.owner;
				var settled = owner._state;
				var value = owner._data;
				var callback = subscriber[settled];
				var promise = subscriber.then;

				if (typeof callback === 'function') {
					settled = FULFILLED;
					try {
						value = callback(value);
					} catch (e) {
						reject(promise, e);
					}
				}

				if (!handleThenable(promise, value)) {
					if (settled === FULFILLED) {
						resolve(promise, value);
					}

					if (settled === REJECTED) {
						reject(promise, value);
					}
				}
			}

			function handleThenable(promise, value) {
				var resolved;

				try {
					if (promise === value) {
						throw new TypeError('A promises callback cannot return that same promise.');
					}

					if (value && (typeof value === 'function' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object')) {
						// then should be retrieved only once
						var then = value.then;

						if (typeof then === 'function') {
							then.call(value, function (val) {
								if (!resolved) {
									resolved = true;

									if (value === val) {
										fulfill(promise, val);
									} else {
										resolve(promise, val);
									}
								}
							}, function (reason) {
								if (!resolved) {
									resolved = true;

									reject(promise, reason);
								}
							});

							return true;
						}
					}
				} catch (e) {
					if (!resolved) {
						reject(promise, e);
					}

					return true;
				}

				return false;
			}

			function resolve(promise, value) {
				if (promise === value || !handleThenable(promise, value)) {
					fulfill(promise, value);
				}
			}

			function fulfill(promise, value) {
				if (promise._state === PENDING) {
					promise._state = SETTLED;
					promise._data = value;

					asyncCall(publishFulfillment, promise);
				}
			}

			function reject(promise, reason) {
				if (promise._state === PENDING) {
					promise._state = SETTLED;
					promise._data = reason;

					asyncCall(publishRejection, promise);
				}
			}

			function publish(promise) {
				promise._then = promise._then.forEach(invokeCallback);
			}

			function publishFulfillment(promise) {
				promise._state = FULFILLED;
				publish(promise);
			}

			function publishRejection(promise) {
				promise._state = REJECTED;
				publish(promise);
				if (!promise._handled && isNode) {
					global.process.emit('unhandledRejection', promise._data, promise);
				}
			}

			function notifyRejectionHandled(promise) {
				global.process.emit('rejectionHandled', promise);
			}

			/**
			 * @class
			 */
			function Promise(resolver) {
				if (typeof resolver !== 'function') {
					throw new TypeError('Promise resolver ' + resolver + ' is not a function');
				}

				if (this instanceof Promise === false) {
					throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
				}

				this._then = [];

				invokeResolver(resolver, this);
			}

			Promise.prototype = {
				constructor: Promise,

				_state: PENDING,
				_then: null,
				_data: undefined,
				_handled: false,

				then: function then(onFulfillment, onRejection) {
					var subscriber = {
						owner: this,
						then: new this.constructor(NOOP),
						fulfilled: onFulfillment,
						rejected: onRejection
					};

					if ((onRejection || onFulfillment) && !this._handled) {
						this._handled = true;
						if (this._state === REJECTED && isNode) {
							asyncCall(notifyRejectionHandled, this);
						}
					}

					if (this._state === FULFILLED || this._state === REJECTED) {
						// already resolved, call callback async
						asyncCall(invokeCallback, subscriber);
					} else {
						// subscribe
						this._then.push(subscriber);
					}

					return subscriber.then;
				},

				catch: function _catch(onRejection) {
					return this.then(null, onRejection);
				}
			};

			Promise.all = function (promises) {
				if (!Array.isArray(promises)) {
					throw new TypeError('You must pass an array to Promise.all().');
				}

				return new Promise(function (resolve, reject) {
					var results = [];
					var remaining = 0;

					function resolver(index) {
						remaining++;
						return function (value) {
							results[index] = value;
							if (! --remaining) {
								resolve(results);
							}
						};
					}

					for (var i = 0, promise; i < promises.length; i++) {
						promise = promises[i];

						if (promise && typeof promise.then === 'function') {
							promise.then(resolver(i), reject);
						} else {
							results[i] = promise;
						}
					}

					if (!remaining) {
						resolve(results);
					}
				});
			};

			Promise.race = function (promises) {
				if (!Array.isArray(promises)) {
					throw new TypeError('You must pass an array to Promise.race().');
				}

				return new Promise(function (resolve, reject) {
					for (var i = 0, promise; i < promises.length; i++) {
						promise = promises[i];

						if (promise && typeof promise.then === 'function') {
							promise.then(resolve, reject);
						} else {
							resolve(promise);
						}
					}
				});
			};

			Promise.resolve = function (value) {
				if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise) {
					return value;
				}

				return new Promise(function (resolve) {
					resolve(value);
				});
			};

			Promise.reject = function (reason) {
				return new Promise(function (resolve, reject) {
					reject(reason);
				});
			};

			module.exports = Promise;
		}
	},
	"testcafe-phoenix": {
		"src": {
			"browser": {
				"connection": {
					"command.js": function (exports, module, require) {
						

						exports.__esModule = true;
						// --------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// --------------------------------------------------------

						exports.default = {
						    run: 'run',
						    idle: 'idle'
						};
						module.exports = exports['default'];
					},
					"status.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = {
						    ok: 'ok',
						    closing: 'closing'
						};
						module.exports = exports['default'];
					}
				}
			},
			"client": {
				"browser": {
					"index.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.startHeartbeat = startHeartbeat;
						exports.startInitScriptExecution = startInitScriptExecution;
						exports.stopInitScriptExecution = stopInitScriptExecution;
						exports.redirect = redirect;
						exports.checkStatus = checkStatus;

						var _pinkie = require('pinkie');

						var _pinkie2 = _interopRequireDefault(_pinkie);

						var _command = require('../../browser/connection/command');

						var _command2 = _interopRequireDefault(_command);

						var _status = require('../../browser/connection/status');

						var _status2 = _interopRequireDefault(_status);

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var HEARTBEAT_INTERVAL = 2 * 1000; // TODO: once we'll have client commons load it from there instead of node modules (currently it's leads to two copies of this packages on client)


						var allowInitScriptExecution = false;

						//Utils
						// NOTE: the window.XMLHttpRequest may have been wrapped by Hammerhead, while we should send a request to
						// the original URL. That's why we need the XMLHttpRequest argument to send the request via native methods.
						function sendXHR(url, createXHR) {
						    var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'GET';
						    var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

						    return new _pinkie2.default(function (resolve, reject) {
						        var xhr = createXHR();

						        xhr.open(method, url, true);

						        xhr.onreadystatechange = function () {
						            if (xhr.readyState === 4) {
						                if (xhr.status === 200) resolve(xhr.responseText ? JSON.parse(xhr.responseText) : ''); //eslint-disable-line no-restricted-globals
						                else reject('disconnected');
						            }
						        };

						        xhr.send(data);
						    });
						}

						function isCurrentLocation(url) {
						    /*eslint-disable no-restricted-properties*/
						    return document.location.href.toLowerCase() === url.toLowerCase();
						    /*eslint-enable no-restricted-properties*/
						}

						//API
						function startHeartbeat(heartbeatUrl, createXHR) {
						    function heartbeat() {
						        sendXHR(heartbeatUrl, createXHR).then(function (status) {
						            if (status.code === _status2.default.closing && !isCurrentLocation(status.url)) {
						                stopInitScriptExecution();
						                document.location = status.url;
						            }
						        });
						    }

						    window.setInterval(heartbeat, HEARTBEAT_INTERVAL);

						    heartbeat();
						}

						function executeInitScript(initScriptUrl, createXHR) {
						    if (!allowInitScriptExecution) return;

						    sendXHR(initScriptUrl, createXHR).then(function (res) {
						        if (!res.code) return null;

						        /* eslint-disable no-eval,  no-restricted-globals*/
						        return sendXHR(initScriptUrl, createXHR, 'POST', JSON.stringify(eval(res.code)));
						        /* eslint-enable no-eval, no-restricted-globals */
						    }).then(function () {
						        window.setTimeout(function () {
						            return executeInitScript(initScriptUrl, createXHR);
						        }, 1000);
						    });
						}

						function startInitScriptExecution(initScriptUrl, createXHR) {
						    allowInitScriptExecution = true;

						    executeInitScript(initScriptUrl, createXHR);
						}

						function stopInitScriptExecution() {
						    allowInitScriptExecution = false;
						}

						function redirect(command) {
						    stopInitScriptExecution();
						    document.location = command.url;
						}

						function checkStatus(statusUrl, createXHR, opts) {
						    var _ref = opts || {},
						        manualRedirect = _ref.manualRedirect;

						    return sendXHR(statusUrl, createXHR).then(function (res) {
						        var redirecting = (res.cmd === _command2.default.run || res.cmd === _command2.default.idle) && !isCurrentLocation(res.url);

						        if (redirecting && !manualRedirect) redirect(res);

						        return { command: res, redirecting: redirecting };
						    });
						}
					}
				},
				"core": {
					"deps": {
						"hammerhead.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = window['%hammerhead%'];
							module.exports = exports['default'];
						}
					},
					"index.js": function (exports, module, require) {
						

						var _hammerhead = require('./deps/hammerhead');

						var _hammerhead2 = _interopRequireDefault(_hammerhead);

						var _keyMaps = require('./utils/key-maps');

						var _keyMaps2 = _interopRequireDefault(_keyMaps);

						var _nodeTypeDescriptions = require('./utils/node-type-descriptions');

						var _nodeTypeDescriptions2 = _interopRequireDefault(_nodeTypeDescriptions);

						var _requestBarrier = require('./request-barrier');

						var _requestBarrier2 = _interopRequireDefault(_requestBarrier);

						var _pageUnloadBarrier = require('./page-unload-barrier');

						var pageUnloadBarrier = _interopRequireWildcard(_pageUnloadBarrier);

						var _preventRealEvents = require('./prevent-real-events');

						var _scrollController = require('./scroll-controller');

						var _scrollController2 = _interopRequireDefault(_scrollController);

						var _service = require('./utils/service');

						var serviceUtils = _interopRequireWildcard(_service);

						var _dom = require('./utils/dom');

						var domUtils = _interopRequireWildcard(_dom);

						var _contentEditable = require('./utils/content-editable');

						var contentEditable = _interopRequireWildcard(_contentEditable);

						var _position = require('./utils/position');

						var positionUtils = _interopRequireWildcard(_position);

						var _style = require('./utils/style');

						var styleUtils = _interopRequireWildcard(_style);

						var _event = require('./utils/event');

						var eventUtils = _interopRequireWildcard(_event);

						var _array = require('./utils/array');

						var arrayUtils = _interopRequireWildcard(_array);

						var _promise = require('./utils/promise');

						var promiseUtils = _interopRequireWildcard(_promise);

						var _textSelection = require('./utils/text-selection');

						var textSelection = _interopRequireWildcard(_textSelection);

						var _waitFor = require('./utils/wait-for');

						var _waitFor2 = _interopRequireDefault(_waitFor);

						var _delay = require('./utils/delay');

						var _delay2 = _interopRequireDefault(_delay);

						var _noop = require('./utils/noop');

						var _noop2 = _interopRequireDefault(_noop);

						var _getKeyArray = require('./utils/get-key-array');

						var _getKeyArray2 = _interopRequireDefault(_getKeyArray);

						var _getSanitizedKey = require('./utils/get-sanitized-key');

						var _getSanitizedKey2 = _interopRequireDefault(_getSanitizedKey);

						var _parseKeySequence = require('./utils/parse-key-sequence');

						var _parseKeySequence2 = _interopRequireDefault(_parseKeySequence);

						var _sendRequestToFrame = require('./utils/send-request-to-frame');

						var _sendRequestToFrame2 = _interopRequireDefault(_sendRequestToFrame);

						var _browser = require('../browser');

						var browser = _interopRequireWildcard(_browser);

						var _selectorTextFilter = require('../../client-functions/selectors/selector-text-filter');

						var _selectorTextFilter2 = _interopRequireDefault(_selectorTextFilter);

						var _selectorAttributeFilter = require('../../client-functions/selectors/selector-attribute-filter');

						var _selectorAttributeFilter2 = _interopRequireDefault(_selectorAttributeFilter);

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						exports.RequestBarrier = _requestBarrier2.default;
						exports.pageUnloadBarrier = pageUnloadBarrier;
						exports.preventRealEvents = _preventRealEvents.preventRealEvents;
						exports.disableRealEventsPreventing = _preventRealEvents.disableRealEventsPreventing;
						exports.scrollController = _scrollController2.default;

						exports.serviceUtils = serviceUtils;
						exports.domUtils = domUtils;
						exports.contentEditable = contentEditable;
						exports.positionUtils = positionUtils;
						exports.styleUtils = styleUtils;
						exports.eventUtils = eventUtils;
						exports.arrayUtils = arrayUtils;
						exports.promiseUtils = promiseUtils;
						exports.textSelection = textSelection;
						exports.waitFor = _waitFor2.default;
						exports.delay = _delay2.default;
						exports.noop = _noop2.default;
						exports.getKeyArray = _getKeyArray2.default;
						exports.getSanitizedKey = _getSanitizedKey2.default;
						exports.parseKeySequence = _parseKeySequence2.default;
						exports.sendRequestToFrame = _sendRequestToFrame2.default;
						exports.KEY_MAPS = _keyMaps2.default;
						exports.NODE_TYPE_DESCRIPTIONS = _nodeTypeDescriptions2.default;
						exports.browser = browser;

						exports.selectorTextFilter = _selectorTextFilter2.default;
						exports.selectorAttributeFilter = _selectorAttributeFilter2.default;

						exports.get = require;

						_hammerhead2.default.nativeMethods.objectDefineProperty.call(window, window, '%testCafeCore%', {
						    configurable: true,
						    value: exports
						});

						// NOTE: initTestCafeCore defined in wrapper template
						/* global initTestCafeCore */
						_hammerhead2.default.on(_hammerhead2.default.EVENTS.evalIframeScript, function (e) {
						    return initTestCafeCore(e.iframe.contentWindow, true);
						});
					},
					"page-unload-barrier.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.init = init;
						exports.watchForPageNavigationTriggers = watchForPageNavigationTriggers;
						exports.wait = wait;

						var _hammerhead = require('./deps/hammerhead');

						var _hammerhead2 = _interopRequireDefault(_hammerhead);

						var _event = require('./utils/event');

						var eventUtils = _interopRequireWildcard(_event);

						var _delay = require('./utils/delay');

						var _delay2 = _interopRequireDefault(_delay);

						var _clientMessages = require('../../test-run/client-messages');

						var _clientMessages2 = _interopRequireDefault(_clientMessages);

						var _dom = require('./utils/dom');

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var Promise = _hammerhead2.default.Promise;
						var browserUtils = _hammerhead2.default.utils.browser;
						var nativeMethods = _hammerhead2.default.nativeMethods;
						var transport = _hammerhead2.default.transport;

						var DEFAULT_BARRIER_TIMEOUT = 400;
						var SHORT_WAIT_FOR_UNLOAD_TIMEOUT = 30;
						var FILE_DOWNLOAD_CHECK_DELAY = 500;
						var MAX_UNLOADING_TIMEOUT = 15 * 1000;

						var waitingForUnload = false;
						var waitingForUnloadTimeoutId = null;
						var waitingPromiseResolvers = [];
						var unloading = false;

						var pageNavigationTriggeredListener = null;
						var pageNavigationTriggered = false;

						function onBeforeUnload() {
						    if (!browserUtils.isIE) {
						        unloading = true;
						        return;
						    }

						    prolongUnloadWaiting(SHORT_WAIT_FOR_UNLOAD_TIMEOUT);

						    (0, _delay2.default)(0).then(function () {
						        // NOTE: except file downloading
						        if (document.readyState === 'loading') {
						            var activeElement = nativeMethods.documentActiveElementGetter.call(document);

						            if (!activeElement || !(0, _dom.isAnchorElement)(activeElement) || !activeElement.hasAttribute('download')) unloading = true;
						        }
						    });
						}

						function prolongUnloadWaiting(timeout) {
						    if (waitingForUnloadTimeoutId) nativeMethods.clearTimeout.call(window, waitingForUnloadTimeoutId);

						    waitingForUnload = true;

						    waitingForUnloadTimeoutId = nativeMethods.setTimeout.call(window, function () {
						        waitingForUnloadTimeoutId = null;
						        waitingForUnload = false;

						        waitingPromiseResolvers.forEach(function (resolve) {
						            return resolve();
						        });
						        waitingPromiseResolvers = [];
						    }, timeout);
						}

						function waitForFileDownload() {
						    return new Promise(function (resolve) {
						        nativeMethods.setTimeout.call(window, function () {
						            transport.queuedAsyncServiceMsg({ cmd: _clientMessages2.default.waitForFileDownload }).then(function (fileDownloadingHandled) {
						                // NOTE: we use a flag to confirm file download because if unload
						                // is raised the browser can respond with an empty string
						                if (fileDownloadingHandled) resolve();
						            });
						        }, FILE_DOWNLOAD_CHECK_DELAY);
						    });
						}

						// API
						function init() {
						    _hammerhead2.default.on(_hammerhead2.default.EVENTS.beforeUnload, onBeforeUnload);

						    eventUtils.bind(window, 'unload', function () {
						        unloading = true;
						    });
						}

						function watchForPageNavigationTriggers() {
						    pageNavigationTriggeredListener = function pageNavigationTriggeredListener() {
						        pageNavigationTriggered = true;
						    };

						    _hammerhead2.default.on(_hammerhead2.default.EVENTS.pageNavigationTriggered, pageNavigationTriggeredListener);
						}

						function wait(timeout) {
						    var waitForUnloadingPromise = new Promise(function (resolve) {
						        if (timeout === void 0) timeout = !pageNavigationTriggeredListener || pageNavigationTriggered ? DEFAULT_BARRIER_TIMEOUT : 0;

						        if (pageNavigationTriggeredListener) {
						            _hammerhead2.default.off(_hammerhead2.default.EVENTS.pageNavigationTriggered, pageNavigationTriggeredListener);
						            pageNavigationTriggeredListener = null;
						        }

						        (0, _delay2.default)(timeout).then(function () {
						            if (unloading) {
						                waitForFileDownload().then(function () {
						                    unloading = false;
						                    resolve();
						                });

						                return;
						            }

						            if (!waitingForUnload) resolve();else waitingPromiseResolvers.push(resolve);
						        });
						    });

						    // NOTE: sometimes the page isn't actually unloaded after the beforeunload event
						    // fires (see issues #664, #437). To avoid test hanging, we resolve the unload
						    // barrier waiting promise in MAX_UNLOADING_TIMEOUT. We can improve this logic when
						    // the https://github.com/DevExpress/testcafe-hammerhead/issues/667 issue is fixed.
						    var watchdog = (0, _delay2.default)(MAX_UNLOADING_TIMEOUT).then(function () {
						        unloading = false;
						    });

						    return Promise.race([waitForUnloadingPromise, watchdog]);
						}
					},
					"prevent-real-events.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.preventRealEvents = preventRealEvents;
						exports.disableRealEventsPreventing = disableRealEventsPreventing;

						var _hammerhead = require('./deps/hammerhead');

						var _scrollController = require('./scroll-controller');

						var _scrollController2 = _interopRequireDefault(_scrollController);

						var _style = require('./utils/style');

						var _array = require('./utils/array');

						var _dom = require('./utils/dom');

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var browserUtils = _hammerhead.utils.browser;
						var listeners = _hammerhead.eventSandbox.listeners;
						var eventSimulator = _hammerhead.eventSandbox.eventSimulator;

						var PREVENTED_EVENTS = ['click', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'mousemove', 'mouseover', 'mouseout', 'touchstart', 'touchmove', 'touchend', 'keydown', 'keypress', 'input', 'keyup', 'change', 'focus', 'blur', 'MSPointerDown', 'MSPointerMove', 'MSPointerOver', 'MSPointerOut', 'MSPointerUp', 'pointerdown', 'pointermove', 'pointerover', 'pointerout', 'pointerup'];

						var F12_KEY_CODE = 123;

						function checkBrowserHotkey(e) {
						    // NOTE: Opening browser tools with F12, CTRL+SHIFT+<SYMBOL KEY>
						    // on PC or with OPTION(ALT)+CMD+<SYMBOL KEY> on Mac.
						    return e.shiftKey && e.ctrlKey || (e.altKey || e.metaKey) && browserUtils.isMacPlatform || e.keyCode === F12_KEY_CODE;
						}

						// NOTE: when tests are running, we should block real events (from mouse
						// or keyboard), because they may lead to unexpected test result.
						function preventRealEventHandler(e, dispatched, preventDefault, cancelHandlers, stopEventPropagation) {
						    var target = e.target || e.srcElement;

						    if (!dispatched && !(0, _dom.isShadowUIElement)(target)) {
						        // NOTE: this will allow pressing hotkeys to open developer tools.
						        if (/^key/.test(e.type) && checkBrowserHotkey(e)) {
						            stopEventPropagation();
						            return;
						        }

						        // NOTE: if an element loses focus because of becoming invisible, the blur event is
						        // raised. We must not prevent this blur event. In IE, an element loses focus only
						        // if the CSS 'display' property is set to 'none', other ways of making an element
						        // invisible don't lead to blurring (in MSEdge, focus/blur are sync).
						        if (e.type === 'blur') {
						            if (browserUtils.isIE && browserUtils.version < 12) {
						                var isElementInvisible = !(0, _dom.isWindow)(target) && (0, _style.get)(target, 'display') === 'none';
						                var elementParents = null;
						                var invisibleParents = false;

						                if (!isElementInvisible) {
						                    elementParents = (0, _dom.getParents)(target);
						                    invisibleParents = (0, _array.filter)(elementParents, function (parent) {
						                        return (0, _style.get)(parent, 'display') === 'none';
						                    });
						                }

						                if (isElementInvisible || invisibleParents.length) {
						                    // NOTE: In IE we should prevent the event and raise it on timeout. This is a fix for
						                    // the case when a focus event leads to the element disappearing. If we don't prevent
						                    // the blur event it will be raised before the previous focus event is raised (see B254768)
						                    _hammerhead.eventSandbox.timers.deferFunction(function () {
						                        eventSimulator.blur(target);
						                    });
						                }
						            }
						            // NOTE: fix for a jQuery bug. An exception is raised when calling .is(':visible')
						            // for a window or document on page loading (when e.ownerDocument is null).
						            else if (target !== window && target !== window.document && !(0, _style.hasDimensions)(target)) return;
						        }

						        preventDefault();
						    }
						}

						function preventRealEvents() {
						    listeners.initElementListening(window, PREVENTED_EVENTS);
						    listeners.addFirstInternalHandler(window, PREVENTED_EVENTS, preventRealEventHandler);

						    _scrollController2.default.init();
						}

						function disableRealEventsPreventing() {
						    listeners.removeInternalEventListener(window, PREVENTED_EVENTS, preventRealEventHandler);
						}
					},
					"request-barrier.js": function (exports, module, require) {
						

						exports.__esModule = true;

						var _hammerhead = require('./deps/hammerhead');

						var _hammerhead2 = _interopRequireDefault(_hammerhead);

						var _delay = require('./utils/delay');

						var _delay2 = _interopRequireDefault(_delay);

						var _array = require('./utils/array');

						var _service = require('./utils/service');

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

						function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

						function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

						var Promise = _hammerhead2.default.Promise;
						var nativeMethods = _hammerhead2.default.nativeMethods;

						var REQUESTS_COLLECTION_DELAY_DEFAULT = 50;
						var REQUESTS_FINISHED_EVENT = 'requests-finished';

						var GLOBAL_REQUEST_BARRIER_FIELD = 'testcafe|request-barrier';

						var RequestBarrier = function (_EventEmitter) {
						    _inherits(RequestBarrier, _EventEmitter);

						    function RequestBarrier() {
						        var delays = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

						        _classCallCheck(this, RequestBarrier);

						        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

						        _this.BARRIER_TIMEOUT = 3000;

						        _this.delays = {
						            requestsCollection: delays.requestsCollection === void 0 ? REQUESTS_COLLECTION_DELAY_DEFAULT : delays.requestsCollection,

						            additionalRequestsCollection: delays.additionalRequestsCollection === void 0 ? REQUESTS_COLLECTION_DELAY_DEFAULT : delays.additionalRequestsCollection,

						            pageInitialRequestsCollection: delays.pageInitialRequestsCollection === void 0 ? REQUESTS_COLLECTION_DELAY_DEFAULT : delays.pageInitialRequestsCollection
						        };

						        _this.collectingReqs = true;
						        _this.requests = [];
						        _this.watchdog = null;

						        _this._unbindHandlers = null;

						        _this._init();
						        return _this;
						    }

						    RequestBarrier.prototype._init = function _init() {
						        var _this2 = this;

						        var onXhrSend = function onXhrSend(e) {
						            return _this2._onXhrSend(e.xhr);
						        };
						        var onXhrCompleted = function onXhrCompleted(e) {
						            return _this2._onRequestCompleted(e.xhr);
						        };
						        var onXhrError = function onXhrError(e) {
						            return _this2._onRequestError(e.xhr, e.err);
						        };
						        var onFetchSend = function onFetchSend(e) {
						            return _this2._onFetchSend(e);
						        };

						        _hammerhead2.default.on(_hammerhead2.default.EVENTS.beforeXhrSend, onXhrSend);
						        _hammerhead2.default.on(_hammerhead2.default.EVENTS.xhrCompleted, onXhrCompleted);
						        _hammerhead2.default.on(_hammerhead2.default.EVENTS.xhrError, onXhrError);
						        _hammerhead2.default.on(_hammerhead2.default.EVENTS.fetchSent, onFetchSend);

						        this._unbindHandlers = function () {
						            _hammerhead2.default.off(_hammerhead2.default.EVENTS.beforeXhrSend, onXhrSend);
						            _hammerhead2.default.off(_hammerhead2.default.EVENTS.xhrCompleted, onXhrCompleted);
						            _hammerhead2.default.off(_hammerhead2.default.EVENTS.xhrError, onXhrError);
						            _hammerhead2.default.off(_hammerhead2.default.EVENTS.fetchSent, onFetchSend);
						        };
						    };

						    RequestBarrier.prototype._onXhrSend = function _onXhrSend(request) {
						        if (this.collectingReqs) this.requests.push(request);
						    };

						    RequestBarrier.prototype._onRequestCompleted = function _onRequestCompleted(request) {
						        var _this3 = this;

						        // NOTE: let the last real XHR handler finish its job and try to obtain
						        // any additional requests if they were initiated by this handler
						        (0, _delay2.default)(this.delays.additionalRequestsCollection).then(function () {
						            return _this3._onRequestFinished(request);
						        });
						    };

						    RequestBarrier.prototype._onRequestError = function _onRequestError(request) {
						        this._onRequestFinished(request);
						    };

						    RequestBarrier.prototype._onRequestFinished = function _onRequestFinished(request) {
						        if ((0, _array.indexOf)(this.requests, request) > -1) {
						            (0, _array.remove)(this.requests, request);

						            if (!this.collectingReqs && !this.requests.length) this.emit(REQUESTS_FINISHED_EVENT);
						        }
						    };

						    RequestBarrier.prototype._onFetchSend = function _onFetchSend(request) {
						        var _this4 = this;

						        if (this.collectingReqs) {
						            this.requests.push(request);

						            request.then(function () {
						                return _this4._onRequestCompleted(request);
						            }).catch(function () {
						                return _this4._onRequestError(request);
						            });
						        }
						    };

						    RequestBarrier.prototype.wait = function wait(isPageLoad) {
						        var _this5 = this;

						        return new Promise(function (resolve) {
						            (0, _delay2.default)(isPageLoad ? _this5.delays.pageInitialRequestsCollection : _this5.delays.requestsCollection).then(function () {
						                _this5.collectingReqs = false;

						                var onRequestsFinished = function onRequestsFinished() {
						                    if (_this5.watchdog) nativeMethods.clearTimeout.call(window, _this5.watchdog);

						                    _this5._unbindHandlers();
						                    resolve();
						                };

						                if (_this5.requests.length) {
						                    _this5.watchdog = nativeMethods.setTimeout.call(window, onRequestsFinished, _this5.BARRIER_TIMEOUT);
						                    _this5.on(REQUESTS_FINISHED_EVENT, onRequestsFinished);
						                } else onRequestsFinished();
						            });
						        });
						    };

						    return RequestBarrier;
						}(_service.EventEmitter);

						exports.default = RequestBarrier;


						RequestBarrier.GLOBAL_REQUEST_BARRIER_FIELD = GLOBAL_REQUEST_BARRIER_FIELD;

						window[RequestBarrier.GLOBAL_REQUEST_BARRIER_FIELD] = RequestBarrier;
						module.exports = exports['default'];
					},
					"scroll-controller.js": function (exports, module, require) {
						

						exports.__esModule = true;

						var _hammerhead = require('./deps/hammerhead');

						var _service = require('./utils/service');

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

						var listeners = _hammerhead.eventSandbox.listeners;

						var ScrollController = function () {
						    function ScrollController() {
						        _classCallCheck(this, ScrollController);

						        this.initialized = false;
						        this.stopPropagationFlag = false;

						        this.events = new _service.EventEmitter();
						    }

						    ScrollController.prototype._internalListener = function _internalListener(event, dispatched, preventEvent, cancelHandlers, stopPropagation) {
						        this.events.emit('scroll', event);

						        if (this.stopPropagationFlag) {
						            cancelHandlers();
						            stopPropagation();
						        }
						    };

						    ScrollController.prototype.init = function init() {
						        var _this = this;

						        if (this.initialized) return;

						        this.initialized = true;

						        listeners.initElementListening(window, ['scroll']);
						        listeners.addFirstInternalHandler(window, ['scroll'], function () {
						            return _this._internalListener.apply(_this, arguments);
						        });
						    };

						    ScrollController.prototype.waitForScroll = function waitForScroll() {
						        var _this2 = this;

						        var promiseResolver = null;

						        var promise = new _hammerhead.Promise(function (resolve) {
						            promiseResolver = resolve;
						        });

						        promise.cancel = function () {
						            return _this2.events.off('scroll', promiseResolver);
						        };

						        if (this.initialized) this.events.once('scroll', promiseResolver);else promiseResolver();

						        return promise;
						    };

						    ScrollController.prototype.stopPropagation = function stopPropagation() {
						        this.stopPropagationFlag = true;
						    };

						    ScrollController.prototype.enablePropagation = function enablePropagation() {
						        this.stopPropagationFlag = false;
						    };

						    return ScrollController;
						}();

						exports.default = new ScrollController();
						module.exports = exports['default'];
					},
					"utils": {
						"array.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.toArray = toArray;
							exports.reverse = reverse;
							exports.isArray = isArray;
							exports.find = find;
							exports.indexOf = indexOf;
							exports.forEach = forEach;
							exports.some = some;
							exports.map = map;
							exports.filter = filter;
							exports.reduce = reduce;
							exports.remove = remove;
							exports.equals = equals;
							exports.getCommonElement = getCommonElement;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var nativeIndexOf = Array.prototype.indexOf;
							var nativeForEach = Array.prototype.forEach;
							var nativeSome = Array.prototype.some;
							var nativeMap = Array.prototype.map;
							var nativeFilter = Array.prototype.filter;
							var nativeReverse = Array.prototype.reverse;
							var nativeReduce = Array.prototype.reduce;
							var nativeSplice = Array.prototype.splice;

							function toArray(arg) {
							    var arr = [];
							    var length = arg.length;

							    for (var i = 0; i < length; i++) {
							        arr.push(arg[i]);
							    }return arr;
							}

							function reverse(arr) {
							    return nativeReverse.call(arr);
							}

							function isArray(arg) {
							    return _hammerhead2.default.nativeMethods.objectToString.call(arg) === '[object Array]';
							}

							function find(arr, callback) {
							    var length = arr.length;

							    for (var i = 0; i < length; i++) {
							        if (callback(arr[i], i, arr)) return arr[i];
							    }

							    return null;
							}

							function indexOf(arr, arg) {
							    return nativeIndexOf.call(arr, arg);
							}

							function forEach(arr, callback) {
							    nativeForEach.call(arr, callback);
							}

							function some(arr, callback) {
							    return nativeSome.call(arr, callback);
							}

							function map(arr, callback) {
							    return nativeMap.call(arr, callback);
							}

							function filter(arr, callback) {
							    return nativeFilter.call(arr, callback);
							}

							function reduce(arr, callback, initialValue) {
							    return nativeReduce.call(arr, callback, initialValue);
							}

							function remove(arr, item) {
							    var index = indexOf(arr, item);

							    if (index > -1) nativeSplice.call(arr, index, 1);
							}

							function equals(arr1, arr2) {
							    if (arr1.length !== arr2.length) return false;

							    for (var i = 0, l = arr1.length; i < l; i++) {
							        if (arr1[i] !== arr2[i]) return false;
							    }

							    return true;
							}

							function getCommonElement(arr1, arr2) {
							    for (var i = 0; i < arr1.length; i++) {
							        for (var t = 0; t < arr2.length; t++) {
							            if (arr1[i] === arr2[t]) return arr1[i];
							        }
							    }

							    return null;
							}
						},
						"content-editable.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.getFirstVisibleTextNode = getFirstVisibleTextNode;
							exports.getLastTextNode = getLastTextNode;
							exports.getFirstNonWhitespaceSymbolIndex = getFirstNonWhitespaceSymbolIndex;
							exports.getLastNonWhitespaceSymbolIndex = getLastNonWhitespaceSymbolIndex;
							exports.isInvisibleTextNode = isInvisibleTextNode;
							exports.findContentEditableParent = findContentEditableParent;
							exports.getNearestCommonAncestor = getNearestCommonAncestor;
							exports.getSelection = getSelection;
							exports.getSelectionStartPosition = getSelectionStartPosition;
							exports.getSelectionEndPosition = getSelectionEndPosition;
							exports.calculateNodeAndOffsetByPosition = calculateNodeAndOffsetByPosition;
							exports.calculatePositionByNodeAndOffset = calculatePositionByNodeAndOffset;
							exports.getElementBySelection = getElementBySelection;
							exports.getFirstVisiblePosition = getFirstVisiblePosition;
							exports.getLastVisiblePosition = getLastVisiblePosition;
							exports.getContentEditableValue = getContentEditableValue;

							var _dom = require('./dom');

							var domUtils = _interopRequireWildcard(_dom);

							var _array = require('./array');

							var arrayUtils = _interopRequireWildcard(_array);

							var _style = require('./style');

							var styleUtils = _interopRequireWildcard(_style);

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

							//nodes utils
							function getOwnFirstVisibleTextNode(el) {
							    var children = el.childNodes;
							    var childrenLength = domUtils.getChildNodesLength(children);

							    if (!childrenLength && isVisibleTextNode(el)) return el;

							    return arrayUtils.find(children, function (node) {
							        return isVisibleTextNode(node);
							    });
							}

							function getOwnFirstVisibleNode(el) {
							    return arrayUtils.find(el.childNodes, function (node) {
							        return isVisibleTextNode(node) || !isSkippableNode(node) && getOwnFirstVisibleNode(node);
							    });
							}

							function getOwnPreviousVisibleSibling(el) {
							    var sibling = null;
							    var current = el;

							    while (!sibling) {
							        current = current.previousSibling;
							        if (!current) break;else if (!isSkippableNode(current) && !isInvisibleTextNode(current)) {
							            sibling = current;
							            break;
							        }
							    }
							    return sibling;
							}

							function isVisibleNode(node) {
							    return domUtils.isTextNode(node) || domUtils.isElementNode(node) && styleUtils.isElementVisible(node);
							}

							function getVisibleChildren(node) {
							    return arrayUtils.filter(node.childNodes, isVisibleNode);
							}

							function hasVisibleChildren(node) {
							    return arrayUtils.some(node.childNodes, isVisibleNode);
							}

							function hasSelectableChildren(node) {
							    return arrayUtils.some(node.childNodes, function (child) {
							        return isNodeSelectable(child, true);
							    });
							}

							//NOTE: before such elements (like div or p) adds line breaks before and after it
							// (except line break before first visible element in contentEditable parent)
							// this line breaks is not contained in node values
							//so we should take it into account manually
							function isNodeBlockWithBreakLine(parent, node) {
							    var parentFirstVisibleChild = null;
							    var firstVisibleChild = null;

							    if (domUtils.isShadowUIElement(parent) || domUtils.isShadowUIElement(node)) return false;

							    if (!domUtils.isTheSameNode(node, parent) && domUtils.getChildNodesLength(node.childNodes) && /div|p/.test(domUtils.getTagName(node))) {
							        parentFirstVisibleChild = getOwnFirstVisibleNode(parent);

							        if (!parentFirstVisibleChild || domUtils.isTheSameNode(node, parentFirstVisibleChild)) return false;

							        firstVisibleChild = getFirstVisibleTextNode(parentFirstVisibleChild);
							        if (!firstVisibleChild || domUtils.isTheSameNode(node, firstVisibleChild)) return false;

							        return getOwnFirstVisibleTextNode(node);
							    }
							    return false;
							}

							function isNodeAfterNodeBlockWithBreakLine(parent, node) {
							    var isRenderedNode = domUtils.isRenderedNode(node);
							    var parentFirstVisibleChild = null;
							    var firstVisibleChild = null;
							    var previousSibling = null;

							    if (domUtils.isShadowUIElement(parent) || domUtils.isShadowUIElement(node)) return false;

							    if (!domUtils.isTheSameNode(node, parent) && (isRenderedNode && domUtils.isElementNode(node) && domUtils.getChildNodesLength(node.childNodes) && !/div|p/.test(domUtils.getTagName(node)) || isVisibleTextNode(node) && !domUtils.isTheSameNode(node, parent) && node.nodeValue.length)) {

							        if (isRenderedNode && domUtils.isElementNode(node)) {
							            parentFirstVisibleChild = getOwnFirstVisibleNode(parent);

							            if (!parentFirstVisibleChild || domUtils.isTheSameNode(node, parentFirstVisibleChild)) return false;

							            firstVisibleChild = getFirstVisibleTextNode(parentFirstVisibleChild);
							            if (!firstVisibleChild || domUtils.isTheSameNode(node, firstVisibleChild)) return false;
							        }

							        previousSibling = getOwnPreviousVisibleSibling(node);

							        return previousSibling && domUtils.isElementNode(previousSibling) && /div|p/.test(domUtils.getTagName(previousSibling)) && getOwnFirstVisibleTextNode(previousSibling);
							    }
							    return false;
							}

							function getFirstTextNode(el, onlyVisible) {
							    var children = el.childNodes;
							    var childrenLength = domUtils.getChildNodesLength(children);
							    var curNode = null;
							    var child = null;
							    var isNotContentEditableElement = null;
							    var checkTextNode = onlyVisible ? isVisibleTextNode : domUtils.isTextNode;

							    if (!childrenLength && checkTextNode(el)) return el;

							    for (var i = 0; i < childrenLength; i++) {
							        curNode = children[i];
							        isNotContentEditableElement = domUtils.isElementNode(curNode) && !domUtils.isContentEditableElement(curNode);

							        if (checkTextNode(curNode)) return curNode;else if (domUtils.isRenderedNode(curNode) && hasVisibleChildren(curNode) && !isNotContentEditableElement) {
							            child = getFirstTextNode(curNode, onlyVisible);

							            if (child) return child;
							        }
							    }

							    return child;
							}

							function getFirstVisibleTextNode(el) {
							    return getFirstTextNode(el, true);
							}

							function getLastTextNode(el, onlyVisible) {
							    var children = el.childNodes;
							    var childrenLength = domUtils.getChildNodesLength(children);
							    var curNode = null;
							    var child = null;
							    var isNotContentEditableElement = null;
							    var visibleTextNode = null;

							    if (!childrenLength && isVisibleTextNode(el)) return el;

							    for (var i = childrenLength - 1; i >= 0; i--) {
							        curNode = children[i];
							        isNotContentEditableElement = domUtils.isElementNode(curNode) && !domUtils.isContentEditableElement(curNode);
							        visibleTextNode = domUtils.isTextNode(curNode) && (onlyVisible ? !isInvisibleTextNode(curNode) : true);

							        if (visibleTextNode) return curNode;else if (domUtils.isRenderedNode(curNode) && hasVisibleChildren(curNode) && !isNotContentEditableElement) {
							            child = getLastTextNode(curNode, false);

							            if (child) return child;
							        }
							    }

							    return child;
							}

							function getFirstNonWhitespaceSymbolIndex(nodeValue, startFrom) {
							    if (!nodeValue || !nodeValue.length) return 0;

							    var valueLength = nodeValue.length;
							    var index = startFrom || 0;

							    for (var i = index; i < valueLength; i++) {
							        if (nodeValue.charCodeAt(i) === 10 || nodeValue.charCodeAt(i) === 32) index++;else break;
							    }
							    return index;
							}

							function getLastNonWhitespaceSymbolIndex(nodeValue) {
							    if (!nodeValue || !nodeValue.length) return 0;

							    var valueLength = nodeValue.length;
							    var index = valueLength;

							    for (var i = valueLength - 1; i >= 0; i--) {
							        if (nodeValue.charCodeAt(i) === 10 || nodeValue.charCodeAt(i) === 32) index--;else break;
							    }
							    return index;
							}

							function isInvisibleTextNode(node) {
							    if (!domUtils.isTextNode(node)) return false;

							    var nodeValue = node.nodeValue;
							    var firstVisibleIndex = getFirstNonWhitespaceSymbolIndex(nodeValue);
							    var lastVisibleIndex = getLastNonWhitespaceSymbolIndex(nodeValue);

							    return firstVisibleIndex === nodeValue.length && lastVisibleIndex === 0;
							}

							function isVisibleTextNode(node) {
							    return domUtils.isTextNode(node) && !isInvisibleTextNode(node);
							}

							function isSkippableNode(node) {
							    return !domUtils.isRenderedNode(node) || domUtils.isShadowUIElement(node);
							}

							//dom utils
							function hasContentEditableAttr(el) {
							    var attrValue = el.getAttribute ? el.getAttribute('contenteditable') : null;

							    return attrValue === '' || attrValue === 'true';
							}

							function findContentEditableParent(element) {
							    var elParents = domUtils.getParents(element);

							    if (hasContentEditableAttr(element) && domUtils.isContentEditableElement(element)) return element;

							    var currentDocument = domUtils.findDocument(element);

							    if (currentDocument.designMode === 'on') return currentDocument.body;

							    return arrayUtils.find(elParents, function (parent) {
							        return hasContentEditableAttr(parent) && domUtils.isContentEditableElement(parent);
							    });
							}

							function getNearestCommonAncestor(node1, node2) {
							    if (domUtils.isTheSameNode(node1, node2)) {
							        if (domUtils.isTheSameNode(node2, findContentEditableParent(node1))) return node1;
							        return node1.parentNode;
							    }

							    var ancestors = [];
							    var contentEditableParent = findContentEditableParent(node1);
							    var curNode = null;

							    if (!domUtils.isElementContainsNode(contentEditableParent, node2)) return null;

							    for (curNode = node1; curNode !== contentEditableParent; curNode = curNode.parentNode) {
							        ancestors.push(curNode);
							    }for (curNode = node2; curNode !== contentEditableParent; curNode = curNode.parentNode) {
							        if (arrayUtils.indexOf(ancestors, curNode) !== -1) return curNode;
							    }

							    return contentEditableParent;
							}

							//selection utils
							function getSelectedPositionInParentByOffset(node, offset) {
							    var currentNode = null;
							    var currentOffset = null;
							    var childCount = domUtils.getChildNodesLength(node.childNodes);
							    var isSearchForLastChild = offset >= childCount;

							    // NOTE: we get a child element by its offset index in the parent
							    if (domUtils.isShadowUIElement(node)) return { node: node, offset: offset };

							    // NOTE: IE behavior
							    if (isSearchForLastChild) currentNode = node.childNodes[childCount - 1];else {
							        currentNode = node.childNodes[offset];
							        currentOffset = 0;
							    }

							    // NOTE: skip shadowUI elements
							    if (domUtils.isShadowUIElement(currentNode)) {
							        if (childCount <= 1) return { node: node, offset: 0 };

							        isSearchForLastChild = offset - 1 >= childCount;

							        if (isSearchForLastChild) currentNode = node.childNodes[childCount - 2];else {
							            currentNode = node.childNodes[offset - 1];
							            currentOffset = 0;
							        }
							    }

							    // NOTE: we try to find text node
							    while (!isSkippableNode(currentNode) && domUtils.isElementNode(currentNode)) {
							        var visibleChildren = getVisibleChildren(currentNode);

							        if (visibleChildren.length) currentNode = visibleChildren[isSearchForLastChild ? visibleChildren.length - 1 : 0];else {
							            //NOTE: if we didn't find a text node then always set offset to zero
							            currentOffset = 0;
							            break;
							        }
							    }

							    if (currentOffset !== 0 && !isSkippableNode(currentNode)) currentOffset = currentNode.nodeValue ? currentNode.nodeValue.length : 0;

							    return {
							        node: currentNode,
							        offset: currentOffset
							    };
							}

							function getSelectionStart(el, selection, inverseSelection) {
							    var startNode = inverseSelection ? selection.focusNode : selection.anchorNode;
							    var startOffset = inverseSelection ? selection.focusOffset : selection.anchorOffset;

							    var correctedStartPosition = {
							        node: startNode,
							        offset: startOffset
							    };

							    //NOTE: window.getSelection() can't returns not rendered node like selected node, so we shouldn't check it
							    if ((domUtils.isTheSameNode(el, startNode) || domUtils.isElementNode(startNode)) && hasSelectableChildren(startNode)) correctedStartPosition = getSelectedPositionInParentByOffset(startNode, startOffset);

							    return {
							        node: correctedStartPosition.node,
							        offset: correctedStartPosition.offset
							    };
							}

							function getSelectionEnd(el, selection, inverseSelection) {
							    var endNode = inverseSelection ? selection.anchorNode : selection.focusNode;
							    var endOffset = inverseSelection ? selection.anchorOffset : selection.focusOffset;

							    var correctedEndPosition = {
							        node: endNode,
							        offset: endOffset
							    };

							    //NOTE: window.getSelection() can't returns not rendered node like selected node, so we shouldn't check it
							    if ((domUtils.isTheSameNode(el, endNode) || domUtils.isElementNode(endNode)) && hasSelectableChildren(endNode)) correctedEndPosition = getSelectedPositionInParentByOffset(endNode, endOffset);

							    return {
							        node: correctedEndPosition.node,
							        offset: correctedEndPosition.offset
							    };
							}

							function getSelection(el, selection, inverseSelection) {
							    return {
							        startPos: getSelectionStart(el, selection, inverseSelection),
							        endPos: getSelectionEnd(el, selection, inverseSelection)
							    };
							}

							function getSelectionStartPosition(el, selection, inverseSelection) {
							    var correctedSelectionStart = getSelectionStart(el, selection, inverseSelection);

							    return calculatePositionByNodeAndOffset(el, correctedSelectionStart);
							}

							function getSelectionEndPosition(el, selection, inverseSelection) {
							    var correctedSelectionEnd = getSelectionEnd(el, selection, inverseSelection);

							    return calculatePositionByNodeAndOffset(el, correctedSelectionEnd);
							}

							function getElementOffset(target) {
							    var offset = 0;

							    var firstBreakElement = arrayUtils.find(target.childNodes, function (node, index) {
							        offset = index;
							        return domUtils.getTagName(node) === 'br';
							    });

							    return firstBreakElement ? offset : 0;
							}

							function isNodeSelectable(node, includeDescendants) {
							    if (styleUtils.isNotVisibleNode(node)) return false;

							    if (domUtils.isTextNode(node)) return true;

							    if (!domUtils.isElementNode(node)) return false;

							    if (hasSelectableChildren(node)) return includeDescendants;

							    var isContentEditableRoot = !domUtils.isContentEditableElement(node.parentNode);
							    var visibleChildren = getVisibleChildren(node);
							    var hasBreakLineElements = arrayUtils.some(visibleChildren, function (child) {
							        return domUtils.getTagName(child) === 'br';
							    });

							    return isContentEditableRoot || hasBreakLineElements;
							}

							function calculateNodeAndOffsetByPosition(el, offset) {
							    var point = {
							        node: null,
							        offset: offset
							    };

							    function checkChildNodes(target) {
							        var childNodes = target.childNodes;
							        var childNodesLength = domUtils.getChildNodesLength(childNodes);

							        if (point.node) return point;

							        if (isSkippableNode(target)) return point;

							        if (domUtils.isTextNode(target)) {
							            if (point.offset <= target.nodeValue.length) {
							                point.node = target;
							                return point;
							            } else if (target.nodeValue.length) {
							                if (!point.node && isNodeAfterNodeBlockWithBreakLine(el, target)) point.offset--;

							                point.offset -= target.nodeValue.length;
							            }
							        } else if (domUtils.isElementNode(target)) {
							            if (!isVisibleNode(target)) return point;

							            if (point.offset === 0 && isNodeSelectable(target, false)) {
							                point.node = target;
							                point.offset = getElementOffset(target);

							                return point;
							            }
							            if (!point.node && (isNodeBlockWithBreakLine(el, target) || isNodeAfterNodeBlockWithBreakLine(el, target))) point.offset--;else if (!childNodesLength && domUtils.getTagName(target) === 'br') point.offset--;
							        }

							        arrayUtils.forEach(childNodes, function (node) {
							            point = checkChildNodes(node);
							        });

							        return point;
							    }

							    return checkChildNodes(el);
							}

							function calculatePositionByNodeAndOffset(el, _ref) {
							    var node = _ref.node,
							        offset = _ref.offset;

							    var currentOffset = 0;
							    var find = false;

							    function checkChildNodes(target) {
							        var childNodes = target.childNodes;
							        var childNodesLength = domUtils.getChildNodesLength(childNodes);

							        if (find) return currentOffset;

							        if (domUtils.isTheSameNode(node, target)) {
							            if (isNodeBlockWithBreakLine(el, target) || isNodeAfterNodeBlockWithBreakLine(el, target)) currentOffset++;

							            find = true;
							            return currentOffset + offset;
							        }

							        if (isSkippableNode(target)) return currentOffset;

							        if (!childNodesLength && target.nodeValue && target.nodeValue.length) {
							            if (!find && isNodeAfterNodeBlockWithBreakLine(el, target)) currentOffset++;

							            currentOffset += target.nodeValue.length;
							        } else if (!childNodesLength && domUtils.isElementNode(target) && domUtils.getTagName(target) === 'br') currentOffset++;else if (!find && (isNodeBlockWithBreakLine(el, target) || isNodeAfterNodeBlockWithBreakLine(el, target))) currentOffset++;

							        arrayUtils.forEach(childNodes, function (currentNode) {
							            currentOffset = checkChildNodes(currentNode);
							        });

							        return currentOffset;
							    }

							    return checkChildNodes(el);
							}

							function getElementBySelection(selection) {
							    var el = getNearestCommonAncestor(selection.anchorNode, selection.focusNode);

							    return domUtils.isTextNode(el) ? el.parentElement : el;
							}

							//NOTE: We can not determine first visible symbol of node in all cases,
							// so we should create a range and select all text contents of the node.
							// Then range object will contain information about node's the first and last visible symbol.
							function getFirstVisiblePosition(el) {
							    var firstVisibleTextChild = domUtils.isTextNode(el) ? el : getFirstVisibleTextNode(el);
							    var curDocument = domUtils.findDocument(el);
							    var range = curDocument.createRange();

							    if (firstVisibleTextChild) {
							        range.selectNodeContents(firstVisibleTextChild);

							        return calculatePositionByNodeAndOffset(el, { node: firstVisibleTextChild, offset: range.startOffset });
							    }

							    return 0;
							}

							function getLastVisiblePosition(el) {
							    var lastVisibleTextChild = domUtils.isTextNode(el) ? el : getLastTextNode(el, true);

							    if (!lastVisibleTextChild || isResetAnchorOffsetRequired(lastVisibleTextChild, el)) return 0;

							    var curDocument = domUtils.findDocument(el);
							    var range = curDocument.createRange();

							    range.selectNodeContents(lastVisibleTextChild);

							    return calculatePositionByNodeAndOffset(el, { node: lastVisibleTextChild, offset: range.endOffset });
							}

							function isResetAnchorOffsetRequired(lastVisibleTextChild, el) {
							    var firstVisibleTextChild = domUtils.isTextNode(el) ? el : getFirstTextNode(el, false);
							    var isSingleTextNode = lastVisibleTextChild === firstVisibleTextChild;
							    var isNewLineChar = lastVisibleTextChild.nodeValue === String.fromCharCode(10);

							    return isSingleTextNode && isNewLineChar && hasWhiteSpacePreStyle(lastVisibleTextChild, el);
							}

							function hasWhiteSpacePreStyle(el, container) {
							    var whiteSpacePreStyles = ['pre', 'pre-wrap', 'pre-line'];

							    while (el !== container) {
							        el = el.parentNode;

							        if (arrayUtils.indexOf(whiteSpacePreStyles, styleUtils.get(el, 'white-space')) > -1) return true;
							    }

							    return false;
							}

							function getContentEditableNodes(target) {
							    var result = [];
							    var childNodes = target.childNodes;
							    var childNodesLength = domUtils.getChildNodesLength(childNodes);

							    if (!isSkippableNode(target) && !childNodesLength && domUtils.isTextNode(target)) result.push(target);

							    arrayUtils.forEach(childNodes, function (node) {
							        result = result.concat(getContentEditableNodes(node));
							    });

							    return result;
							}

							// contents util
							function getContentEditableValue(target) {
							    return arrayUtils.map(getContentEditableNodes(target), function (node) {
							        return node.nodeValue;
							    }).join('');
							}
						},
						"delay.js": function (exports, module, require) {
							

							exports.__esModule = true;

							exports.default = function (ms) {
							    return new Promise(function (resolve) {
							        return nativeMethods.setTimeout.call(window, resolve, ms);
							    });
							};

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var Promise = _hammerhead2.default.Promise;
							var nativeMethods = _hammerhead2.default.nativeMethods;

							module.exports = exports['default'];
						},
						"dom.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.getTopSameDomainWindow = exports.getParents = exports.closest = exports.getTagName = exports.getMapContainer = exports.getScrollbarSize = exports.isElementReadOnly = exports.isHammerheadAttr = exports.isElementFocusable = exports.isShadowUIElement = exports.isDomElement = exports.isContentEditableElement = exports.isTextEditableElementAndEditingAllowed = exports.isTextEditableElement = exports.isTextEditableInput = exports.isWindow = exports.isDocument = exports.isHtmlElement = exports.isBodyElement = exports.isMapElement = exports.isSVGElement = exports.isOptionElement = exports.isSelectElement = exports.isFormElement = exports.isImgElement = exports.isAnchorElement = exports.isTextAreaElement = exports.isFileInput = exports.isButtonElement = exports.isInputElement = exports.isIframeElement = exports.isRenderedNode = exports.isTextNode = exports.isElementNode = exports.getSelectVisibleChildren = exports.getChildVisibleIndex = exports.getSelectParent = exports.isCrossDomainWindows = exports.getIframeByElement = exports.isElementInIframe = exports.isElementInDocument = exports.findDocument = exports.getActiveElement = undefined;
							exports.containsElement = containsElement;
							exports.getTextareaIndentInLine = getTextareaIndentInLine;
							exports.getTextareaLineNumberByPosition = getTextareaLineNumberByPosition;
							exports.getTextareaPositionByLineAndOffset = getTextareaPositionByLineAndOffset;
							exports.blocksImplicitSubmission = blocksImplicitSubmission;
							exports.isEditableElement = isEditableElement;
							exports.isElementContainsNode = isElementContainsNode;
							exports.isOptionGroupElement = isOptionGroupElement;
							exports.getElementIndexInParent = getElementIndexInParent;
							exports.isTheSameNode = isTheSameNode;
							exports.getElementDescription = getElementDescription;
							exports.getNextFocusableElement = getNextFocusableElement;
							exports.getFocusableParent = getFocusableParent;
							exports.remove = remove;
							exports.isIFrameWindowInDOM = isIFrameWindowInDOM;
							exports.isTopWindow = isTopWindow;
							exports.findIframeByWindow = findIframeByWindow;
							exports.isEditableFormElement = isEditableFormElement;
							exports.getCommonAncestor = getCommonAncestor;
							exports.getChildrenLength = getChildrenLength;
							exports.getChildNodesLength = getChildNodesLength;
							exports.getInputValue = getInputValue;
							exports.getTextAreaValue = getTextAreaValue;
							exports.setInputValue = setInputValue;
							exports.setTextAreaValue = setTextAreaValue;
							exports.getElementValue = getElementValue;
							exports.setElementValue = setElementValue;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _style = require('./style');

							var styleUtils = _interopRequireWildcard(_style);

							var _array = require('./array');

							var arrayUtils = _interopRequireWildcard(_array);

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var browserUtils = _hammerhead2.default.utils.browser;
							var nativeMethods = _hammerhead2.default.nativeMethods;

							var getActiveElement = exports.getActiveElement = _hammerhead2.default.utils.dom.getActiveElement;
							var findDocument = exports.findDocument = _hammerhead2.default.utils.dom.findDocument;
							var isElementInDocument = exports.isElementInDocument = _hammerhead2.default.utils.dom.isElementInDocument;
							var isElementInIframe = exports.isElementInIframe = _hammerhead2.default.utils.dom.isElementInIframe;
							var getIframeByElement = exports.getIframeByElement = _hammerhead2.default.utils.dom.getIframeByElement;
							var isCrossDomainWindows = exports.isCrossDomainWindows = _hammerhead2.default.utils.dom.isCrossDomainWindows;
							var getSelectParent = exports.getSelectParent = _hammerhead2.default.utils.dom.getSelectParent;
							var getChildVisibleIndex = exports.getChildVisibleIndex = _hammerhead2.default.utils.dom.getChildVisibleIndex;
							var getSelectVisibleChildren = exports.getSelectVisibleChildren = _hammerhead2.default.utils.dom.getSelectVisibleChildren;
							var isElementNode = exports.isElementNode = _hammerhead2.default.utils.dom.isElementNode;
							var isTextNode = exports.isTextNode = _hammerhead2.default.utils.dom.isTextNode;
							var isRenderedNode = exports.isRenderedNode = _hammerhead2.default.utils.dom.isRenderedNode;
							var isIframeElement = exports.isIframeElement = _hammerhead2.default.utils.dom.isIframeElement;
							var isInputElement = exports.isInputElement = _hammerhead2.default.utils.dom.isInputElement;
							var isButtonElement = exports.isButtonElement = _hammerhead2.default.utils.dom.isButtonElement;
							var isFileInput = exports.isFileInput = _hammerhead2.default.utils.dom.isFileInput;
							var isTextAreaElement = exports.isTextAreaElement = _hammerhead2.default.utils.dom.isTextAreaElement;
							var isAnchorElement = exports.isAnchorElement = _hammerhead2.default.utils.dom.isAnchorElement;
							var isImgElement = exports.isImgElement = _hammerhead2.default.utils.dom.isImgElement;
							var isFormElement = exports.isFormElement = _hammerhead2.default.utils.dom.isFormElement;
							var isSelectElement = exports.isSelectElement = _hammerhead2.default.utils.dom.isSelectElement;
							var isOptionElement = exports.isOptionElement = _hammerhead2.default.utils.dom.isOptionElement;
							var isSVGElement = exports.isSVGElement = _hammerhead2.default.utils.dom.isSVGElement;
							var isMapElement = exports.isMapElement = _hammerhead2.default.utils.dom.isMapElement;
							var isBodyElement = exports.isBodyElement = _hammerhead2.default.utils.dom.isBodyElement;
							var isHtmlElement = exports.isHtmlElement = _hammerhead2.default.utils.dom.isHtmlElement;
							var isDocument = exports.isDocument = _hammerhead2.default.utils.dom.isDocument;
							var isWindow = exports.isWindow = _hammerhead2.default.utils.dom.isWindow;
							var isTextEditableInput = exports.isTextEditableInput = _hammerhead2.default.utils.dom.isTextEditableInput;
							var isTextEditableElement = exports.isTextEditableElement = _hammerhead2.default.utils.dom.isTextEditableElement;
							var isTextEditableElementAndEditingAllowed = exports.isTextEditableElementAndEditingAllowed = _hammerhead2.default.utils.dom.isTextEditableElementAndEditingAllowed;
							var isContentEditableElement = exports.isContentEditableElement = _hammerhead2.default.utils.dom.isContentEditableElement;
							var isDomElement = exports.isDomElement = _hammerhead2.default.utils.dom.isDomElement;
							var isShadowUIElement = exports.isShadowUIElement = _hammerhead2.default.utils.dom.isShadowUIElement;
							var isElementFocusable = exports.isElementFocusable = _hammerhead2.default.utils.dom.isElementFocusable;
							var isHammerheadAttr = exports.isHammerheadAttr = _hammerhead2.default.utils.dom.isHammerheadAttr;
							var isElementReadOnly = exports.isElementReadOnly = _hammerhead2.default.utils.dom.isElementReadOnly;
							var getScrollbarSize = exports.getScrollbarSize = _hammerhead2.default.utils.dom.getScrollbarSize;
							var getMapContainer = exports.getMapContainer = _hammerhead2.default.utils.dom.getMapContainer;
							var getTagName = exports.getTagName = _hammerhead2.default.utils.dom.getTagName;
							var closest = exports.closest = _hammerhead2.default.utils.dom.closest;
							var getParents = exports.getParents = _hammerhead2.default.utils.dom.getParents;
							var getTopSameDomainWindow = exports.getTopSameDomainWindow = _hammerhead2.default.utils.dom.getTopSameDomainWindow;

							function getElementsWithTabIndex(elements) {
							    return arrayUtils.filter(elements, function (el) {
							        return el.tabIndex > 0;
							    });
							}

							function getElementsWithoutTabIndex(elements) {
							    return arrayUtils.filter(elements, function (el) {
							        return el.tabIndex <= 0;
							    });
							}

							function sortElementsByFocusingIndex(elements) {
							    if (!elements || !elements.length) return [];

							    var elementsWithTabIndex = getElementsWithTabIndex(elements);

							    //iFrames
							    var iFrames = arrayUtils.filter(elements, function (el) {
							        return isIframeElement(el);
							    });

							    if (!elementsWithTabIndex.length) {
							        if (iFrames.length) elements = insertIFramesContentElements(elements, iFrames);

							        return elements;
							    }

							    elementsWithTabIndex = elementsWithTabIndex.sort(sortBy('tabIndex'));
							    var elementsWithoutTabIndex = getElementsWithoutTabIndex(elements);

							    if (iFrames.length) return insertIFramesContentElements(elementsWithTabIndex, iFrames).concat(insertIFramesContentElements(elementsWithoutTabIndex, iFrames));

							    return elementsWithTabIndex.concat(elementsWithoutTabIndex);
							}

							function insertIFramesContentElements(elements, iFrames) {
							    var sortedIFrames = sortElementsByTabIndex(iFrames);
							    var results = [];
							    var iFramesElements = [];
							    var iframeFocusedElements = [];
							    var i = 0;

							    for (i = 0; i < sortedIFrames.length; i++) {
							        //NOTE: We can get elements of the same domain iframe only
							        try {
							            iframeFocusedElements = getFocusableElements(sortedIFrames[i].contentDocument);
							        } catch (e) {
							            iframeFocusedElements = [];
							        }

							        iFramesElements.push(sortElementsByFocusingIndex(iframeFocusedElements));
							    }

							    for (i = 0; i < elements.length; i++) {
							        results.push(elements[i]);

							        if (isIframeElement(elements[i])) {
							            if (browserUtils.isIE) {
							                results.pop();

							                var iFrameElements = iFramesElements[arrayUtils.indexOf(iFrames, elements[i])];
							                var elementsWithTabIndex = getElementsWithTabIndex(iFrameElements);
							                var elementsWithoutTabIndexArray = getElementsWithoutTabIndex(iFrameElements);

							                elementsWithTabIndex = elementsWithTabIndex.sort(sortBy('tabIndex'));
							                results = results.concat(elementsWithTabIndex);
							                results.push(elements[i]);
							                results = results.concat(elementsWithoutTabIndexArray);
							            } else {
							                if (browserUtils.isWebKit && iFramesElements[arrayUtils.indexOf(iFrames, elements[i])].length) results.pop();

							                results = results.concat(iFramesElements[arrayUtils.indexOf(iFrames, elements[i])]);
							            }
							        }
							    }

							    return results;
							}

							function sortElementsByTabIndex(elements) {
							    var elementsWithTabIndex = getElementsWithTabIndex(elements);

							    if (!elementsWithTabIndex.length) return elements;

							    return elementsWithTabIndex.sort(sortBy('tabIndex')).concat(getElementsWithoutTabIndex(elements));
							}

							function sortBy(property) {
							    return function (a, b) {
							        if (a[property] < b[property]) return -1;
							        if (a[property] > b[property]) return 1;

							        return 0;
							    };
							}

							function getFocusableElements(doc) {
							    // NOTE: We don't take into account the case of embedded contentEditable
							    // elements and specify the contentEditable attribute for focusable elements
							    var allElements = doc.querySelectorAll('*');
							    var invisibleElements = getInvisibleElements(allElements);
							    var inputElementsRegExp = /^(input|button|select|textarea)$/;
							    var focusableElements = [];
							    var element = null;
							    var tagName = null;
							    var tabIndex = null;

							    var needPush = false;

							    for (var i = 0; i < allElements.length; i++) {
							        element = allElements[i];
							        tagName = getTagName(element);
							        tabIndex = getTabIndexAttributeIntValue(element);
							        needPush = false;

							        if (element.disabled) continue;

							        if (styleUtils.get(element, 'display') === 'none' || styleUtils.get(element, 'visibility') === 'hidden') continue;

							        if ((browserUtils.isIE || browserUtils.isAndroid) && isOptionElement(element)) continue;

							        if (tabIndex !== null && tabIndex < 0) continue;

							        if (inputElementsRegExp.test(tagName)) needPush = true;else if (browserUtils.isIE && isIframeElement(element)) focusableElements.push(element);else if (isAnchorElement(element) && element.hasAttribute('href')) needPush = element.getAttribute('href') !== '' || !browserUtils.isIE || tabIndex !== null;

							        var contentEditableAttr = element.getAttribute('contenteditable');

							        if (contentEditableAttr === '' || contentEditableAttr === 'true') needPush = true;

							        if (tabIndex !== null) needPush = true;

							        if (needPush) focusableElements.push(element);
							    }

							    //NOTE: remove children of invisible elements
							    return arrayUtils.filter(focusableElements, function (el) {
							        return !containsElement(invisibleElements, el);
							    });
							}

							function getInvisibleElements(elements) {
							    var invisibleElements = [];

							    for (var i = 0; i < elements.length; i++) {
							        if (styleUtils.get(elements[i], 'display') === 'none') invisibleElements.push(elements[i]);
							    }

							    return invisibleElements;
							}

							function getTabIndexAttributeIntValue(el) {
							    var tabIndex = el.getAttribute('tabIndex');

							    if (tabIndex !== null) {
							        tabIndex = parseInt(tabIndex, 10);
							        tabIndex = isNaN(tabIndex) ? null : tabIndex;
							    }

							    return tabIndex;
							}

							function containsElement(elements, element) {
							    if (elements.contains) return elements.contains(element);

							    return arrayUtils.some(elements, function (parent) {
							        return parent.contains(element);
							    });
							}

							function getTextareaIndentInLine(textarea, position) {
							    var textareaValue = getTextAreaValue(textarea);

							    if (!textareaValue) return 0;

							    var topPart = textareaValue.substring(0, position);
							    var linePosition = topPart.lastIndexOf('\n') === -1 ? 0 : topPart.lastIndexOf('\n') + 1;

							    return position - linePosition;
							}

							function getTextareaLineNumberByPosition(textarea, position) {
							    var textareaValue = getTextAreaValue(textarea);
							    var lines = textareaValue.split('\n');
							    var topPartLength = 0;
							    var line = 0;

							    for (var i = 0; topPartLength <= position; i++) {
							        if (position <= topPartLength + lines[i].length) {
							            line = i;

							            break;
							        }

							        topPartLength += lines[i].length + 1;
							    }

							    return line;
							}

							function getTextareaPositionByLineAndOffset(textarea, line, offset) {
							    var textareaValue = getTextAreaValue(textarea);
							    var lines = textareaValue.split('\n');
							    var lineIndex = 0;

							    for (var i = 0; i < line; i++) {
							        lineIndex += lines[i].length + 1;
							    }return lineIndex + offset;
							}

							// NOTE: the form is also submitted on enter key press if there is only one input of certain
							// types (referred to as types that block implicit submission in the HTML5 standard) on the
							// form and this input is focused (http://www.w3.org/TR/html5/forms.html#implicit-submission)
							function blocksImplicitSubmission(el) {
							    var inputTypeRegExp = null;

							    if (browserUtils.isSafari) inputTypeRegExp = /^(text|password|color|date|time|datetime|datetime-local|email|month|number|search|tel|url|week|image)$/i;else if (browserUtils.isFirefox) inputTypeRegExp = /^(text|password|date|time|datetime|datetime-local|email|month|number|search|tel|url|week|image)$/i;else if (browserUtils.isIE) inputTypeRegExp = /^(text|password|color|date|time|datetime|datetime-local|email|file|month|number|search|tel|url|week|image)$/i;else inputTypeRegExp = /^(text|password|datetime|email|number|search|tel|url|image)$/i;

							    return inputTypeRegExp.test(el.type);
							}

							function isEditableElement(el, checkEditingAllowed) {
							    return checkEditingAllowed ? isTextEditableElementAndEditingAllowed(el) || isContentEditableElement(el) : isTextEditableElement(el) || isContentEditableElement(el);
							}

							function isElementContainsNode(parentElement, childNode) {
							    var contains = false;

							    function checkChildNodes(el, node) {
							        if (contains || isTheSameNode(node, el)) contains = true;

							        for (var i = 0; i < el.childNodes.length; i++) {
							            contains = checkChildNodes(el.childNodes[i], node);

							            if (contains) return contains;
							        }

							        return contains;
							    }

							    return checkChildNodes(parentElement, childNode);
							}

							function isOptionGroupElement(element) {
							    return _hammerhead2.default.utils.dom.instanceToString(element) === '[object HTMLOptGroupElement]';
							}

							function getElementIndexInParent(parent, child) {
							    var children = parent.querySelectorAll(getTagName(child));

							    return arrayUtils.indexOf(children, child);
							}

							function isTheSameNode(node1, node2) {
							    //NOTE: Mozilla has not isSameNode method
							    if (node1 && node2 && node1.isSameNode) return node1.isSameNode(node2);

							    return node1 === node2;
							}

							function getElementDescription(el) {
							    var attributes = {
							        id: 'id',
							        name: 'name',
							        'class': 'className'
							    };

							    var res = [];

							    res.push('<');
							    res.push(getTagName(el));

							    for (var attr in attributes) {
							        if (attributes.hasOwnProperty(attr)) {
							            var val = el[attributes[attr]];

							            if (val) res.push(' ' + attr + '="' + val + '"');
							        }
							    }

							    res.push('>');

							    return res.join('');
							}

							function getNextFocusableElement(element, reverse) {
							    var offset = reverse ? -1 : 1;
							    var allFocusable = sortElementsByFocusingIndex(getFocusableElements(findDocument(element)));

							    //NOTE: in all browsers except Mozilla and Opera focus sets on one radio set from group only.
							    // in Mozilla and Opera focus sets on any radio set.
							    if (isInputElement(element) && element.type === 'radio' && element.name !== '' && !browserUtils.isFirefox) {
							        allFocusable = arrayUtils.filter(allFocusable, function (item) {
							            return !item.name || item === element || item.name !== element.name;
							        });
							    }

							    var currentIndex = arrayUtils.indexOf(allFocusable, element);
							    var isLastElementFocused = reverse ? currentIndex === 0 : currentIndex === allFocusable.length - 1;

							    if (isLastElementFocused) return document.body;

							    if (reverse && currentIndex === -1) return allFocusable[allFocusable.length - 1];

							    return allFocusable[currentIndex + offset];
							}

							function getFocusableParent(el) {
							    var parents = getParents(el);

							    for (var i = 0; i < parents.length; i++) {
							        if (isElementFocusable(parents[i])) return parents[i];
							    }

							    return null;
							}

							function remove(el) {
							    if (el && el.parentElement) el.parentElement.removeChild(el);
							}

							function isIFrameWindowInDOM(win) {
							    //NOTE: In MS Edge, if an iframe is removed from DOM, the browser throws an exception when accessing window.top
							    //and window.frameElement. Fortunately, setTimeout is set to undefined in this case.
							    if (!win.setTimeout) return false;

							    var frameElement = null;

							    try {
							        //NOTE: This may raise a cross-domain policy error in some browsers.
							        frameElement = win.frameElement;
							    } catch (e) {
							        return !!win.top;
							    }

							    // NOTE: in Firefox and WebKit, frameElement is null for cross-domain iframes even if they are in the DOM.
							    // But these browsers don't execute scripts in removed iframes, so we suppose that the iframe is in the DOM.
							    if ((browserUtils.isFirefox || browserUtils.isWebKit) && win.top !== win && !frameElement) return true;

							    return !!(frameElement && frameElement.contentDocument);
							}

							function isTopWindow(win) {
							    try {
							        //NOTE: MS Edge throws an exception when trying to access window.top from an iframe removed from DOM
							        return win.top === win;
							    } catch (e) {
							        return false;
							    }
							}

							function findIframeByWindow(iframeWindow, iframeDestinationWindow) {
							    var iframes = (iframeDestinationWindow || window).document.getElementsByTagName('iframe');

							    for (var i = 0; i < iframes.length; i++) {
							        if (iframes[i].contentWindow === iframeWindow) return iframes[i];
							    }

							    return null;
							}

							function isEditableFormElement(element) {
							    return isTextEditableElement(element) || isSelectElement(element);
							}

							function getCommonAncestor(element1, element2) {
							    if (isTheSameNode(element1, element2)) return element1;

							    var el1Parents = [element1].concat(getParents(element1));
							    var commonAncestor = element2;

							    while (commonAncestor) {
							        if (arrayUtils.indexOf(el1Parents, commonAncestor) > -1) return commonAncestor;

							        commonAncestor = commonAncestor.parentNode;
							    }

							    return commonAncestor;
							}

							function getChildrenLength(children) {
							    return nativeMethods.htmlCollectionLengthGetter.call(children);
							}

							function getChildNodesLength(childNodes) {
							    return nativeMethods.nodeListLengthGetter.call(childNodes);
							}

							function getInputValue(input) {
							    return nativeMethods.inputValueGetter.call(input);
							}

							function getTextAreaValue(textArea) {
							    return nativeMethods.textAreaValueGetter.call(textArea);
							}

							function setInputValue(input, value) {
							    return nativeMethods.inputValueSetter.call(input, value);
							}

							function setTextAreaValue(textArea, value) {
							    return nativeMethods.textAreaValueSetter.call(textArea, value);
							}

							function getElementValue(element) {
							    if (isInputElement(element)) return getInputValue(element);else if (isTextAreaElement(element)) return getTextAreaValue(element);

							    /*eslint-disable no-restricted-properties*/
							    return element.value;
							    /*eslint-enable no-restricted-properties*/
							}

							function setElementValue(element, value) {
							    if (isInputElement(element)) return setInputValue(element, value);else if (isTextAreaElement(element)) return setTextAreaValue(element, value);

							    /*eslint-disable no-restricted-properties*/
							    element.value = value;
							    /*eslint-enable no-restricted-properties*/

							    return value;
							}
						},
						"event.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.preventDefault = exports.WHICH_PARAMETER = exports.DOM_EVENTS = exports.BUTTONS_PARAMETER = exports.BUTTON = exports.RECORDING_LISTENED_EVENTS = undefined;
							exports.bind = bind;
							exports.unbind = unbind;
							exports.documentReady = documentReady;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _delay = require('./delay');

							var _delay2 = _interopRequireDefault(_delay);

							var _dom = require('./dom');

							var domUtils = _interopRequireWildcard(_dom);

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var Promise = _hammerhead2.default.Promise;
							var nativeMethods = _hammerhead2.default.nativeMethods;
							var listeners = _hammerhead2.default.eventSandbox.listeners;

							var RECORDING_LISTENED_EVENTS = exports.RECORDING_LISTENED_EVENTS = ['click', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'mousemove', 'mouseover', 'mouseout', 'touchstart', 'touchmove', 'touchend', 'keydown', 'keypress', 'input', 'keyup', 'change', 'focus', 'blur', 'MSPointerDown', 'MSPointerMove', 'MSPointerOver', 'MSPointerOut', 'MSPointerUp', 'pointerdown', 'pointermove', 'pointerover', 'pointerout', 'pointerup'];

							// Imported form the hammerhead
							var BUTTON = exports.BUTTON = _hammerhead2.default.utils.event.BUTTON;
							var BUTTONS_PARAMETER = exports.BUTTONS_PARAMETER = _hammerhead2.default.utils.event.BUTTONS_PARAMETER;
							var DOM_EVENTS = exports.DOM_EVENTS = _hammerhead2.default.utils.event.DOM_EVENTS;
							var WHICH_PARAMETER = exports.WHICH_PARAMETER = _hammerhead2.default.utils.event.WHICH_PARAMETER;

							var preventDefault = exports.preventDefault = _hammerhead2.default.utils.event.preventDefault;

							function bind(el, event, handler, useCapture) {
							    if (domUtils.isWindow(el)) nativeMethods.windowAddEventListener.call(el, event, handler, useCapture);else nativeMethods.addEventListener.call(el, event, handler, useCapture);
							}

							function unbind(el, event, handler, useCapture) {
							    if (domUtils.isWindow(el)) nativeMethods.windowRemoveEventListener.call(el, event, handler, useCapture);else nativeMethods.removeEventListener.call(el, event, handler, useCapture);
							}

							// Document ready
							var waitForDomContentLoaded = function waitForDomContentLoaded() {
							    // NOTE: We can't use a regular Promise here, because window.load event can happen in the same event loop pass
							    // The default Promise will call resolve handlers in the next pass, and load event will be lost.
							    var resolveHandlers = [];

							    function createPromiseResolver(resolveHandler) {
							        return new Promise(function (resolve) {
							            return resolveHandlers.push(function () {
							                return resolve(resolveHandler());
							            });
							        });
							    }

							    var isReady = false;

							    function ready() {
							        if (isReady) return;

							        if (!document.body) {
							            nativeMethods.setTimeout.call(window, ready, 1);
							            return;
							        }

							        isReady = true;

							        resolveHandlers.forEach(function (handler) {
							            return handler();
							        });
							    }

							    function onContentLoaded() {
							        if (!domUtils.isIFrameWindowInDOM(window) && !domUtils.isTopWindow(window)) return;

							        unbind(document, 'DOMContentLoaded', onContentLoaded);
							        ready();
							    }

							    if (document.readyState === 'complete') nativeMethods.setTimeout.call(window, onContentLoaded, 1);else bind(document, 'DOMContentLoaded', onContentLoaded);

							    return { then: function then(handler) {
							            return createPromiseResolver(handler);
							        } };
							};

							var waitForWindowLoad = function waitForWindowLoad() {
							    return new Promise(function (resolve) {
							        return bind(window, 'load', resolve);
							    });
							};

							function documentReady() {
							    var pageLoadTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

							    return waitForDomContentLoaded().then(function () {
							        if (!listeners.getEventListeners(window, 'load').length) return null;

							        return Promise.race([waitForWindowLoad(), (0, _delay2.default)(pageLoadTimeout)]);
							    });
							}
						},
						"get-key-array.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = getKeyArray;

							var _array = require('./array');

							function getKeyArray(keyCombination) {
							    // NOTE: we should separate the '+' symbol that concats other
							    // keys and the '+'  key to support commands like the 'ctrl++'
							    var keys = keyCombination.replace(/^\+/g, 'plus').replace(/\+\+/g, '+plus').split('+');

							    return (0, _array.map)(keys, function (key) {
							        return key.replace('plus', '+');
							    });
							}
							module.exports = exports['default'];
						},
						"get-sanitized-key.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = getSanitizedKey;

							var _keyMaps = require('./key-maps');

							var _keyMaps2 = _interopRequireDefault(_keyMaps);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function getSanitizedKey(key) {
							    var isChar = key.length === 1 || key === 'space';
							    var sanitizedKey = isChar ? key : key.toLowerCase();

							    if (_keyMaps2.default.modifiersMap[sanitizedKey]) sanitizedKey = _keyMaps2.default.modifiersMap[sanitizedKey];

							    return sanitizedKey;
							}
							module.exports = exports['default'];
						},
						"key-maps.js": function (exports, module, require) {
							

							exports.__esModule = true;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var browserUtils = _hammerhead2.default.utils.browser;

							var MODIFIERS = {
							    alt: 18,
							    ctrl: 17,
							    meta: 91,
							    shift: 16
							};

							var SHIFT_MAP = {
							    '~': '`',
							    '!': '1',
							    '@': '2',
							    '#': '3',
							    '$': '4',
							    '%': '5',
							    '^': '6',
							    '&': '7',
							    '*': '8',
							    '(': '9',
							    ')': '0',
							    '_': '-',
							    '+': '=',
							    '{': '[',
							    '}': ']',
							    ':': ';',
							    '"': '\'',
							    '|': '\\',
							    '<': ',',
							    '>': '.',
							    '?': '/',
							    '': ''
							};

							var SPECIAL_KEYS = {
							    backspace: 8,
							    capslock: 20,
							    delete: 46,
							    down: 40,
							    end: 35,
							    enter: 13,
							    esc: 27,
							    home: 36,
							    ins: 45,
							    left: 37,
							    pagedown: 34,
							    pageup: 33,
							    right: 39,
							    space: 32,
							    tab: 9,
							    up: 38
							};

							function reverseMap(map) {
							    var reversed = {};

							    for (var key in map) {
							        if (map.hasOwnProperty(key)) reversed[map[key]] = key;
							    }

							    return reversed;
							}

							exports.default = {
							    modifiers: MODIFIERS,

							    shiftMap: SHIFT_MAP,

							    specialKeys: SPECIAL_KEYS,

							    reversedModifiers: reverseMap(MODIFIERS),

							    reversedShiftMap: reverseMap(SHIFT_MAP),

							    reversedSpecialKeys: reverseMap(SPECIAL_KEYS),

							    modifiersMap: {
							        option: 'alt'
							    },

							    keyProperty: {
							        left: browserUtils.isIE ? 'Left' : 'ArrowLeft',
							        down: browserUtils.isIE ? 'Down' : 'ArrowDown',
							        right: browserUtils.isIE ? 'Right' : 'ArrowRight',
							        up: browserUtils.isIE ? 'Up' : 'ArrowUp',
							        backspace: 'Backspace',
							        capslock: 'CapsLock',
							        delete: 'Delete',
							        end: 'End',
							        enter: 'Enter',
							        esc: 'Escape',
							        home: 'Home',
							        ins: 'Insert',
							        pagedown: 'PageDown',
							        pageup: 'PageUp',
							        space: ' ',
							        tab: 'Tab',
							        alt: 'Alt',
							        ctrl: 'Control',
							        meta: 'Meta',
							        shift: 'Shift'
							    },

							    symbolCharCodeToKeyCode: {
							        96: 192, // `
							        91: 219, // [
							        93: 221, // ]
							        92: 220, // \
							        59: 186, // ;
							        39: 222, // '
							        44: 188, // ,
							        45: browserUtils.isFirefox ? 173 : 189, // -
							        46: 190, // .
							        47: 191 // /
							    },

							    symbolKeysCharCodes: {
							        109: 45,
							        173: 45,
							        186: 59,
							        187: 61,
							        188: 44,
							        189: 45,
							        190: 46,
							        191: 47,
							        192: 96,
							        219: 91,
							        220: 92,
							        221: 93,
							        222: 39,

							        110: 46,
							        96: 48,
							        97: 49,
							        98: 50,
							        99: 51,
							        100: 52,
							        101: 53,
							        102: 54,
							        103: 55,
							        104: 56,
							        105: 57,
							        107: 43,
							        106: 42,
							        111: 47
							    }
							};
							module.exports = exports['default'];
						},
						"node-type-descriptions.js": function (exports, module, require) {
							

							exports.__esModule = true;
							// NOTE: node description by node type
							exports.default = {
							    1: 'element',
							    2: 'attribute',
							    3: 'text',
							    4: 'cdata section',
							    5: 'entity reference',
							    6: 'entity node',
							    7: 'processing instruction',
							    8: 'comment',
							    9: 'document',
							    10: 'document type',
							    11: 'document fragment',
							    12: 'notation'
							};
							module.exports = exports['default'];
						},
						"noop.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = noop;
							function noop() {}
							module.exports = exports["default"];
						},
						"parse-key-sequence.js": function (exports, module, require) {
							

							exports.__esModule = true;

							exports.default = function (keyString) {
							    if (typeof keyString !== 'string') return { error: true };

							    keyString = trim(keyString).replace(/\s+/g, ' ');

							    var keyStringLength = keyString.length;
							    var lastChar = keyString.charAt(keyStringLength - 1);
							    var charBeforeLast = keyString.charAt(keyStringLength - 2);

							    // NOTE: trim last connecting '+'
							    if (keyStringLength > 1 && lastChar === '+' && !/[+ ]/.test(charBeforeLast)) keyString = keyString.substring(0, keyString.length - 1);

							    var combinations = keyString.split(' ');

							    var error = (0, _array.some)(combinations, function (combination) {
							        var keyArray = (0, _getKeyArray2.default)(combination);

							        return (0, _array.some)(keyArray, function (key) {
							            var isChar = key.length === 1 || key === 'space';
							            var sanitizedKey = (0, _getSanitizedKey2.default)(key);
							            var modifierKeyCode = _keyMaps2.default.modifiers[sanitizedKey];
							            var specialKeyCode = _keyMaps2.default.specialKeys[sanitizedKey];

							            return !(isChar || modifierKeyCode || specialKeyCode);
							        });
							    });

							    return {
							        combinations: combinations,
							        error: error,
							        keys: keyString
							    };
							};

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _keyMaps = require('./key-maps');

							var _keyMaps2 = _interopRequireDefault(_keyMaps);

							var _array = require('./array');

							var _getKeyArray = require('./get-key-array');

							var _getKeyArray2 = _interopRequireDefault(_getKeyArray);

							var _getSanitizedKey = require('./get-sanitized-key');

							var _getSanitizedKey2 = _interopRequireDefault(_getSanitizedKey);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var trim = _hammerhead2.default.utils.trim;

							module.exports = exports['default'];
						},
						"position.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.offsetToClientCoords = exports.getOffsetPosition = exports.getElementRectangle = undefined;
							exports.getIframeClientCoordinates = getIframeClientCoordinates;
							exports.isElementVisible = isElementVisible;
							exports.getClientDimensions = getClientDimensions;
							exports.containsOffset = containsOffset;
							exports.getEventAbsoluteCoordinates = getEventAbsoluteCoordinates;
							exports.getEventPageCoordinates = getEventPageCoordinates;
							exports.getElementFromPoint = getElementFromPoint;
							exports.getIframePointRelativeToParentFrame = getIframePointRelativeToParentFrame;
							exports.clientToOffsetCoord = clientToOffsetCoord;
							exports.findCenter = findCenter;
							exports.getClientPosition = getClientPosition;
							exports.getElementClientRectangle = getElementClientRectangle;
							exports.calcRelativePosition = calcRelativePosition;
							exports.isInRectangle = isInRectangle;
							exports.getLineYByXCoord = getLineYByXCoord;
							exports.getLineXByYCoord = getLineXByYCoord;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _style = require('./style');

							var styleUtils = _interopRequireWildcard(_style);

							var _dom = require('./dom');

							var domUtils = _interopRequireWildcard(_dom);

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var getElementRectangle = exports.getElementRectangle = _hammerhead2.default.utils.position.getElementRectangle; /* global isIFrameWithoutSrc:true */
							var getOffsetPosition = exports.getOffsetPosition = _hammerhead2.default.utils.position.getOffsetPosition;
							var offsetToClientCoords = exports.offsetToClientCoords = _hammerhead2.default.utils.position.offsetToClientCoords;

							function getIframeClientCoordinates(iframe) {
							    var _getOffsetPosition = getOffsetPosition(iframe),
							        left = _getOffsetPosition.left,
							        top = _getOffsetPosition.top;

							    var clientPosition = offsetToClientCoords({ x: left, y: top });
							    var iframeBorders = styleUtils.getBordersWidth(iframe);
							    var iframePadding = styleUtils.getElementPadding(iframe);
							    var iframeRectangleLeft = clientPosition.x + iframeBorders.left + iframePadding.left;
							    var iframeRectangleTop = clientPosition.y + iframeBorders.top + iframePadding.top;

							    return {
							        left: iframeRectangleLeft,
							        top: iframeRectangleTop,
							        right: iframeRectangleLeft + styleUtils.getWidth(iframe),
							        bottom: iframeRectangleTop + styleUtils.getHeight(iframe)
							    };
							}

							function isElementVisible(el) {
							    if (domUtils.isTextNode(el)) return !styleUtils.isNotVisibleNode(el);

							    var elementRectangle = getElementRectangle(el);

							    if (!domUtils.isContentEditableElement(el)) {
							        if (elementRectangle.width === 0 || elementRectangle.height === 0) return false;
							    }

							    if (domUtils.isMapElement(el)) {
							        var mapContainer = domUtils.getMapContainer(domUtils.closest(el, 'map'));

							        return mapContainer ? isElementVisible(mapContainer) : false;
							    }

							    if (styleUtils.isSelectVisibleChild(el)) {
							        var select = domUtils.getSelectParent(el);
							        var childRealIndex = domUtils.getChildVisibleIndex(select, el);
							        var realSelectSizeValue = styleUtils.getSelectElementSize(select);
							        var topVisibleIndex = Math.max(styleUtils.getScrollTop(select) / styleUtils.getOptionHeight(select), 0);
							        var bottomVisibleIndex = topVisibleIndex + realSelectSizeValue - 1;
							        var optionVisibleIndex = Math.max(childRealIndex - topVisibleIndex, 0);

							        return optionVisibleIndex >= topVisibleIndex && optionVisibleIndex <= bottomVisibleIndex;
							    }

							    if (domUtils.isSVGElement(el)) return styleUtils.get(el, 'visibility') !== 'hidden' && styleUtils.get(el, 'display') !== 'none';

							    return styleUtils.hasDimensions(el) && styleUtils.get(el, 'visibility') !== 'hidden';
							}

							function getClientDimensions(target) {
							    if (!domUtils.isDomElement(target)) {
							        var clientPoint = offsetToClientCoords(target);

							        return {
							            width: 0,
							            height: 0,

							            border: {
							                bottom: 0,
							                left: 0,
							                right: 0,
							                top: 0
							            },
							            scroll: {
							                left: 0,
							                top: 0
							            },

							            left: clientPoint.x,
							            right: clientPoint.x,
							            top: clientPoint.y,
							            bottom: clientPoint.y
							        };
							    }

							    var isHtmlElement = /html/i.test(target.tagName);
							    var body = isHtmlElement ? target.getElementsByTagName('body')[0] : null;
							    var elementBorders = styleUtils.getBordersWidth(target);
							    var elementRect = target.getBoundingClientRect();
							    var elementScroll = styleUtils.getElementScroll(target);
							    var isElementInIframe = domUtils.isElementInIframe(target);
							    var elementLeftPosition = isHtmlElement ? 0 : elementRect.left;
							    var elementTopPosition = isHtmlElement ? 0 : elementRect.top;
							    var elementHeight = isHtmlElement ? target.clientHeight : elementRect.height;
							    var elementWidth = isHtmlElement ? target.clientWidth : elementRect.width;
							    var isCompatMode = target.ownerDocument.compatMode === 'BackCompat';

							    if (isHtmlElement && body && (typeof isIFrameWithoutSrc === 'boolean' && isIFrameWithoutSrc || isCompatMode)) {
							        elementHeight = body.clientHeight;
							        elementWidth = body.clientWidth;
							    }

							    if (isElementInIframe) {
							        var iframeElement = domUtils.getIframeByElement(target);

							        if (iframeElement) {
							            var iframeOffset = getOffsetPosition(iframeElement);
							            var clientOffset = offsetToClientCoords({
							                x: iframeOffset.left,
							                y: iframeOffset.top
							            });
							            var iframeBorders = styleUtils.getBordersWidth(iframeElement);

							            elementLeftPosition += clientOffset.x + iframeBorders.left;
							            elementTopPosition += clientOffset.y + iframeBorders.top;

							            if (isHtmlElement) {
							                elementBorders.bottom += iframeBorders.bottom;
							                elementBorders.left += iframeBorders.left;
							                elementBorders.right += iframeBorders.right;
							                elementBorders.top += iframeBorders.top;
							            }
							        }
							    }

							    var hasRightScrollbar = !isHtmlElement && styleUtils.getInnerWidth(target) !== target.clientWidth;
							    var rightScrollbarWidth = hasRightScrollbar ? domUtils.getScrollbarSize() : 0;

							    var hasBottomScrollbar = !isHtmlElement && styleUtils.getInnerHeight(target) !== target.clientHeight;
							    var bottomScrollbarHeight = hasBottomScrollbar ? domUtils.getScrollbarSize() : 0;

							    return {
							        width: elementWidth,
							        height: elementHeight,
							        left: elementLeftPosition,
							        top: elementTopPosition,
							        border: elementBorders,
							        bottom: elementTopPosition + elementHeight,
							        right: elementLeftPosition + elementWidth,

							        scroll: {
							            left: elementScroll.left,
							            top: elementScroll.top
							        },

							        scrollbar: {
							            right: rightScrollbarWidth,
							            bottom: bottomScrollbarHeight
							        }
							    };
							}

							function containsOffset(el, offsetX, offsetY) {
							    var dimensions = getClientDimensions(el);
							    var width = Math.max(el.scrollWidth, dimensions.width);
							    var height = Math.max(el.scrollHeight, dimensions.height);
							    var maxX = dimensions.scrollbar.right + dimensions.border.left + dimensions.border.right + width;
							    var maxY = dimensions.scrollbar.bottom + dimensions.border.top + dimensions.border.bottom + height;

							    return (typeof offsetX === 'undefined' || offsetX >= 0 && maxX >= offsetX) && (typeof offsetY === 'undefined' || offsetY >= 0 && maxY >= offsetY);
							}

							function getEventAbsoluteCoordinates(ev) {
							    var el = ev.target || ev.srcElement;
							    var pageCoordinates = getEventPageCoordinates(ev);
							    var curDocument = domUtils.findDocument(el);
							    var xOffset = 0;
							    var yOffset = 0;

							    if (domUtils.isElementInIframe(curDocument.documentElement)) {
							        var currentIframe = domUtils.getIframeByElement(curDocument);

							        if (currentIframe) {
							            var iframeOffset = getOffsetPosition(currentIframe);
							            var iframeBorders = styleUtils.getBordersWidth(currentIframe);

							            xOffset = iframeOffset.left + iframeBorders.left;
							            yOffset = iframeOffset.top + iframeBorders.top;
							        }
							    }

							    return {
							        x: pageCoordinates.x + xOffset,
							        y: pageCoordinates.y + yOffset
							    };
							}

							function getEventPageCoordinates(ev) {
							    var curCoordObject = /^touch/.test(ev.type) && ev.targetTouches ? ev.targetTouches[0] || ev.changedTouches[0] : ev;

							    var bothPageCoordinatesAreZero = curCoordObject.pageX === 0 && curCoordObject.pageY === 0;
							    var notBothClientCoordinatesAreZero = curCoordObject.clientX !== 0 || curCoordObject.clientY !== 0;

							    if ((curCoordObject.pageX === null || bothPageCoordinatesAreZero && notBothClientCoordinatesAreZero) && curCoordObject.clientX !== null) {
							        var currentDocument = domUtils.findDocument(ev.target || ev.srcElement);
							        var html = currentDocument.documentElement;
							        var body = currentDocument.body;

							        return {
							            x: Math.round(curCoordObject.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0)),
							            y: Math.round(curCoordObject.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0))
							        };
							    }
							    return {
							        x: Math.round(curCoordObject.pageX),
							        y: Math.round(curCoordObject.pageY)
							    };
							}

							function getElementFromPoint(x, y) {
							    var el = null;
							    var func = document.getElementFromPoint || document.elementFromPoint;

							    try {
							        // Permission denied to access property 'getElementFromPoint' error in iframe
							        el = func.call(document, x, y);
							    } catch (ex) {
							        return null;
							    }

							    //NOTE: elementFromPoint returns null when is's a border of an iframe
							    if (el === null) el = func.call(document, x - 1, y - 1);

							    while (el && el.shadowRoot && el.shadowRoot.elementFromPoint) {
							        var shadowEl = el.shadowRoot.elementFromPoint(x, y);

							        if (!shadowEl) break;

							        el = shadowEl;
							    }

							    return el;
							}

							function getIframePointRelativeToParentFrame(pos, iframeWin) {
							    var iframe = domUtils.findIframeByWindow(iframeWin);
							    var iframeOffset = getOffsetPosition(iframe);
							    var iframeBorders = styleUtils.getBordersWidth(iframe);
							    var iframePadding = styleUtils.getElementPadding(iframe);

							    return offsetToClientCoords({
							        x: pos.x + iframeOffset.left + iframeBorders.left + iframePadding.left,
							        y: pos.y + iframeOffset.top + iframeBorders.top + iframePadding.top
							    });
							}

							function clientToOffsetCoord(coords, currentDocument) {
							    var doc = currentDocument || document;

							    return {
							        x: coords.x + styleUtils.getScrollLeft(doc),
							        y: coords.y + styleUtils.getScrollTop(doc)
							    };
							}

							function findCenter(el) {
							    var rectangle = getElementRectangle(el);

							    return {
							        x: Math.round(rectangle.left + rectangle.width / 2),
							        y: Math.round(rectangle.top + rectangle.height / 2)
							    };
							}

							function getClientPosition(el) {
							    var _getOffsetPosition2 = getOffsetPosition(el),
							        left = _getOffsetPosition2.left,
							        top = _getOffsetPosition2.top;

							    var clientCoords = offsetToClientCoords({ x: left, y: top });

							    clientCoords.x = Math.round(clientCoords.x);
							    clientCoords.y = Math.round(clientCoords.y);

							    return clientCoords;
							}

							function getElementClientRectangle(el) {
							    var rect = getElementRectangle(el);
							    var clientPos = offsetToClientCoords({
							        x: rect.left,
							        y: rect.top
							    });

							    return {
							        height: rect.height,
							        left: clientPos.x,
							        top: clientPos.y,
							        width: rect.width
							    };
							}

							function calcRelativePosition(dimensions, toDimensions) {
							    return {
							        left: Math.ceil(dimensions.left - (toDimensions.left + toDimensions.border.left)),

							        right: Math.floor(toDimensions.right - toDimensions.border.right - toDimensions.scrollbar.right - dimensions.right),

							        top: Math.ceil(dimensions.top - (toDimensions.top + toDimensions.border.top)),

							        bottom: Math.floor(toDimensions.bottom - toDimensions.border.bottom - toDimensions.scrollbar.bottom - dimensions.bottom)
							    };
							}

							function isInRectangle(_ref, rectangle) {
							    var x = _ref.x,
							        y = _ref.y;

							    return x >= rectangle.left && x <= rectangle.right && y >= rectangle.top && y <= rectangle.bottom;
							}

							function getLineYByXCoord(startLinePoint, endLinePoint, x) {
							    if (endLinePoint.x - startLinePoint.x === 0) return null;

							    var equationSlope = (endLinePoint.y - startLinePoint.y) / (endLinePoint.x - startLinePoint.x);

							    var equationYIntercept = startLinePoint.x * (startLinePoint.y - endLinePoint.y) / (endLinePoint.x - startLinePoint.x) + startLinePoint.y;

							    return Math.round(equationSlope * x + equationYIntercept);
							}

							function getLineXByYCoord(startLinePoint, endLinePoint, y) {
							    if (endLinePoint.y - startLinePoint.y === 0) return null;

							    var equationSlope = (endLinePoint.x - startLinePoint.x) / (endLinePoint.y - startLinePoint.y);

							    var equationXIntercept = startLinePoint.y * (startLinePoint.x - endLinePoint.x) / (endLinePoint.y - startLinePoint.y) + startLinePoint.x;

							    return Math.round(equationSlope * y + equationXIntercept);
							}
						},
						"promise.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.whilst = whilst;
							exports.times = times;
							exports.each = each;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _array = require('./array');

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var Promise = _hammerhead2.default.Promise;

							function whilst(condition, iterator) {
							    return new Promise(function (resolve, reject) {
							        function iterate() {
							            if (condition()) return iterator().then(iterate).catch(function (err) {
							                return reject(err);
							            });

							            return resolve();
							        }

							        return iterate();
							    });
							}

							function times(n, iterator) {
							    var promise = Promise.resolve();

							    var _loop = function _loop(i) {
							        promise = promise.then(function () {
							            return iterator(i);
							        });
							    };

							    for (var i = 0; i < n; i++) {
							        _loop(i);
							    }return promise;
							}

							function each(items, iterator) {
							    return (0, _array.reduce)(items, function (promise, item) {
							        return promise.then(function () {
							            return iterator(item);
							        });
							    }, Promise.resolve());
							}
						},
						"send-request-to-frame.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = sendRequestToFrame;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var Promise = _hammerhead2.default.Promise;
							var messageSandbox = _hammerhead2.default.eventSandbox.message;

							function sendRequestToFrame(msg, responseCmd, receiverWindow) {
							    return new Promise(function (resolve) {
							        function onMessage(e) {
							            if (e.message.cmd === responseCmd) {
							                messageSandbox.off(messageSandbox.SERVICE_MSG_RECEIVED_EVENT, onMessage);
							                resolve(e.message);
							            }
							        }

							        messageSandbox.on(messageSandbox.SERVICE_MSG_RECEIVED_EVENT, onMessage);
							        messageSandbox.sendServiceMsg(msg, receiverWindow);
							    });
							}
							module.exports = exports['default'];
						},
						"service.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.EventEmitter = undefined;
							exports.inherit = inherit;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _array = require('./array');

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function inherit(Child, Parent) {
							    var Func = function Func() {};

							    Func.prototype = Parent.prototype;

							    _hammerhead2.default.utils.extend(Child.prototype, new Func());
							    Child.prototype.constructor = Child;
							    Child.base = Parent.prototype;
							}

							var EventEmitter = exports.EventEmitter = function EventEmitter() {
							    this.eventsListeners = [];
							};

							EventEmitter.prototype.emit = function (evt) {
							    var listeners = this.eventsListeners[evt];

							    if (listeners) {
							        for (var i = 0; i < listeners.length; i++) {
							            try {
							                if (listeners[i]) listeners[i].apply(this, Array.prototype.slice.apply(arguments, [1]));
							            } catch (e) {
							                // Hack for IE: after document.write calling IFrameSandbox event handlers
							                // rises 'Can't execute code from a freed script' exception because document has been
							                // recreated
							                if (e.message && e.message.indexOf('freed script') > -1) listeners[i] = null;else throw e;
							            }
							        }
							    }
							};

							EventEmitter.prototype.off = function (evt, listener) {
							    var listeners = this.eventsListeners[evt];

							    if (listeners) this.eventsListeners[evt] = (0, _array.filter)(listeners, function (item) {
							        return item !== listener;
							    });
							};

							EventEmitter.prototype.on = function (evt, listener) {
							    if (!this.eventsListeners[evt]) this.eventsListeners[evt] = [];

							    this.eventsListeners[evt].push(listener);
							};

							EventEmitter.prototype.once = function (evt, listener) {
							    var _this = this;

							    this.on(evt, function () {
							        _this.off(evt, listener);

							        return listener.apply(undefined, arguments);
							    });
							};
						},
						"style.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.get = exports.setScrollTop = exports.setScrollLeft = exports.getScrollTop = exports.getScrollLeft = exports.getInnerHeight = exports.getInnerWidth = exports.getHeight = exports.getWidth = exports.isSelectVisibleChild = exports.isElementVisible = exports.getSelectElementSize = exports.getOptionHeight = exports.getElementScroll = exports.getElementPadding = exports.getElementMargin = exports.getComputedStyle = exports.getBordersWidth = undefined;
							exports.isFixedElement = isFixedElement;
							exports.isNotVisibleNode = isNotVisibleNode;
							exports.getScrollableParents = getScrollableParents;
							exports.hasScroll = hasScroll;
							exports.hasDimensions = hasDimensions;
							exports.set = set;
							exports.getViewportDimensions = getViewportDimensions;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _dom = require('./dom');

							var domUtils = _interopRequireWildcard(_dom);

							var _array = require('./array');

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var styleUtils = _hammerhead2.default.utils.style;

							var getBordersWidth = exports.getBordersWidth = _hammerhead2.default.utils.style.getBordersWidth;
							var getComputedStyle = exports.getComputedStyle = _hammerhead2.default.utils.style.getComputedStyle;
							var getElementMargin = exports.getElementMargin = _hammerhead2.default.utils.style.getElementMargin;
							var getElementPadding = exports.getElementPadding = _hammerhead2.default.utils.style.getElementPadding;
							var getElementScroll = exports.getElementScroll = _hammerhead2.default.utils.style.getElementScroll;
							var getOptionHeight = exports.getOptionHeight = _hammerhead2.default.utils.style.getOptionHeight;
							var getSelectElementSize = exports.getSelectElementSize = _hammerhead2.default.utils.style.getSelectElementSize;
							var isElementVisible = exports.isElementVisible = _hammerhead2.default.utils.style.isElementVisible;
							var isSelectVisibleChild = exports.isSelectVisibleChild = _hammerhead2.default.utils.style.isVisibleChild;
							var getWidth = exports.getWidth = _hammerhead2.default.utils.style.getWidth;
							var getHeight = exports.getHeight = _hammerhead2.default.utils.style.getHeight;
							var getInnerWidth = exports.getInnerWidth = _hammerhead2.default.utils.style.getInnerWidth;
							var getInnerHeight = exports.getInnerHeight = _hammerhead2.default.utils.style.getInnerHeight;
							var getScrollLeft = exports.getScrollLeft = _hammerhead2.default.utils.style.getScrollLeft;
							var getScrollTop = exports.getScrollTop = _hammerhead2.default.utils.style.getScrollTop;
							var setScrollLeft = exports.setScrollLeft = _hammerhead2.default.utils.style.setScrollLeft;
							var setScrollTop = exports.setScrollTop = _hammerhead2.default.utils.style.setScrollTop;
							var get = exports.get = _hammerhead2.default.utils.style.get;

							var SCROLLABLE_OVERFLOW_STYLE_RE = /auto|scroll/i;

							var getAncestors = function getAncestors(node) {
							    var ancestors = [];

							    while (node.parentNode) {
							        ancestors.unshift(node.parentNode);
							        node = node.parentNode;
							    }

							    return ancestors;
							};

							var getAncestorsAndSelf = function getAncestorsAndSelf(node) {
							    return getAncestors(node).concat([node]);
							};

							var isVisibilityHiddenNode = function isVisibilityHiddenNode(node) {
							    var ancestors = getAncestorsAndSelf(node);

							    return (0, _array.some)(ancestors, function (ancestor) {
							        return domUtils.isElementNode(ancestor) && get(ancestor, 'visibility') === 'hidden';
							    });
							};

							var isHiddenNode = function isHiddenNode(node) {
							    var ancestors = getAncestorsAndSelf(node);

							    return (0, _array.some)(ancestors, function (ancestor) {
							        return domUtils.isElementNode(ancestor) && get(ancestor, 'display') === 'none';
							    });
							};

							function isFixedElement(node) {
							    return domUtils.isElementNode(node) && get(node, 'position') === 'fixed';
							}

							function isNotVisibleNode(node) {
							    return !domUtils.isRenderedNode(node) || isHiddenNode(node) || isVisibilityHiddenNode(node);
							}

							function getScrollableParents(element) {
							    var parentsArray = domUtils.getParents(element);

							    if (domUtils.isElementInIframe(element)) {
							        var iFrameParents = domUtils.getParents(domUtils.getIframeByElement(element));

							        parentsArray.concat(iFrameParents);
							    }

							    return (0, _array.filter)(parentsArray, hasScroll);
							}

							function hasBodyScroll(el) {
							    var overflowX = get(el, 'overflowX');
							    var overflowY = get(el, 'overflowY');
							    var scrollableHorizontally = SCROLLABLE_OVERFLOW_STYLE_RE.test(overflowX);
							    var scrollableVertically = SCROLLABLE_OVERFLOW_STYLE_RE.test(overflowY);

							    var documentElement = domUtils.findDocument(el).documentElement;

							    return (scrollableHorizontally || scrollableVertically) && el.scrollHeight > documentElement.scrollHeight;
							}

							function hasHTMLElementScroll(el) {
							    var overflowX = get(el, 'overflowX');
							    var overflowY = get(el, 'overflowY');
							    //T174562 - wrong scrolling in iframes without src and others iframes
							    var body = el.getElementsByTagName('body')[0];

							    //T303226
							    if (overflowX === 'hidden' && overflowY === 'hidden') return false;

							    var hasHorizontalScroll = el.scrollHeight > el.clientHeight;
							    var hasVerticalScroll = el.scrollWidth > el.clientWidth;

							    if (hasHorizontalScroll || hasVerticalScroll) return true;

							    if (body) {
							        if (hasBodyScroll(body)) return false;

							        var clientWidth = Math.min(el.clientWidth, body.clientWidth);
							        var clientHeight = Math.min(el.clientHeight, body.clientHeight);

							        return body.scrollHeight > clientHeight || body.scrollWidth > clientWidth;
							    }

							    return false;
							}

							function hasScroll(el) {
							    var overflowX = get(el, 'overflowX');
							    var overflowY = get(el, 'overflowY');
							    var scrollableHorizontally = SCROLLABLE_OVERFLOW_STYLE_RE.test(overflowX);
							    var scrollableVertically = SCROLLABLE_OVERFLOW_STYLE_RE.test(overflowY);

							    if (domUtils.isBodyElement(el)) return hasBodyScroll(el);

							    if (domUtils.isHtmlElement(el)) return hasHTMLElementScroll(el);

							    if (!scrollableHorizontally && !scrollableVertically) return false;

							    var hasHorizontalScroll = scrollableVertically && el.scrollHeight > el.clientHeight;
							    var hasVerticalScroll = scrollableHorizontally && el.scrollWidth > el.clientWidth;

							    return hasHorizontalScroll || hasVerticalScroll;
							}

							function hasDimensions(el) {
							    //NOTE: it's like jquery ':visible' selector (http://blog.jquery.com/2009/02/20/jquery-1-3-2-released/)
							    return el && !(el.offsetHeight <= 0 && el.offsetWidth <= 0);
							}

							function set(el, style, value) {
							    if (typeof style === 'string') styleUtils.set(el, style, value);

							    for (var property in style) {
							        if (style.hasOwnProperty(property)) styleUtils.set(el, property, style[property]);
							    }
							}

							function getViewportDimension(windowDimension, documentDimension, bodyDimension) {
							    if (documentDimension > windowDimension) return bodyDimension;

							    if (bodyDimension > windowDimension) return documentDimension;

							    return Math.max(bodyDimension, documentDimension);
							}

							function getViewportDimensions() {
							    return {
							        width: getViewportDimension(window.innerWidth, document.documentElement.clientWidth, document.body.clientWidth),
							        height: getViewportDimension(window.innerHeight, document.documentElement.clientHeight, document.body.clientHeight)
							    };
							}
						},
						"text-selection.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.hasInverseSelectionContentEditable = hasInverseSelectionContentEditable;
							exports.isInverseSelectionContentEditable = isInverseSelectionContentEditable;
							exports.getSelectionStart = getSelectionStart;
							exports.getSelectionEnd = getSelectionEnd;
							exports.hasInverseSelection = hasInverseSelection;
							exports.getSelectionByElement = getSelectionByElement;
							exports.select = select;
							exports.selectByNodesAndOffsets = selectByNodesAndOffsets;
							exports.deleteSelectionContents = deleteSelectionContents;
							exports.setCursorToLastVisiblePosition = setCursorToLastVisiblePosition;
							exports.hasElementContainsSelection = hasElementContainsSelection;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _dom = require('./dom');

							var domUtils = _interopRequireWildcard(_dom);

							var _contentEditable = require('./content-editable');

							var contentEditable = _interopRequireWildcard(_contentEditable);

							var _event = require('./event');

							var eventUtils = _interopRequireWildcard(_event);

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var browserUtils = _hammerhead2.default.utils.browser;
							var nativeMethods = _hammerhead2.default.nativeMethods;
							var selectionSandbox = _hammerhead2.default.eventSandbox.selection;

							//NOTE: we can't determine selection direction in ie from dom api. Therefore we should listen selection changes,
							// and calculate direction using it.
							var BACKWARD_SELECTION_DIRECTION = 'backward';
							var FORWARD_SELECTION_DIRECTION = 'forward';
							var NONE_SELECTION_DIRECTION = 'none';

							var selectionDirection = NONE_SELECTION_DIRECTION;
							var initialLeft = 0;
							var initialTop = 0;
							var lastSelectionHeight = 0;
							var lastSelectionLeft = 0;
							var lastSelectionLength = 0;
							var lastSelectionTop = 0;

							function stateChanged(left, top, height, width, selectionLength) {
							    if (!selectionLength) {
							        initialLeft = left;
							        initialTop = top;
							        selectionDirection = NONE_SELECTION_DIRECTION;
							    } else {
							        switch (selectionDirection) {
							            case NONE_SELECTION_DIRECTION:
							                if (top === lastSelectionTop && (left === lastSelectionLeft || height > lastSelectionHeight)) selectionDirection = FORWARD_SELECTION_DIRECTION;else if (left < lastSelectionLeft || top < lastSelectionTop) selectionDirection = BACKWARD_SELECTION_DIRECTION;

							                break;

							            case FORWARD_SELECTION_DIRECTION:
							                if (left === lastSelectionLeft && top === lastSelectionTop || left < lastSelectionLeft && height > lastSelectionHeight || top === lastSelectionTop && height === lastSelectionHeight && selectionLength > lastSelectionLength && left + width !== initialLeft) break;else if (left < lastSelectionLeft || top < lastSelectionTop) selectionDirection = BACKWARD_SELECTION_DIRECTION;

							                break;

							            case BACKWARD_SELECTION_DIRECTION:
							                if ((left < lastSelectionLeft || top < lastSelectionTop) && selectionLength > lastSelectionLength) break;else if (top === initialTop && (left >= initialLeft || height > lastSelectionHeight)) selectionDirection = FORWARD_SELECTION_DIRECTION;

							                break;
							        }
							    }

							    lastSelectionHeight = height;
							    lastSelectionLeft = left;
							    lastSelectionLength = selectionLength;
							    lastSelectionTop = top;
							}

							function onSelectionChange() {
							    var activeElement = null;
							    var endSelection = null;
							    var range = null;
							    var rect = null;
							    var startSelection = null;

							    try {
							        if (this.selection) range = this.selection.createRange();else {
							            //HACK: we need do this for IE11 because otherwise we can not get TextRange properties
							            activeElement = nativeMethods.documentActiveElementGetter.call(this);

							            if (!activeElement || !domUtils.isTextEditableElement(activeElement)) {
							                selectionDirection = NONE_SELECTION_DIRECTION;

							                return;
							            }

							            startSelection = getSelectionStart(activeElement);
							            endSelection = getSelectionEnd(activeElement);

							            if (activeElement.createTextRange) {
							                range = activeElement.createTextRange();
							                range.collapse(true);
							                range.moveStart('character', startSelection);
							                range.moveEnd('character', endSelection - startSelection);
							            } else if (document.createRange) {
							                //NOTE: for MSEdge
							                range = document.createRange();

							                var textNode = _hammerhead2.default.nativeMethods.nodeFirstChildGetter.call(activeElement);

							                range.setStart(textNode, startSelection);
							                range.setEnd(textNode, endSelection);
							                rect = range.getBoundingClientRect();
							            }
							        }
							    } catch (e) {
							        //NOTE: in ie it raises error when there are not a real selection
							        selectionDirection = NONE_SELECTION_DIRECTION;

							        return;
							    }

							    var rangeLeft = rect ? Math.ceil(rect.left) : range.offsetLeft;
							    var rangeTop = rect ? Math.ceil(rect.top) : range.offsetTop;
							    var rangeHeight = rect ? Math.ceil(rect.height) : range.boundingHeight;
							    var rangeWidth = rect ? Math.ceil(rect.width) : range.boundingWidth;
							    var rangeHTMLTextLength = range.htmlText ? range.htmlText.length : 0;
							    var rangeTextLength = rect ? range.toString().length : rangeHTMLTextLength;

							    stateChanged(rangeLeft, rangeTop, rangeHeight, rangeWidth, rangeTextLength);
							}

							if (browserUtils.isIE) eventUtils.bind(document, 'selectionchange', onSelectionChange, true);

							//utils for contentEditable
							function selectContentEditable(el, from, to, needFocus) {
							    var endPosition = null;
							    var firstTextNodeChild = null;
							    var latestTextNodeChild = null;
							    var startPosition = null;
							    var temp = null;
							    var inverse = false;

							    if (typeof from !== 'undefined' && typeof to !== 'undefined' && from > to) {
							        temp = from;
							        from = to;
							        to = temp;
							        inverse = true;
							    }

							    if (typeof from === 'undefined') {
							        firstTextNodeChild = contentEditable.getFirstVisibleTextNode(el);

							        startPosition = {
							            node: firstTextNodeChild || el,
							            offset: firstTextNodeChild && firstTextNodeChild.nodeValue ? contentEditable.getFirstNonWhitespaceSymbolIndex(firstTextNodeChild.nodeValue) : 0
							        };
							    }

							    if (typeof to === 'undefined') {
							        latestTextNodeChild = contentEditable.getLastTextNode(el, true);
							        endPosition = {
							            node: latestTextNodeChild || el,
							            offset: latestTextNodeChild && latestTextNodeChild.nodeValue ? contentEditable.getLastNonWhitespaceSymbolIndex(latestTextNodeChild.nodeValue) : 0
							        };
							    }

							    startPosition = startPosition || contentEditable.calculateNodeAndOffsetByPosition(el, from);
							    endPosition = endPosition || contentEditable.calculateNodeAndOffsetByPosition(el, to);

							    if (!startPosition.node || !endPosition.node) return;

							    if (inverse) selectByNodesAndOffsets(endPosition, startPosition, needFocus);else selectByNodesAndOffsets(startPosition, endPosition, needFocus);
							}

							function correctContentEditableSelectionBeforeDelete(el) {
							    var selection = getSelectionByElement(el);

							    var startNode = selection.anchorNode;
							    var endNode = selection.focusNode;

							    var startOffset = selection.anchorOffset;
							    var endOffset = selection.focusOffset;

							    var startNodeFirstNonWhitespaceSymbol = contentEditable.getFirstNonWhitespaceSymbolIndex(startNode.nodeValue);
							    var startNodeLastNonWhitespaceSymbol = contentEditable.getLastNonWhitespaceSymbolIndex(startNode.nodeValue);

							    var endNodeFirstNonWhitespaceSymbol = contentEditable.getFirstNonWhitespaceSymbolIndex(endNode.nodeValue);
							    var endNodeLastNonWhitespaceSymbol = contentEditable.getLastNonWhitespaceSymbolIndex(endNode.nodeValue);

							    var newStartOffset = null;
							    var newEndOffset = null;

							    if (domUtils.isTextNode(startNode)) {
							        if (startOffset < startNodeFirstNonWhitespaceSymbol && startOffset !== 0) newStartOffset = 0;else if (startOffset !== startNode.nodeValue.length && (contentEditable.isInvisibleTextNode(startNode) && startOffset !== 0 || startOffset > startNodeLastNonWhitespaceSymbol)) newStartOffset = startNode.nodeValue.length;
							    }

							    if (domUtils.isTextNode(endNode)) {
							        if (endOffset < endNodeFirstNonWhitespaceSymbol && endOffset !== 0) newEndOffset = 0;else if (endOffset !== endNode.nodeValue.length && (contentEditable.isInvisibleTextNode(endNode) && endOffset !== 0 || endOffset > endNodeLastNonWhitespaceSymbol)) newEndOffset = endNode.nodeValue.length;
							    }

							    if (browserUtils.isWebKit || browserUtils.isIE && browserUtils.version > 11) {
							        if (newStartOffset !== null) {
							            if (newStartOffset === 0) startNode.nodeValue = startNode.nodeValue.substring(startNodeFirstNonWhitespaceSymbol);else startNode.nodeValue = startNode.nodeValue.substring(0, startNodeLastNonWhitespaceSymbol);
							        }

							        if (newEndOffset !== null) {
							            if (newEndOffset === 0) endNode.nodeValue = endNode.nodeValue.substring(endNodeFirstNonWhitespaceSymbol);else endNode.nodeValue = endNode.nodeValue.substring(0, endNodeLastNonWhitespaceSymbol);
							        }
							    }

							    if (newStartOffset !== null || newEndOffset !== null) {
							        if (newStartOffset !== null) newStartOffset = newStartOffset === 0 ? newStartOffset : startNode.nodeValue.length;else newStartOffset = startOffset;

							        if (newEndOffset !== null) newEndOffset = newEndOffset === 0 ? newEndOffset : endNode.nodeValue.length;else newEndOffset = endOffset;

							        var startPos = { node: startNode, offset: newStartOffset };
							        var endPos = { node: endNode, offset: newEndOffset };

							        selectByNodesAndOffsets(startPos, endPos);
							    }
							}

							//API
							function hasInverseSelectionContentEditable(el) {
							    var curDocument = el ? domUtils.findDocument(el) : document;
							    var selection = curDocument.getSelection();
							    var range = null;
							    var backward = false;

							    if (selection) {
							        if (!selection.isCollapsed) {
							            range = curDocument.createRange();
							            range.setStart(selection.anchorNode, selection.anchorOffset);
							            range.setEnd(selection.focusNode, selection.focusOffset);
							            backward = range.collapsed;
							            range.detach();
							        }
							    }

							    return backward;
							}

							function isInverseSelectionContentEditable(element, startPos, endPos) {
							    var startPosition = contentEditable.calculatePositionByNodeAndOffset(element, startPos);
							    var endPosition = contentEditable.calculatePositionByNodeAndOffset(element, endPos);

							    return startPosition > endPosition;
							}

							function getSelectionStart(el) {
							    var selection = null;

							    if (!domUtils.isContentEditableElement(el)) return selectionSandbox.getSelection(el).start;

							    if (hasElementContainsSelection(el)) {
							        selection = getSelectionByElement(el);

							        return contentEditable.getSelectionStartPosition(el, selection, hasInverseSelectionContentEditable(el));
							    }

							    return 0;
							}

							function getSelectionEnd(el) {
							    var selection = null;

							    if (!domUtils.isContentEditableElement(el)) return selectionSandbox.getSelection(el).end;

							    if (hasElementContainsSelection(el)) {
							        selection = getSelectionByElement(el);

							        return contentEditable.getSelectionEndPosition(el, selection, hasInverseSelectionContentEditable(el));
							    }

							    return 0;
							}

							function hasInverseSelection(el) {
							    if (domUtils.isContentEditableElement(el)) return hasInverseSelectionContentEditable(el);

							    return (selectionSandbox.getSelection(el).direction || selectionDirection) === BACKWARD_SELECTION_DIRECTION;
							}

							function getSelectionByElement(el) {
							    var currentDocument = domUtils.findDocument(el);

							    return currentDocument ? currentDocument.getSelection() : window.getSelection();
							}

							function select(el, from, to) {
							    if (domUtils.isContentEditableElement(el)) {
							        selectContentEditable(el, from, to, true);

							        return;
							    }

							    var start = from || 0;
							    var end = typeof to === 'undefined' ? domUtils.getElementValue(el).length : to;
							    var inverse = false;
							    var temp = null;

							    if (start > end) {
							        temp = start;
							        start = end;
							        end = temp;
							        inverse = true;
							    }

							    selectionSandbox.setSelection(el, start, end, inverse ? BACKWARD_SELECTION_DIRECTION : FORWARD_SELECTION_DIRECTION);

							    if (from === to) selectionDirection = NONE_SELECTION_DIRECTION;else selectionDirection = inverse ? BACKWARD_SELECTION_DIRECTION : FORWARD_SELECTION_DIRECTION;
							}

							function selectByNodesAndOffsets(startPos, endPos, needFocus) {
							    var startNode = startPos.node;
							    var endNode = endPos.node;

							    var startNodeLength = startNode.nodeValue ? startNode.length : 0;
							    var endNodeLength = endNode.nodeValue ? endNode.length : 0;
							    var startOffset = startPos.offset;
							    var endOffset = endPos.offset;

							    if (!domUtils.isElementNode(startNode) || !startOffset) startOffset = Math.min(startNodeLength, startPos.offset);

							    if (!domUtils.isElementNode(endNode) || !endOffset) endOffset = Math.min(endNodeLength, endPos.offset);

							    var parentElement = contentEditable.findContentEditableParent(startNode);
							    var inverse = isInverseSelectionContentEditable(parentElement, startPos, endPos);

							    var selection = getSelectionByElement(parentElement);
							    var curDocument = domUtils.findDocument(parentElement);
							    var range = curDocument.createRange();

							    var selectionSetter = function selectionSetter() {
							        selection.removeAllRanges();

							        //NOTE: For IE we can't create inverse selection
							        if (!inverse) {
							            range.setStart(startNode, startOffset);
							            range.setEnd(endNode, endOffset);
							            selection.addRange(range);
							        } else if (browserUtils.isIE) {
							            range.setStart(endNode, endOffset);
							            range.setEnd(startNode, startOffset);
							            selection.addRange(range);
							        } else {
							            range.setStart(startNode, startOffset);
							            range.setEnd(startNode, startOffset);
							            selection.addRange(range);

							            var shouldCutEndOffset = browserUtils.isSafari || browserUtils.isChrome && browserUtils.version < 58;

							            var extendSelection = function extendSelection(node, offset) {
							                // NODE: in some cases in Firefox extend method raises error so we use try-catch
							                try {
							                    selection.extend(node, offset);
							                } catch (err) {
							                    return false;
							                }

							                return true;
							            };

							            if (shouldCutEndOffset && contentEditable.isInvisibleTextNode(endNode)) {
							                if (!extendSelection(endNode, Math.min(endOffset, 1))) extendSelection(endNode, 0);
							            } else extendSelection(endNode, endOffset);
							        }
							    };

							    selectionSandbox.wrapSetterSelection(parentElement, selectionSetter, needFocus, true);
							}

							function deleteSelectionRanges(el) {
							    var selection = getSelectionByElement(el);
							    var rangeCount = selection.rangeCount;

							    if (!rangeCount) return;

							    for (var i = 0; i < rangeCount; i++) {
							        selection.getRangeAt(i).deleteContents();
							    }
							}

							function deleteSelectionContents(el, selectAll) {
							    var startSelection = getSelectionStart(el);
							    var endSelection = getSelectionEnd(el);

							    if (selectAll) selectContentEditable(el);

							    if (startSelection === endSelection) return;

							    // NOTE: If selection is not contain initial and final invisible symbols
							    //we should select its
							    correctContentEditableSelectionBeforeDelete(el);

							    deleteSelectionRanges(el);

							    var selection = getSelectionByElement(el);
							    var range = null;

							    //NOTE: We should try to do selection collapsed
							    if (selection.rangeCount && !selection.getRangeAt(0).collapsed) {
							        range = selection.getRangeAt(0);
							        range.collapse(true);
							    }
							}

							function setCursorToLastVisiblePosition(el) {
							    var position = contentEditable.getLastVisiblePosition(el);

							    selectContentEditable(el, position, position);
							}

							function hasElementContainsSelection(el) {
							    var selection = getSelectionByElement(el);

							    return selection.anchorNode && selection.focusNode ? domUtils.isElementContainsNode(el, selection.anchorNode) && domUtils.isElementContainsNode(el, selection.focusNode) : false;
							}
						},
						"wait-for.js": function (exports, module, require) {
							

							exports.__esModule = true;

							exports.default = function (fn, delay, timeout) {
							    return new Promise(function (resolve, reject) {
							        var result = fn();

							        if (result) {
							            resolve(result);
							            return;
							        }

							        var intervalId = nativeMethods.setInterval.call(window, function () {
							            result = fn();

							            if (result) {
							                nativeMethods.clearInterval.call(window, intervalId);
							                nativeMethods.clearTimeout.call(window, timeoutId);
							                resolve(result);
							            }
							        }, delay);

							        var timeoutId = nativeMethods.setTimeout.call(window, function () {
							            nativeMethods.clearInterval.call(window, intervalId);
							            reject();
							        }, timeout);
							    });
							};

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var Promise = _hammerhead2.default.Promise;
							var nativeMethods = _hammerhead2.default.nativeMethods;

							module.exports = exports['default'];
						}
					}
				}
			},
			"client-functions": {
				"selectors": {
					"selector-attribute-filter.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = selectorAttributeFilter;
						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						/* eslint-disable no-undef */
						function selectorAttributeFilter(node, index, originNode, attrName, attrValue) {
						    if (node.nodeType !== 1) return false;

						    var attributes = node.attributes;
						    var attr = null;

						    var check = function check(actual, expect) {
						        return typeof expect === 'string' ? expect === actual : expect.test(actual);
						    };

						    for (var i = 0; i < attributes.length; i++) {
						        attr = attributes[i];

						        if (check(attr.nodeName, attrName) && (!attrValue || check(attr.nodeValue, attrValue))) return true;
						    }

						    return false;
						}
						/* eslint-enable no-undef */

						module.exports = exports['default'];
					},
					"selector-text-filter.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = selectorTextFilter;
						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						/* eslint-disable no-undef */
						function selectorTextFilter(node, index, originNode, textFilter) {

						    function hasChildrenWithText(parentNode) {
						        var cnCount = parentNode.childNodes.length;

						        for (var i = 0; i < cnCount; i++) {
						            if (selectorTextFilter(parentNode.childNodes[i], index, originNode, textFilter)) return true;
						        }

						        return false;
						    }

						    function checkNodeText(text) {
						        if (textFilter instanceof RegExp) return textFilter.test(text);
						        return textFilter === text.trim();
						    }

						    // Element
						    if (node.nodeType === 1) {
						        var text = node.innerText;

						        // NOTE: In Firefox, <option> elements don't have `innerText`.
						        // So, we fallback to `textContent` in that case (see GH-861).
						        if (node.tagName.toLowerCase() === 'option') {
						            var textContent = node.textContent;

						            if (!text && textContent) text = textContent;
						        }

						        return checkNodeText(text);
						    }

						    // Document
						    if (node.nodeType === 9) {
						        // NOTE: latest version of Edge doesn't have `innerText` for `document`,
						        // `html` and `body`. So we check their children instead.
						        var head = node.querySelector('head');
						        var body = node.querySelector('body');

						        return hasChildrenWithText(head, textFilter) || hasChildrenWithText(body, textFilter);
						    }

						    // DocumentFragment
						    if (node.nodeType === 11) return hasChildrenWithText(node, textFilter);

						    return checkNodeText(node.textContent);
						}
						/* eslint-enable no-undef */

						module.exports = exports['default'];
					}
				}
			},
			"test-run": {
				"client-messages.js": function (exports, module, require) {
					

					exports.__esModule = true;
					exports.default = {
					    ready: 'ready',
					    readyForBrowserManipulation: 'ready-for-browser-manipulation',
					    waitForFileDownload: 'wait-for-file-download'
					};
					module.exports = exports['default'];
				}
			}
		}
	}
})("testcafe-phoenix/src/client/core/index");

    }

    initTestCafeCore(window);
})();
