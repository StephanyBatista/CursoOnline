// NOTE: We should have the capability to initialize scripts with different contexts.
// This is required for iframes without the src attribute because Hammerhead does not
// inject scripts into such iframes. So, we wrap all scripts in initialization functions.
(function () {
    function initTestCafeAutomation(window, isIFrameWithoutSrc) {
        var document = window.document;

        // This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"testcafe-phoenix": {
		"src": {
			"client": {
				"automation": {
					"cursor.js": function (exports, module, require) {
						

						exports.__esModule = true;

						var _testcafeCore = require('./deps/testcafe-core');

						var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

						var _testcafeUi = require('./deps/testcafe-ui');

						var _testcafeUi2 = _interopRequireDefault(_testcafeUi);

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var domUtils = _testcafeCore2.default.domUtils;
						var cursorUI = window.top === window ? _testcafeUi2.default.cursorUI : _testcafeUi2.default.iframeCursorUI;

						// NOTE: the default position should be outside of the page (GH-794)
						exports.default = {
						    x: -1,
						    y: -1,
						    currentActiveWindow: window.top,

						    _ensureActiveWindow: function _ensureActiveWindow() {
						        if (this.currentActiveWindow === window || this.currentActiveWindow === window.parent) return;

						        var activeFrame = domUtils.findIframeByWindow(this.currentActiveWindow);

						        if (!activeFrame || !domUtils.isElementInDocument(activeFrame)) this.currentActiveWindow = window;
						    },


						    get active() {
						        this._ensureActiveWindow();
						        return this.currentActiveWindow === window;
						    },

						    set activeWindow(win) {
						        this.currentActiveWindow = win;
						    },

						    get activeWindow() {
						        this._ensureActiveWindow();
						        return this.currentActiveWindow;
						    },

						    get position() {
						        return { x: this.x, y: this.y };
						    },

						    get visible() {
						        return window.top === window && cursorUI.isVisible();
						    },

						    move: function move(newX, newY) {
						        this.x = newX;
						        this.y = newY;

						        return cursorUI.move(this.x, this.y);
						    },
						    hide: function hide() {
						        if (this.visible) cursorUI.hide();
						    },
						    show: function show() {
						        if (window.top === window) cursorUI.show();
						    },
						    leftButtonDown: function leftButtonDown() {
						        return cursorUI.leftButtonDown();
						    },
						    rightButtonDown: function rightButtonDown() {
						        return cursorUI.rightButtonDown();
						    },
						    buttonUp: function buttonUp() {
						        return cursorUI.buttonUp();
						    }
						};
						module.exports = exports['default'];
					},
					"deps": {
						"hammerhead.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = window['%hammerhead%'];
							module.exports = exports['default'];
						},
						"testcafe-core.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = window['%testCafeCore%'];
							module.exports = exports['default'];
						},
						"testcafe-ui.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = window['%testCafeUI%'];
							module.exports = exports['default'];
						}
					},
					"errors.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = {
						    elementIsInvisibleError: 'elementIsInvisibleError',
						    foundElementIsNotTarget: 'foundElementIsNotTarget'
						};
						module.exports = exports['default'];
					},
					"get-element.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.fromPoint = fromPoint;
						exports.underCursor = underCursor;

						var _hammerhead = require('./deps/hammerhead');

						var _hammerhead2 = _interopRequireDefault(_hammerhead);

						var _testcafeCore = require('./deps/testcafe-core');

						var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

						var _testcafeUi = require('./deps/testcafe-ui');

						var _testcafeUi2 = _interopRequireDefault(_testcafeUi);

						var _cursor = require('./cursor');

						var _cursor2 = _interopRequireDefault(_cursor);

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var browserUtils = _hammerhead2.default.utils.browser;
						var Promise = _hammerhead2.default.Promise;
						var nativeMethods = _hammerhead2.default.nativeMethods;
						var positionUtils = _testcafeCore2.default.positionUtils;
						var domUtils = _testcafeCore2.default.domUtils;

						function getElementFromPoint(x, y, underTopShadowUIElement) {
						    var topElement = null;

						    return _testcafeUi2.default.hide(underTopShadowUIElement).then(function () {
						        topElement = positionUtils.getElementFromPoint(x, y);

						        return _testcafeUi2.default.show(underTopShadowUIElement);
						    }).then(function () {
						        return topElement;
						    });
						}

						function ensureImageMap(imgElement, areaElement) {
						    var mapElement = domUtils.closest(areaElement, 'map');

						    return mapElement && mapElement.name === imgElement.useMap.substring(1) ? areaElement : imgElement;
						}

						function findElementOrNonEmptyChildFromPoint(x, y, element) {
						    var topElement = positionUtils.getElementFromPoint(x, y);
						    var isNonEmptyChild = domUtils.containsElement(element, topElement) && nativeMethods.nodeTextContentGetter.call(topElement).length;

						    if (topElement && topElement === element || isNonEmptyChild) return topElement;

						    return null;
						}

						function correctTopElementByExpectedElement(topElement, expectedElement) {
						    var expectedElementDefined = expectedElement && domUtils.isDomElement(expectedElement);

						    if (!expectedElementDefined || !topElement || topElement === expectedElement) return topElement;

						    var isTREFElement = domUtils.getTagName(expectedElement) === 'tref';

						    // NOTE: 'document.elementFromPoint' can't find these types of elements
						    if (isTREFElement) return expectedElement;

						    // NOTE: T299665 - Incorrect click automation for images with an associated map element in Firefox
						    // All browsers return the <area> element from document.getElementFromPoint, but
						    // Firefox returns the <img> element. We should accomplish this for Firefox as well.
						    var isImageMapArea = domUtils.getTagName(expectedElement) === 'area' && domUtils.isImgElement(topElement);

						    if (browserUtils.isFirefox && isImageMapArea) return ensureImageMap(topElement, expectedElement);

						    // NOTE: try to find a multi-line link by its rectangle (T163678)
						    var isLinkOrChildExpected = domUtils.isAnchorElement(expectedElement) || domUtils.getParents(expectedElement, 'a').length;

						    var isTopElementChildOfLink = isLinkOrChildExpected && domUtils.containsElement(expectedElement, topElement) && nativeMethods.nodeTextContentGetter.call(topElement).length;

						    var shouldSearchForMultilineLink = isLinkOrChildExpected && !isTopElementChildOfLink && nativeMethods.nodeTextContentGetter.call(expectedElement).length;

						    if (!shouldSearchForMultilineLink) return topElement;

						    var linkRect = expectedElement.getBoundingClientRect();

						    return findElementOrNonEmptyChildFromPoint(linkRect.right - 1, linkRect.top + 1, expectedElement) || findElementOrNonEmptyChildFromPoint(linkRect.left + 1, linkRect.bottom - 1, expectedElement) || topElement;
						}

						function fromPoint(x, y, expectedElement) {
						    var isInIframe = window !== window.top;
						    var foundElement = null;

						    return getElementFromPoint(x, y).then(function (topElement) {
						        foundElement = topElement;

						        // NOTE: when trying to get an element by elementFromPoint in iframe and the target
						        // element is under any of shadow-ui elements, you will get null (only in IE).
						        // In this case, you should hide a top window's shadow-ui root to obtain an element.
						        var resChain = Promise.resolve(topElement);

						        if (!foundElement && isInIframe && x > 0 && y > 0) {
						            resChain = resChain.then(function () {
						                return getElementFromPoint(x, y, true);
						            }).then(function (element) {
						                foundElement = element;

						                return element;
						            });
						        }

						        return resChain.then(function (element) {
						            return correctTopElementByExpectedElement(element, expectedElement);
						        }).then(function (correctedElement) {
						            return { element: correctedElement, corrected: correctedElement !== foundElement };
						        });
						    });
						}

						function underCursor() {
						    var cursorPosition = _cursor2.default.position;

						    return fromPoint(cursorPosition.x, cursorPosition.y).then(function (_ref) {
						        var element = _ref.element;
						        return element;
						    });
						}
					},
					"index.js": function (exports, module, require) {
						

						var _hammerhead = require('./deps/hammerhead');

						var _hammerhead2 = _interopRequireDefault(_hammerhead);

						var _scroll = require('./playback/scroll');

						var _scroll2 = _interopRequireDefault(_scroll);

						var _click = require('./playback/click');

						var _click2 = _interopRequireDefault(_click);

						var _selectChild = require('./playback/click/select-child');

						var _selectChild2 = _interopRequireDefault(_selectChild);

						var _dblclick = require('./playback/dblclick');

						var _dblclick2 = _interopRequireDefault(_dblclick);

						var _toOffset = require('./playback/drag/to-offset');

						var _toOffset2 = _interopRequireDefault(_toOffset);

						var _toElement = require('./playback/drag/to-element');

						var _toElement2 = _interopRequireDefault(_toElement);

						var _hover = require('./playback/hover');

						var _hover2 = _interopRequireDefault(_hover);

						var _press = require('./playback/press');

						var _press2 = _interopRequireDefault(_press);

						var _rclick = require('./playback/rclick');

						var _rclick2 = _interopRequireDefault(_rclick);

						var _selectText = require('./playback/select/select-text');

						var _selectText2 = _interopRequireDefault(_selectText);

						var _selectEditableContent = require('./playback/select/select-editable-content');

						var _selectEditableContent2 = _interopRequireDefault(_selectEditableContent);

						var _type = require('./playback/type');

						var _type2 = _interopRequireDefault(_type);

						var _upload = require('./playback/upload');

						var _upload2 = _interopRequireDefault(_upload);

						var _options = require('../../test-run/commands/options');

						var _settings = require('./settings');

						var _settings2 = _interopRequireDefault(_settings);

						var _offsets = require('./utils/offsets');

						var _calculateSelectTextArguments = require('./playback/select/calculate-select-text-arguments');

						var _calculateSelectTextArguments2 = _interopRequireDefault(_calculateSelectTextArguments);

						var _errors = require('./errors');

						var _errors2 = _interopRequireDefault(_errors);

						var _cursor = require('./cursor');

						var _cursor2 = _interopRequireDefault(_cursor);

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						exports.Scroll = _scroll2.default;
						exports.Click = _click2.default;
						exports.SelectChildClick = _selectChild2.default;
						exports.DblClick = _dblclick2.default;
						exports.DragToOffset = _toOffset2.default;
						exports.DragToElement = _toElement2.default;
						exports.Hover = _hover2.default;
						exports.Press = _press2.default;
						exports.RClick = _rclick2.default;
						exports.SelectText = _selectText2.default;
						exports.SelectEditableContent = _selectEditableContent2.default;
						exports.Type = _type2.default;
						exports.Upload = _upload2.default;
						exports.MouseOptions = _options.MouseOptions;
						exports.ClickOptions = _options.ClickOptions;
						exports.TypeOptions = _options.TypeOptions;

						exports.ERROR_TYPES = _errors2.default;
						exports.AutomationSettings = _settings2.default;
						exports.getOffsetOptions = _offsets.getOffsetOptions;
						exports.calculateSelectTextArguments = _calculateSelectTextArguments2.default;
						exports.cursor = _cursor2.default;

						exports.get = require;

						_hammerhead2.default.nativeMethods.objectDefineProperty.call(window, window, '%testCafeAutomation%', {
						    configurable: true,
						    value: exports
						});

						/* eslint-disable no-undef */
						_hammerhead2.default.on(_hammerhead2.default.EVENTS.evalIframeScript, function (e) {
						    return initTestCafeAutomation(e.iframe.contentWindow, true);
						});
						/* eslint-enable no-undef */
					},
					"playback": {
						"click": {
							"index.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _testcafeUi = require('../../deps/testcafe-ui');

								var _testcafeUi2 = _interopRequireDefault(_testcafeUi);

								var _visibleElementAutomation = require('../visible-element-automation');

								var _visibleElementAutomation2 = _interopRequireDefault(_visibleElementAutomation);

								var _utils = require('../../utils/utils');

								var _cursor = require('../../cursor');

								var _cursor2 = _interopRequireDefault(_cursor);

								var _nextTick = require('../../utils/next-tick');

								var _nextTick2 = _interopRequireDefault(_nextTick);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

								function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

								var Promise = _hammerhead2.default.Promise;

								var extend = _hammerhead2.default.utils.extend;
								var browserUtils = _hammerhead2.default.utils.browser;
								var featureDetection = _hammerhead2.default.utils.featureDetection;
								var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;

								var domUtils = _testcafeCore2.default.domUtils;
								var styleUtils = _testcafeCore2.default.styleUtils;
								var eventUtils = _testcafeCore2.default.eventUtils;
								var arrayUtils = _testcafeCore2.default.arrayUtils;
								var delay = _testcafeCore2.default.delay;

								var selectElementUI = _testcafeUi2.default.selectElement;

								var ClickAutomation = function (_VisibleElementAutoma) {
								    _inherits(ClickAutomation, _VisibleElementAutoma);

								    function ClickAutomation(element, clickOptions) {
								        _classCallCheck(this, ClickAutomation);

								        var _this = _possibleConstructorReturn(this, _VisibleElementAutoma.call(this, element, clickOptions));

								        _this.modifiers = clickOptions.modifiers;
								        _this.caretPos = clickOptions.caretPos;

								        _this.targetElementParentNodes = [];
								        _this.activeElementBeforeMouseDown = null;
								        _this.mouseDownElement = null;

								        _this.eventState = {
								            mousedownPrevented: false,
								            blurRaised: false,
								            simulateDefaultBehavior: true,
								            clickElement: null
								        };
								        return _this;
								    }

								    ClickAutomation.prototype._bindMousedownHandler = function _bindMousedownHandler() {
								        var _this2 = this;

								        var onmousedown = function onmousedown(e) {
								            _this2.eventState.mousedownPrevented = e.defaultPrevented;
								            eventUtils.preventDefault(e);
								            eventUtils.unbind(_this2.element, 'mousedown', onmousedown);
								        };

								        eventUtils.bind(this.element, 'mousedown', onmousedown);
								    };

								    ClickAutomation.prototype._bindBlurHandler = function _bindBlurHandler(element) {
								        var _this3 = this;

								        var onblur = function onblur() {
								            _this3.eventState.blurRaised = true;
								            eventUtils.unbind(element, 'blur', onblur, true);
								        };

								        eventUtils.bind(element, 'blur', onblur, true);
								    };

								    ClickAutomation.prototype._bindClickHandler = function _bindClickHandler(element) {
								        var onclick = function onclick(e) {
								            eventUtils.preventDefault(e, true);
								            eventUtils.unbind(element, 'click', onclick);
								        };

								        eventUtils.bind(element, 'click', onclick);
								    };

								    ClickAutomation.prototype._raiseTouchEvents = function _raiseTouchEvents(eventArgs) {
								        if (featureDetection.isTouchDevice) {
								            eventSimulator.touchstart(eventArgs.element, eventArgs.options);
								            eventSimulator.touchend(eventArgs.element, eventArgs.options);
								        }
								    };

								    ClickAutomation.prototype._mousedown = function _mousedown(eventArgs) {
								        var _this4 = this;

								        this.targetElementParentNodes = domUtils.getParents(eventArgs.element);
								        this.mouseDownElement = eventArgs.element;

								        return _cursor2.default.leftButtonDown().then(function () {
								            _this4._raiseTouchEvents(eventArgs);

								            var activeElement = domUtils.getActiveElement();

								            _this4.activeElementBeforeMouseDown = activeElement;

								            // NOTE: In WebKit and IE, the mousedown event opens the select element's dropdown;
								            // therefore, we should prevent mousedown and hide the dropdown (B236416).
								            var needCloseSelectDropDown = (browserUtils.isWebKit || browserUtils.isIE) && domUtils.isSelectElement(_this4.mouseDownElement);

								            if (needCloseSelectDropDown) _this4._bindMousedownHandler();

								            _this4._bindBlurHandler(activeElement);

								            _this4.eventState.simulateDefaultBehavior = eventSimulator.mousedown(eventArgs.element, eventArgs.options);

								            if (_this4.eventState.simulateDefaultBehavior === false) _this4.eventState.simulateDefaultBehavior = needCloseSelectDropDown && !_this4.eventState.mousedownPrevented;

								            return _this4._ensureActiveElementBlur(activeElement);
								        }).then(function () {
								            return _this4._focus(eventArgs);
								        });
								    };

								    ClickAutomation.prototype._ensureActiveElementBlur = function _ensureActiveElementBlur(element) {
								        var _this5 = this;

								        // NOTE: In some cases, mousedown may lead to active element change (browsers raise blur).
								        // We simulate the blur event if the active element was changed after the mousedown, and
								        // the blur event does not get raised automatically (B239273, B253520)
								        return new Promise(function (resolve) {
								            var simulateBlur = domUtils.getActiveElement() !== element && !_this5.eventState.blurRaised;

								            if (!simulateBlur) {
								                resolve();
								                return;
								            }

								            if (browserUtils.isIE && browserUtils.version < 12) {
								                // NOTE: In whatever way an element is blurred from the client script, the
								                // blur event is raised asynchronously in IE (in MSEdge focus/blur is sync)
								                (0, _nextTick2.default)().then(function () {
								                    if (!_this5.eventState.blurRaised) eventSimulator.blur(element);

								                    resolve();
								                });
								            } else {
								                eventSimulator.blur(element);
								                resolve();
								            }
								        });
								    };

								    ClickAutomation.prototype._focus = function _focus(eventArgs) {
								        if (this.eventState.simulateDefaultBehavior === false) return Promise.resolve();

								        // NOTE: If a target element is a contentEditable element, we need to call focusAndSetSelection directly for
								        // this element. Otherwise, if the element obtained by elementFromPoint is a child of the contentEditable
								        // element, a selection position may be calculated incorrectly (by using the caretPos option).
								        var elementForFocus = domUtils.isContentEditableElement(this.element) ? this.element : eventArgs.element;

								        // NOTE: IE doesn't perform focus if active element has been changed while executing mousedown
								        var simulateFocus = !browserUtils.isIE || this.activeElementBeforeMouseDown === domUtils.getActiveElement();

								        return (0, _utils.focusAndSetSelection)(elementForFocus, simulateFocus, this.caretPos);
								    };

								    ClickAutomation._getElementForClick = function _getElementForClick(mouseDownElement, topElement, mouseDownElementParentNodes) {
								        var topElementParentNodes = domUtils.getParents(topElement);
								        var areElementsSame = domUtils.isTheSameNode(topElement, mouseDownElement);

								        // NOTE: Mozilla Firefox always skips click, if an element under cursor has been changed after mousedown.
								        if (browserUtils.isFirefox) return areElementsSame ? mouseDownElement : null;

								        if (!areElementsSame) {
								            if (mouseDownElement.contains(topElement) && !domUtils.isEditableFormElement(topElement)) return mouseDownElement;

								            if (topElement.contains(mouseDownElement)) return topElement;

								            // NOTE: If elements are not in the parent-child relationships,
								            // non-ff browsers raise the `click` event for their common parent.
								            return arrayUtils.getCommonElement(topElementParentNodes, mouseDownElementParentNodes);
								        }

								        // NOTE: In case the target element and the top element are the same,
								        // non-FF browsers are dispatching the `click` event if the target
								        // element hasn't changed its position in the DOM after mousedown.
								        return arrayUtils.equals(mouseDownElementParentNodes, topElementParentNodes) ? mouseDownElement : null;
								    };

								    ClickAutomation.prototype._mouseup = function _mouseup(eventArgs) {
								        var _this6 = this;

								        return _cursor2.default.buttonUp().then(function () {
								            return _this6._getElementForEvent(eventArgs);
								        }).then(function (element) {
								            eventArgs.element = element;

								            _this6.eventState.clickElement = ClickAutomation._getElementForClick(_this6.mouseDownElement, element, _this6.targetElementParentNodes);

								            eventSimulator.mouseup(element, eventArgs.options);
								        });
								    };

								    ClickAutomation.prototype._click = function _click(eventArgs) {
								        if (domUtils.isOptionElement(eventArgs.element)) return eventArgs.element;

								        if (this.eventState.clickElement) {
								            var isColorInput = domUtils.isInputElement(this.eventState.clickElement) && this.eventState.clickElement.type === 'color';

								            if (browserUtils.isFirefox && isColorInput) this._bindClickHandler(this.eventState.clickElement);

								            eventSimulator.click(this.eventState.clickElement, eventArgs.options);
								        }

								        if (!domUtils.isElementFocusable(eventArgs.element)) (0, _utils.focusByRelatedElement)(eventArgs.element);

								        // NOTE: Emulating the click event on the 'select' element doesn't expand the
								        // dropdown with options (except chrome), therefore we should emulate it.
								        var isSelectElement = domUtils.isSelectElement(eventArgs.element);
								        var isSelectWithDropDown = isSelectElement && styleUtils.getSelectElementSize(eventArgs.element) === 1;

								        if (isSelectWithDropDown && this.eventState.simulateDefaultBehavior !== false) {
								            if (selectElementUI.isOptionListExpanded(eventArgs.element)) selectElementUI.collapseOptionList();else selectElementUI.expandOptionList(eventArgs.element);
								        }

								        return eventArgs;
								    };

								    ClickAutomation.prototype.run = function run(useStrictElementCheck) {
								        var _this7 = this;

								        var eventArgs = null;

								        return this._ensureElement(useStrictElementCheck).then(function (_ref) {
								            var element = _ref.element,
								                clientPoint = _ref.clientPoint,
								                screenPoint = _ref.screenPoint,
								                devicePoint = _ref.devicePoint;

								            eventArgs = {
								                point: clientPoint,
								                screenPoint: screenPoint,
								                element: element,
								                options: extend({
								                    clientX: clientPoint.x,
								                    clientY: clientPoint.y,
								                    screenX: devicePoint.x,
								                    screenY: devicePoint.y
								                }, _this7.modifiers)
								            };

								            // NOTE: we should raise mouseup event with 'mouseActionStepDelay' after we trigger
								            // mousedown event regardless of how long mousedown event handlers were executing
								            return Promise.all([delay(_this7.automationSettings.mouseActionStepDelay), _this7._mousedown(eventArgs)]);
								        }).then(function () {
								            return _this7._mouseup(eventArgs);
								        }).then(function () {
								            return _this7._click(eventArgs);
								        });
								    };

								    return ClickAutomation;
								}(_visibleElementAutomation2.default);

								exports.default = ClickAutomation;
								module.exports = exports['default'];
							},
							"select-child.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _testcafeUi = require('../../deps/testcafe-ui');

								var _testcafeUi2 = _interopRequireDefault(_testcafeUi);

								var _move2 = require('../move');

								var _move3 = _interopRequireDefault(_move2);

								var _options = require('../../../../test-run/commands/options');

								var _offsets = require('../../utils/offsets');

								var _settings = require('../../settings');

								var _settings2 = _interopRequireDefault(_settings);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								var Promise = _hammerhead2.default.Promise;

								var browserUtils = _hammerhead2.default.utils.browser;
								var featureDetection = _hammerhead2.default.utils.featureDetection;
								var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;
								var focusBlurSandbox = _hammerhead2.default.eventSandbox.focusBlur;

								var domUtils = _testcafeCore2.default.domUtils;
								var styleUtils = _testcafeCore2.default.styleUtils;
								var delay = _testcafeCore2.default.delay;

								var selectElementUI = _testcafeUi2.default.selectElement;

								var FOCUS_DELAY = featureDetection.isTouchDevice ? 0 : 160;

								var SelectChildClickAutomation = function () {
								    function SelectChildClickAutomation(element, clickOptions) {
								        _classCallCheck(this, SelectChildClickAutomation);

								        this.element = element;
								        this.modifiers = clickOptions.modifiers;
								        this.caretPos = clickOptions.caretPos;

								        this.offsetX = clickOptions.offsetX;
								        this.offsetY = clickOptions.offsetY;
								        this.speed = clickOptions.speed;

								        this.automationSettings = new _settings2.default(clickOptions.speed);

								        this.parentSelect = domUtils.getSelectParent(this.element);
								        this.optionListExpanded = this.parentSelect ? selectElementUI.isOptionListExpanded(this.parentSelect) : false;
								        this.childIndex = null;
								        this.clickCausesChange = false;

								        if (this.parentSelect) {
								            var isOption = domUtils.isOptionElement(this.element);
								            var selectedIndex = this.parentSelect.selectedIndex;

								            this.childIndex = isOption ? domUtils.getElementIndexInParent(this.parentSelect, this.element) : domUtils.getElementIndexInParent(this.parentSelect, this.element);

								            var parentOptGroup = domUtils.isOptionGroupElement(this.element.parentNode) ? this.element.parentNode : null;
								            var isDisabled = this.element.disabled || parentOptGroup && parentOptGroup.disabled;

								            this.clickCausesChange = isOption && !isDisabled && this.childIndex !== selectedIndex;
								        }

								        this.eventsArgs = {
								            options: this.modifiers,
								            element: this.element
								        };
								    }

								    SelectChildClickAutomation.prototype._calculateEventArguments = function _calculateEventArguments() {
								        var childElement = this.optionListExpanded ? selectElementUI.getEmulatedChildElement(this.element) : this.element;
								        var parentSelectSize = styleUtils.getSelectElementSize(this.parentSelect) > 1;

								        return {
								            options: this.modifiers,
								            element: browserUtils.isIE && parentSelectSize ? this.parentSelect : childElement
								        };
								    };

								    SelectChildClickAutomation.prototype._getMoveArguments = function _getMoveArguments() {
								        var element = null;
								        var offsetX = null;
								        var offsetY = null;

								        if (this.optionListExpanded) {
								            element = selectElementUI.getEmulatedChildElement(this.element);

								            var moveActionOffsets = (0, _offsets.getDefaultAutomationOffsets)(element);

								            offsetX = moveActionOffsets.offsetX;
								            offsetY = moveActionOffsets.offsetY;
								        } else {
								            element = document.documentElement;

								            var elementCenter = selectElementUI.getSelectChildCenter(this.element);

								            offsetX = elementCenter.x;
								            offsetY = elementCenter.y;
								        }

								        return { element: element, offsetX: offsetX, offsetY: offsetY, speed: this.speed };
								    };

								    SelectChildClickAutomation.prototype._move = function _move(_ref) {
								        var _this = this;

								        var element = _ref.element,
								            offsetX = _ref.offsetX,
								            offsetY = _ref.offsetY,
								            speed = _ref.speed;

								        var moveOptions = new _options.MoveOptions({
								            offsetX: offsetX,
								            offsetY: offsetY,
								            speed: speed,

								            modifiers: this.modifiers
								        }, false);

								        var moveAutomation = new _move3.default(element, moveOptions);

								        return moveAutomation.run().then(function () {
								            return delay(_this.automationSettings.mouseActionStepDelay);
								        });
								    };

								    SelectChildClickAutomation.prototype._mousedown = function _mousedown() {
								        var _this2 = this;

								        if (browserUtils.isFirefox) {
								            eventSimulator.mousedown(this.eventsArgs.element, this.eventsArgs.options);

								            if (this.clickCausesChange) this.parentSelect.selectedIndex = this.childIndex;

								            return this._focus();
								        }

								        if (browserUtils.isIE) {
								            eventSimulator.mousedown(this.eventsArgs.element, this.eventsArgs.options);

								            return this._focus();
								        }

								        // NOTE: In Chrome, document.activeElement is 'select' after mousedown. But we need to
								        // raise blur and change the event for a previously active element during focus raising.
								        // That's why we should change the event order and raise focus before mousedown.
								        return this._focus().then(function () {
								            return delay(FOCUS_DELAY);
								        }).then(function () {
								            eventSimulator.mousedown(_this2.eventsArgs.element, _this2.eventsArgs.options);

								            if (_this2.clickCausesChange) _this2.parentSelect.selectedIndex = _this2.childIndex;
								        });
								    };

								    SelectChildClickAutomation.prototype._focus = function _focus() {
								        var _this3 = this;

								        return new Promise(function (resolve) {
								            focusBlurSandbox.focus(_this3.parentSelect, resolve, false, true);
								        });
								    };

								    SelectChildClickAutomation.prototype._mouseup = function _mouseup() {
								        var elementForMouseupEvent = browserUtils.isIE ? this.parentSelect : this.eventsArgs.element;

								        eventSimulator.mouseup(elementForMouseupEvent, this.eventsArgs.options);

								        if (browserUtils.isIE && this.clickCausesChange) this.parentSelect.selectedIndex = this.childIndex;

								        var simulateInputEventOnValueChange = browserUtils.isFirefox || browserUtils.isSafari || browserUtils.isChrome && browserUtils.version >= 53;

								        var simulateChangeEventOnValueChange = simulateInputEventOnValueChange || browserUtils.isIE;

								        if (simulateInputEventOnValueChange && this.clickCausesChange) eventSimulator.input(this.parentSelect);

								        if (simulateChangeEventOnValueChange && this.clickCausesChange) eventSimulator.change(this.parentSelect);

								        return Promise.resolve();
								    };

								    SelectChildClickAutomation.prototype._click = function _click() {
								        eventSimulator.click(this.eventsArgs.element, this.eventsArgs.options);
								    };

								    SelectChildClickAutomation.prototype.run = function run() {
								        var _this4 = this;

								        if (!this.parentSelect) {
								            eventSimulator.click(this.eventsArgs.element, this.eventsArgs.options);

								            return Promise.resolve();
								        }

								        if (!this.optionListExpanded) selectElementUI.scrollOptionListByChild(this.element);

								        var moveArguments = this._getMoveArguments();

								        this.eventsArgs = this._calculateEventArguments();

								        if (styleUtils.getSelectElementSize(this.parentSelect) <= 1) {
								            return this._move(moveArguments).then(function () {
								                return _this4._click();
								            });
								        }

								        return this._move(moveArguments).then(function () {
								            return _this4._mousedown();
								        }).then(function () {
								            return _this4._mouseup();
								        }).then(function () {
								            return _this4._click();
								        });
								    };

								    return SelectChildClickAutomation;
								}();

								exports.default = SelectChildClickAutomation;
								module.exports = exports['default'];
							}
						},
						"dblclick.js": function (exports, module, require) {
							

							exports.__esModule = true;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _testcafeCore = require('../deps/testcafe-core');

							var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

							var _options = require('../../../test-run/commands/options');

							var _visibleElementAutomation = require('./visible-element-automation');

							var _visibleElementAutomation2 = _interopRequireDefault(_visibleElementAutomation);

							var _click = require('./click');

							var _click2 = _interopRequireDefault(_click);

							var _settings = require('../settings');

							var _settings2 = _interopRequireDefault(_settings);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

							function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

							function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

							var featureDetection = _hammerhead2.default.utils.featureDetection;
							var browserUtils = _hammerhead2.default.utils.browser;
							var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;

							var eventUtils = _testcafeCore2.default.eventUtils;
							var delay = _testcafeCore2.default.delay;

							var FIRST_CLICK_DELAY = featureDetection.isTouchDevice ? 0 : 160;

							var DblClickAutomation = function (_VisibleElementAutoma) {
							    _inherits(DblClickAutomation, _VisibleElementAutoma);

							    function DblClickAutomation(element, clickOptions) {
							        _classCallCheck(this, DblClickAutomation);

							        var _this = _possibleConstructorReturn(this, _VisibleElementAutoma.call(this, element, clickOptions));

							        _this.modifiers = clickOptions.modifiers;
							        _this.caretPos = clickOptions.caretPos;
							        _this.speed = clickOptions.speed;

							        _this.automationSettings = new _settings2.default(_this.speed);

							        _this.offsetX = clickOptions.offsetX;
							        _this.offsetY = clickOptions.offsetY;

							        _this.eventArgs = null;

							        _this.eventState = {
							            dblClickElement: null
							        };
							        return _this;
							    }

							    DblClickAutomation.prototype._firstClick = function _firstClick(useStrictElementCheck) {
							        var _this2 = this;

							        // NOTE: we should always perform click with the highest speed
							        var clickOptions = new _options.ClickOptions(this.options);

							        clickOptions.speed = 1;

							        var clickAutomation = new _click2.default(this.element, clickOptions);

							        clickAutomation.on(clickAutomation.TARGET_ELEMENT_FOUND_EVENT, function (e) {
							            return _this2.emit(_this2.TARGET_ELEMENT_FOUND_EVENT, e);
							        });

							        return clickAutomation.run(useStrictElementCheck).then(function (clickEventArgs) {
							            return delay(FIRST_CLICK_DELAY).then(function () {
							                return clickEventArgs;
							            });
							        });
							    };

							    DblClickAutomation.prototype._secondClick = function _secondClick(eventArgs) {
							        var _this3 = this;

							        //NOTE: we should not call focus after the second mousedown (except in IE) because of the native browser behavior
							        if (browserUtils.isIE) eventUtils.bind(document, 'focus', eventUtils.preventDefault, true);

							        var clickOptions = new _options.ClickOptions({
							            offsetX: eventArgs.screenPoint.x,
							            offsetY: eventArgs.screenPoint.y,
							            caretPos: this.caretPos,
							            modifiers: this.modifiers,
							            speed: 1
							        });

							        var clickAutomation = new _click2.default(document.documentElement, clickOptions);

							        return clickAutomation.run().then(function (clickEventArgs) {
							            // NOTE: We should raise the `dblclick` event on an element that
							            // has been actually clicked during the second click automation.
							            _this3.eventState.dblClickElement = clickAutomation.eventState.clickElement;

							            if (browserUtils.isIE) eventUtils.unbind(document, 'focus', eventUtils.preventDefault, true);

							            return clickEventArgs;
							        });
							    };

							    DblClickAutomation.prototype._dblClick = function _dblClick(eventArgs) {
							        if (this.eventState.dblClickElement) eventSimulator.dblclick(this.eventState.dblClickElement, eventArgs.options);
							    };

							    DblClickAutomation.prototype.run = function run(useStrictElementCheck) {
							        var _this4 = this;

							        // NOTE: If the target element is out of viewport the firstClick sub-automation raises an error
							        return this._firstClick(useStrictElementCheck).then(function (eventArgs) {
							            return _this4._secondClick(eventArgs);
							        }).then(function (eventArgs) {
							            return _this4._dblClick(eventArgs);
							        });
							    };

							    return DblClickAutomation;
							}(_visibleElementAutomation2.default);

							exports.default = DblClickAutomation;
							module.exports = exports['default'];
						},
						"drag": {
							"base.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _getElement = require('../../get-element');

								var _visibleElementAutomation = require('../visible-element-automation');

								var _visibleElementAutomation2 = _interopRequireDefault(_visibleElementAutomation);

								var _move = require('../move');

								var _move2 = _interopRequireDefault(_move);

								var _options = require('../../../../test-run/commands/options');

								var _cursor = require('../../cursor');

								var _cursor2 = _interopRequireDefault(_cursor);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

								function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

								var MIN_MOVING_TIME = 25;

								var Promise = _hammerhead2.default.Promise;
								var extend = _hammerhead2.default.utils.extend;
								var featureDetection = _hammerhead2.default.utils.featureDetection;
								var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;
								var focusBlurSandbox = _hammerhead2.default.eventSandbox.focusBlur;

								var DragAutomationBase = function (_VisibleElementAutoma) {
								    _inherits(DragAutomationBase, _VisibleElementAutoma);

								    function DragAutomationBase(element, mouseOptions) {
								        _classCallCheck(this, DragAutomationBase);

								        var _this = _possibleConstructorReturn(this, _VisibleElementAutoma.call(this, element, mouseOptions));

								        _this.modifiers = mouseOptions.modifiers;
								        _this.speed = mouseOptions.speed;
								        _this.offsetX = mouseOptions.offsetX;
								        _this.offsetY = mouseOptions.offsetY;

								        _this.endPoint = null;
								        _this.downEvent = featureDetection.isTouchDevice ? 'touchstart' : 'mousedown';
								        _this.upEvent = featureDetection.isTouchDevice ? 'touchend' : 'mouseup';

								        _this.dragAndDropState = null;
								        return _this;
								    }

								    DragAutomationBase.prototype._getEndPoint = function _getEndPoint() {
								        throw new Error('Not implemented');
								    };

								    DragAutomationBase.prototype._mousedown = function _mousedown(eventArgs) {
								        var _this2 = this;

								        return _cursor2.default.leftButtonDown().then(function () {
								            eventSimulator[_this2.downEvent](eventArgs.element, eventArgs.options);

								            return _this2._focus(eventArgs);
								        });
								    };

								    DragAutomationBase.prototype._focus = function _focus(eventArgs) {
								        var _this3 = this;

								        return new Promise(function (resolve) {
								            // NOTE: If the target element is a child of a contentEditable element, we need to call focus for its parent
								            var elementForFocus = _testcafeCore.domUtils.isContentEditableElement(_this3.element) ? _testcafeCore.contentEditable.findContentEditableParent(_this3.element) : eventArgs.element;

								            focusBlurSandbox.focus(elementForFocus, resolve, false, true);
								        });
								    };

								    DragAutomationBase.prototype._getDestination = function _getDestination() {
								        throw new Error('Not implemented');
								    };

								    DragAutomationBase.prototype._drag = function _drag() {
								        var _this4 = this;

								        var _getDestination2 = this._getDestination(),
								            element = _getDestination2.element,
								            offsets = _getDestination2.offsets,
								            endPoint = _getDestination2.endPoint;

								        this.endPoint = endPoint;

								        var dragOptions = new _options.MoveOptions({
								            offsetX: offsets.offsetX,
								            offsetY: offsets.offsetY,
								            modifiers: this.modifiers,
								            speed: this.speed,
								            minMovingTime: MIN_MOVING_TIME,
								            holdLeftButton: true
								        }, false);

								        var moveAutomation = new _move2.default(element, dragOptions);

								        return moveAutomation.run().then(function (dragAndDropState) {
								            _this4.dragAndDropState = dragAndDropState;

								            return (0, _testcafeCore.delay)(_this4.automationSettings.mouseActionStepDelay);
								        });
								    };

								    DragAutomationBase.prototype._mouseup = function _mouseup() {
								        var _this5 = this;

								        return _cursor2.default.buttonUp().then(function () {
								            var point = _testcafeCore.positionUtils.offsetToClientCoords(_this5.endPoint);
								            var topElement = null;
								            var options = extend({
								                clientX: point.x,
								                clientY: point.y
								            }, _this5.modifiers);

								            return (0, _getElement.fromPoint)(point.x, point.y).then(function (_ref) {
								                var element = _ref.element;

								                topElement = element;

								                if (!topElement) return topElement;

								                if (_this5.dragAndDropState.enabled) {
								                    options.dataTransfer = _this5.dragAndDropState.dataTransfer;

								                    if (_this5.dragAndDropState.dropAllowed) eventSimulator.drop(topElement, options);

								                    eventSimulator.dragend(_this5.dragAndDropState.element, options);
								                    _this5.dragAndDropState.dataStore.setProtectedMode();
								                } else eventSimulator[_this5.upEvent](topElement, options);

								                return (0, _getElement.fromPoint)(point.x, point.y);
								            }).then(function (_ref2) {
								                var element = _ref2.element;

								                //B231323
								                if (topElement && element === topElement && !_this5.dragAndDropState.enabled) eventSimulator.click(topElement, options);
								            });
								        });
								    };

								    DragAutomationBase.prototype.run = function run(useStrictElementCheck) {
								        var _this6 = this;

								        var eventArgs = null;

								        return this._ensureElement(useStrictElementCheck).then(function (_ref3) {
								            var element = _ref3.element,
								                clientPoint = _ref3.clientPoint;

								            eventArgs = {
								                point: clientPoint,
								                element: element,
								                options: extend({
								                    clientX: clientPoint.x,
								                    clientY: clientPoint.y
								                }, _this6.modifiers)
								            };

								            // NOTE: we should raise start drag with 'mouseActionStepDelay' after we trigger
								            // mousedown event regardless of how long mousedown event handlers were executing
								            return Promise.all([(0, _testcafeCore.delay)(_this6.automationSettings.mouseActionStepDelay), _this6._mousedown(eventArgs)]);
								        }).then(function () {
								            return _this6._drag();
								        }).then(function () {
								            return _this6._mouseup();
								        });
								    };

								    return DragAutomationBase;
								}(_visibleElementAutomation2.default);

								exports.default = DragAutomationBase;
								module.exports = exports['default'];
							},
							"drag-and-drop-state.js": function (exports, module, require) {
								

								exports.__esModule = true;

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								var DragAndDropState = function DragAndDropState() {
								    _classCallCheck(this, DragAndDropState);

								    this.enabled = false;
								    this.dropAllowed = false;
								    this.element = null;
								    this.dataTransfer = null;
								    this.dataStore = null;
								};

								exports.default = DragAndDropState;
								module.exports = exports["default"];
							},
							"to-element.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _base = require('./base');

								var _base2 = _interopRequireDefault(_base);

								var _offsets = require('../../utils/offsets');

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

								function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

								var positionUtils = _testcafeCore2.default.positionUtils;

								var DragToElementAutomation = function (_DragAutomationBase) {
								    _inherits(DragToElementAutomation, _DragAutomationBase);

								    function DragToElementAutomation(element, destinationElement, dragToElementOptions) {
								        _classCallCheck(this, DragToElementAutomation);

								        var _this = _possibleConstructorReturn(this, _DragAutomationBase.call(this, element, dragToElementOptions));

								        _this.destinationElement = destinationElement;
								        _this.destinationOffsetX = dragToElementOptions.destinationOffsetX;
								        _this.destinationOffsetY = dragToElementOptions.destinationOffsetY;
								        return _this;
								    }

								    DragToElementAutomation.prototype._getDestination = function _getDestination() {
								        var element = this.destinationElement;
								        var elementRect = positionUtils.getElementRectangle(element);
								        var offsets = (0, _offsets.getOffsetOptions)(element, this.destinationOffsetX, this.destinationOffsetY);

								        var endPoint = {
								            x: elementRect.left + offsets.offsetX,
								            y: elementRect.top + offsets.offsetY
								        };

								        return { element: element, offsets: offsets, endPoint: endPoint };
								    };

								    return DragToElementAutomation;
								}(_base2.default);

								exports.default = DragToElementAutomation;
								module.exports = exports['default'];
							},
							"to-offset.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _base = require('./base');

								var _base2 = _interopRequireDefault(_base);

								var _getAutomationPoint = require('../../utils/get-automation-point');

								var _getAutomationPoint2 = _interopRequireDefault(_getAutomationPoint);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

								function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

								var styleUtils = _testcafeCore2.default.styleUtils;

								var DragToOffsetAutomation = function (_DragAutomationBase) {
								    _inherits(DragToOffsetAutomation, _DragAutomationBase);

								    function DragToOffsetAutomation(element, offsetX, offsetY, mouseOptions) {
								        _classCallCheck(this, DragToOffsetAutomation);

								        var _this = _possibleConstructorReturn(this, _DragAutomationBase.call(this, element, mouseOptions));

								        _this.dragOffsetX = offsetX;
								        _this.dragOffsetY = offsetY;
								        return _this;
								    }

								    DragToOffsetAutomation.prototype._getDestination = function _getDestination() {
								        var startPoint = (0, _getAutomationPoint2.default)(this.element, this.offsetX, this.offsetY);
								        var maxX = styleUtils.getWidth(document);
								        var maxY = styleUtils.getHeight(document);

								        var endPoint = {
								            x: startPoint.x + this.dragOffsetX,
								            y: startPoint.y + this.dragOffsetY
								        };

								        endPoint = {
								            x: Math.min(Math.max(0, endPoint.x), maxX),
								            y: Math.min(Math.max(0, endPoint.y), maxY)
								        };

								        var element = document.documentElement;

								        var offsets = {
								            offsetX: endPoint.x,
								            offsetY: endPoint.y
								        };

								        return { element: element, offsets: offsets, endPoint: endPoint };
								    };

								    return DragToOffsetAutomation;
								}(_base2.default);

								exports.default = DragToOffsetAutomation;
								module.exports = exports['default'];
							}
						},
						"hover.js": function (exports, module, require) {
							

							exports.__esModule = true;

							var _visibleElementAutomation = require('./visible-element-automation');

							var _visibleElementAutomation2 = _interopRequireDefault(_visibleElementAutomation);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

							function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

							function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

							var HoverAutomation = function (_VisibleElementAutoma) {
							    _inherits(HoverAutomation, _VisibleElementAutoma);

							    function HoverAutomation(element, hoverOptions) {
							        _classCallCheck(this, HoverAutomation);

							        return _possibleConstructorReturn(this, _VisibleElementAutoma.call(this, element, hoverOptions));
							    }

							    HoverAutomation.prototype.run = function run(useStrictElementCheck) {
							        return this._ensureElement(useStrictElementCheck, true);
							    };

							    return HoverAutomation;
							}(_visibleElementAutomation2.default);

							exports.default = HoverAutomation;
							module.exports = exports['default'];
						},
						"move": {
							"event-sequence": {
								"base.js": function (exports, module, require) {
									

									exports.__esModule = true;

									var _hammerhead = require('../../../deps/hammerhead');

									var _hammerhead2 = _interopRequireDefault(_hammerhead);

									var _testcafeCore = require('../../../deps/testcafe-core');

									function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

									function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

									var browserUtils = _hammerhead2.default.utils.browser;

									var MoveEventSequenceBase = function () {
									    function MoveEventSequenceBase() {
									        _classCallCheck(this, MoveEventSequenceBase);

									        this.dragAndDropMode = false;
									        this.dropAllowed = false;
									    }

									    MoveEventSequenceBase.prototype.setup = function setup() {
									        this.dragAndDropMode = false;
									        this.dropAllowed = false;
									    };

									    MoveEventSequenceBase.prototype.leaveElement = function leaveElement() /* currentElement, prevElement, commonAncestor, options */{};

									    MoveEventSequenceBase.prototype.move = function move() /* element, options, moveEvent */{};

									    MoveEventSequenceBase.prototype.enterElement = function enterElement() /* currentElement, prevElement, commonAncestor, options */{};

									    MoveEventSequenceBase.prototype.dragAndDrop = function dragAndDrop() /* dragElement, currentElement, prevElement, options, dragDataStore */{};

									    MoveEventSequenceBase.prototype.teardown = function teardown() /* currentElement, eventOptions, prevElement, moveEvent */{};

									    MoveEventSequenceBase.prototype.run = function run(currentElement, prevElement, options, moveEvent, dragElement, dragDataStore) {
									        // NOTE: if last hovered element was in an iframe that has been removed, IE
									        // raises an exception when we try to compare it with the current element
									        var prevElementInDocument = prevElement && _testcafeCore.domUtils.isElementInDocument(prevElement);

									        var prevElementInRemovedIframe = prevElement && _testcafeCore.domUtils.isElementInIframe(prevElement) && !_testcafeCore.domUtils.getIframeByElement(prevElement);

									        if (!prevElementInDocument || prevElementInRemovedIframe) prevElement = null;

									        var elementChanged = currentElement !== prevElement;
									        var commonAncestor = elementChanged ? _testcafeCore.domUtils.getCommonAncestor(currentElement, prevElement) : null;

									        this.setup();

									        if (elementChanged && !!prevElement) this.leaveElement(currentElement, prevElement, commonAncestor, options);

									        if (browserUtils.isIE) this.move(currentElement, options, moveEvent);

									        if (elementChanged && _testcafeCore.domUtils.isElementInDocument(currentElement)) this.enterElement(currentElement, prevElement, commonAncestor, options);

									        if (!browserUtils.isIE) this.move(currentElement, options, moveEvent);

									        this.dragAndDrop(dragElement, currentElement, prevElement, options, dragDataStore);
									        this.teardown(currentElement, options, prevElement, moveEvent);

									        var dragAndDropMode = this.dragAndDropMode;
									        var dropAllowed = this.dropAllowed;

									        this.dragAndDropMode = false;
									        this.dropAllowed = false;

									        return { dragAndDropMode: dragAndDropMode, dropAllowed: dropAllowed };
									    };

									    return MoveEventSequenceBase;
									}();

									exports.default = MoveEventSequenceBase;
									module.exports = exports['default'];
								},
								"drag-and-drop-first-move.js": function (exports, module, require) {
									

									exports.__esModule = true;

									var _hammerhead = require('../../../deps/hammerhead');

									var _hammerhead2 = _interopRequireDefault(_hammerhead);

									var _base = require('./base');

									var _base2 = _interopRequireDefault(_base);

									var _index = require('./index');

									var _index2 = _interopRequireDefault(_index);

									var _dragAndDropMove = require('./drag-and-drop-move');

									var _dragAndDropMove2 = _interopRequireDefault(_dragAndDropMove);

									function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

									function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

									function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

									function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

									var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;

									var DragAndDropFirstMoveEventSequence = function (_MoveEventSequenceBas) {
									    _inherits(DragAndDropFirstMoveEventSequence, _MoveEventSequenceBas);

									    function DragAndDropFirstMoveEventSequence() {
									        _classCallCheck(this, DragAndDropFirstMoveEventSequence);

									        return _possibleConstructorReturn(this, _MoveEventSequenceBas.apply(this, arguments));
									    }

									    DragAndDropFirstMoveEventSequence.prototype.setup = function setup() {
									        _MoveEventSequenceBas.prototype.setup.call(this);

									        this.dragAndDropMode = true;
									    };

									    DragAndDropFirstMoveEventSequence.prototype.leaveElement = function leaveElement() {
									        _index2.default.leaveElement.apply(this, arguments);
									    };

									    DragAndDropFirstMoveEventSequence.prototype.move = function move() {
									        _index2.default.move.apply(this, arguments);
									    };

									    DragAndDropFirstMoveEventSequence.prototype.enterElement = function enterElement() {
									        _index2.default.enterElement.apply(this, arguments);
									    };

									    DragAndDropFirstMoveEventSequence.prototype.dragAndDrop = function dragAndDrop(dragElement, currentElement, prevElement, options, dragDataStore) {
									        var dragAllowed = eventSimulator.dragstart(dragElement, options);

									        dragDataStore.setReadOnlyMode();

									        if (!dragAllowed) {
									            this.dragAndDropMode = false;
									            return;
									        }

									        _dragAndDropMove2.default.dragAndDrop.apply(this, arguments);
									    };

									    DragAndDropFirstMoveEventSequence.prototype.run = function run(currentElement, prevElement, options, moveEvent, dragElement, dragDataStore) {
									        return _MoveEventSequenceBas.prototype.run.call(this, currentElement, null, options, moveEvent, dragElement, dragDataStore);
									    };

									    return DragAndDropFirstMoveEventSequence;
									}(_base2.default);

									exports.default = new DragAndDropFirstMoveEventSequence();
									module.exports = exports['default'];
								},
								"drag-and-drop-move.js": function (exports, module, require) {
									

									exports.__esModule = true;

									var _hammerhead = require('../../../deps/hammerhead');

									var _hammerhead2 = _interopRequireDefault(_hammerhead);

									var _testcafeCore = require('../../../deps/testcafe-core');

									var _base = require('./base');

									var _base2 = _interopRequireDefault(_base);

									function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

									function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

									function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

									function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

									var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;

									var DragAndDropMoveEventSequence = function (_MoveEventSequenceBas) {
									    _inherits(DragAndDropMoveEventSequence, _MoveEventSequenceBas);

									    function DragAndDropMoveEventSequence() {
									        _classCallCheck(this, DragAndDropMoveEventSequence);

									        return _possibleConstructorReturn(this, _MoveEventSequenceBas.apply(this, arguments));
									    }

									    DragAndDropMoveEventSequence.prototype.setup = function setup() {
									        _MoveEventSequenceBas.prototype.setup.call(this);

									        this.dragAndDropMode = true;
									    };

									    DragAndDropMoveEventSequence.prototype.dragAndDrop = function dragAndDrop(dragElement, currentElement, prevElement, options) {
									        eventSimulator.drag(dragElement, options);

									        var currentElementChanged = currentElement !== prevElement;

									        if (currentElementChanged) {
									            if (_testcafeCore.domUtils.isElementInDocument(currentElement)) {
									                options.relatedTarget = prevElement;

									                eventSimulator.dragenter(currentElement, options);
									            }

									            if (prevElement) {
									                options.relatedTarget = currentElement;

									                eventSimulator.dragleave(prevElement, options);
									            }
									        }

									        this.dropAllowed = !eventSimulator.dragover(currentElement, options);
									    };

									    return DragAndDropMoveEventSequence;
									}(_base2.default);

									exports.default = new DragAndDropMoveEventSequence();
									module.exports = exports['default'];
								},
								"index.js": function (exports, module, require) {
									

									exports.__esModule = true;

									var _hammerhead = require('../../../deps/hammerhead');

									var _hammerhead2 = _interopRequireDefault(_hammerhead);

									var _testcafeCore = require('../../../deps/testcafe-core');

									var _base = require('./base');

									var _base2 = _interopRequireDefault(_base);

									function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

									function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

									function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

									function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

									var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;
									var extend = _hammerhead2.default.utils.extend;

									var MoveEventSequence = function (_MoveEventSequenceBas) {
									    _inherits(MoveEventSequence, _MoveEventSequenceBas);

									    function MoveEventSequence() {
									        _classCallCheck(this, MoveEventSequence);

									        return _possibleConstructorReturn(this, _MoveEventSequenceBas.apply(this, arguments));
									    }

									    MoveEventSequence.prototype.leaveElement = function leaveElement(currentElement, prevElement, commonAncestor, options) {
									        eventSimulator.mouseout(prevElement, extend({ relatedTarget: currentElement }, options));

									        var currentParent = prevElement;

									        while (currentParent && currentParent !== commonAncestor) {
									            eventSimulator.mouseleave(currentParent, extend({ relatedTarget: currentElement }, options));
									            currentParent = currentParent.parentNode;
									        }
									    };

									    MoveEventSequence.prototype.move = function move(element, options, moveEvent) {
									        eventSimulator[moveEvent](element, options);
									    };

									    MoveEventSequence.prototype.enterElement = function enterElement(currentElement, prevElement, commonAncestor, options) {
									        eventSimulator.mouseover(currentElement, extend({ relatedTarget: prevElement }, options));

									        var currentParent = currentElement;
									        var mouseenterElements = [];

									        while (currentParent && currentParent !== commonAncestor) {
									            mouseenterElements.push(currentParent);
									            currentParent = currentParent.parentNode;
									        }

									        mouseenterElements.reverse();

									        for (var i = 0; i < mouseenterElements.length; i++) {
									            eventSimulator.mouseenter(mouseenterElements[i], extend({ relatedTarget: prevElement }, options));
									        }
									    };

									    MoveEventSequence.prototype.teardown = function teardown(currentElement, eventOptions, prevElement, moveEvent) {
									        // NOTE: we need to add an extra 'mousemove' if the element was changed because sometimes
									        // the client script requires several 'mousemove' events for an element (T246904)
									        if (_testcafeCore.domUtils.isElementInDocument(currentElement) && currentElement !== prevElement) eventSimulator[moveEvent](currentElement, eventOptions);
									    };

									    return MoveEventSequence;
									}(_base2.default);

									exports.default = new MoveEventSequence();
									module.exports = exports['default'];
								}
							},
							"index.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _options = require('../../../../test-run/commands/options');

								var _scroll2 = require('../scroll');

								var _scroll3 = _interopRequireDefault(_scroll2);

								var _cursor = require('../../cursor');

								var _cursor2 = _interopRequireDefault(_cursor);

								var _getElement = require('../../get-element');

								var _getAutomationPoint = require('../../utils/get-automation-point');

								var _getAutomationPoint2 = _interopRequireDefault(_getAutomationPoint);

								var _getLineRectIntersection = require('../../utils/get-line-rect-intersection');

								var _getLineRectIntersection2 = _interopRequireDefault(_getLineRectIntersection);

								var _getDevicePoint = require('../../utils/get-device-point');

								var _getDevicePoint2 = _interopRequireDefault(_getDevicePoint);

								var _nextTick = require('../../utils/next-tick');

								var _nextTick2 = _interopRequireDefault(_nextTick);

								var _settings = require('../../settings');

								var _settings2 = _interopRequireDefault(_settings);

								var _dragAndDropState = require('../drag/drag-and-drop-state');

								var _dragAndDropState2 = _interopRequireDefault(_dragAndDropState);

								var _eventSequence = require('./event-sequence');

								var _eventSequence2 = _interopRequireDefault(_eventSequence);

								var _dragAndDropMove = require('./event-sequence/drag-and-drop-move');

								var _dragAndDropMove2 = _interopRequireDefault(_dragAndDropMove);

								var _dragAndDropFirstMove = require('./event-sequence/drag-and-drop-first-move');

								var _dragAndDropFirstMove2 = _interopRequireDefault(_dragAndDropFirstMove);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								var Promise = _hammerhead2.default.Promise;
								var nativeMethods = _hammerhead2.default.nativeMethods;
								var featureDetection = _hammerhead2.default.utils.featureDetection;
								var htmlUtils = _hammerhead2.default.utils.html;
								var urlUtils = _hammerhead2.default.utils.url;
								var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;
								var messageSandbox = _hammerhead2.default.eventSandbox.message;
								var DataTransfer = _hammerhead2.default.eventSandbox.DataTransfer;
								var DragDataStore = _hammerhead2.default.eventSandbox.DragDataStore;

								var positionUtils = _testcafeCore2.default.positionUtils;
								var domUtils = _testcafeCore2.default.domUtils;
								var styleUtils = _testcafeCore2.default.styleUtils;
								var eventUtils = _testcafeCore2.default.eventUtils;
								var promiseUtils = _testcafeCore2.default.promiseUtils;
								var sendRequestToFrame = _testcafeCore2.default.sendRequestToFrame;

								var MOVE_REQUEST_CMD = 'automation|move|request';
								var MOVE_RESPONSE_CMD = 'automation|move|response';

								// Setup cross-iframe interaction
								messageSandbox.on(messageSandbox.SERVICE_MSG_RECEIVED_EVENT, function (e) {
								    if (e.message.cmd === MOVE_REQUEST_CMD) {
								        if (e.source.parent === window) MoveAutomation.onMoveToIframeRequest(e);else {
								            _hammerhead2.default.on(_hammerhead2.default.EVENTS.beforeUnload, function () {
								                return messageSandbox.sendServiceMsg({ cmd: MOVE_RESPONSE_CMD }, e.source);
								            });

								            MoveAutomation.onMoveOutRequest(e);
								        }
								    }
								});

								// Utils
								function findDraggableElement(element) {
								    var parentNode = element;

								    while (parentNode) {
								        if (parentNode.draggable) return parentNode;

								        parentNode = parentNode.parentNode;
								    }

								    return null;
								}

								// Static
								var lastHoveredElement = null;

								var MoveAutomation = function () {
								    function MoveAutomation(element, moveOptions) {
								        _classCallCheck(this, MoveAutomation);

								        this.touchMode = featureDetection.isTouchDevice;
								        this.moveEvent = this.touchMode ? 'touchmove' : 'mousemove';

								        this.holdLeftButton = moveOptions.holdLeftButton;
								        this.dragElement = null;

								        this.dragAndDropState = new _dragAndDropState2.default();

								        this.automationSettings = new _settings2.default(moveOptions.speed);

								        var target = MoveAutomation.getTarget(element, moveOptions.offsetX, moveOptions.offsetY);

								        this.element = target.element;
								        this.offsetX = target.offsetX;
								        this.offsetY = target.offsetY;
								        this.speed = moveOptions.speed;
								        this.cursorSpeed = this.holdLeftButton ? this.automationSettings.draggingSpeed : this.automationSettings.cursorSpeed;

								        this.minMovingTime = moveOptions.minMovingTime || null;
								        this.modifiers = moveOptions.modifiers || {};
								        this.skipScrolling = moveOptions.skipScrolling;

								        this.endPoint = null;

								        // moving state
								        this.movingTime = null;
								        this.x = null;
								        this.y = null;
								        this.startTime = null;
								        this.endTime = null;
								        this.distanceX = null;
								        this.distanceY = null;

								        this.firstMovingStepOccured = false;
								    }

								    MoveAutomation.getTarget = function getTarget(el, offsetX, offsetY) {
								        // NOTE: if the target point (considering offsets) is out of
								        // the element change the target element to the document element
								        var relateToDocument = !positionUtils.containsOffset(el, offsetX, offsetY);
								        var relatedPoint = relateToDocument ? (0, _getAutomationPoint2.default)(el, offsetX, offsetY) : { x: offsetX, y: offsetY };

								        return {
								            element: relateToDocument ? document.documentElement : el,
								            offsetX: relatedPoint.x,
								            offsetY: relatedPoint.y
								        };
								    };

								    MoveAutomation.onMoveToIframeRequest = function onMoveToIframeRequest(e) {
								        var iframePoint = {
								            x: e.message.endX,
								            y: e.message.endY
								        };

								        var iframeWin = e.source;
								        var iframe = domUtils.findIframeByWindow(iframeWin);
								        var iframeBorders = styleUtils.getBordersWidth(iframe);
								        var iframePadding = styleUtils.getElementPadding(iframe);
								        var iframeRectangle = positionUtils.getIframeClientCoordinates(iframe);
								        var iframePointRelativeToParent = positionUtils.getIframePointRelativeToParentFrame(iframePoint, iframeWin);
								        var cursorPosition = _cursor2.default.position;

								        var intersectionPoint = positionUtils.isInRectangle(cursorPosition, iframeRectangle) ? cursorPosition : (0, _getLineRectIntersection2.default)(cursorPosition, iframePointRelativeToParent, iframeRectangle);

								        var intersectionRelatedToIframe = {
								            x: intersectionPoint.x - iframeRectangle.left,
								            y: intersectionPoint.y - iframeRectangle.top
								        };

								        var moveOptions = new _options.MoveOptions({
								            modifiers: e.message.modifiers,
								            offsetX: intersectionRelatedToIframe.x + iframeBorders.left + iframePadding.left,
								            offsetY: intersectionRelatedToIframe.y + iframeBorders.top + iframePadding.top,
								            speed: e.message.speed,

								            // NOTE: we should not perform scrolling because the active window was
								            // already scrolled to the target element before the request (GH-847)
								            skipScrolling: true
								        }, false);

								        var moveAutomation = new MoveAutomation(iframe, moveOptions);

								        var responseMsg = {
								            cmd: MOVE_RESPONSE_CMD,
								            x: intersectionRelatedToIframe.x,
								            y: intersectionRelatedToIframe.y
								        };

								        if (_cursor2.default.activeWindow !== iframeWin) {
								            moveAutomation.run().then(function () {
								                _cursor2.default.activeWindow = iframeWin;

								                messageSandbox.sendServiceMsg(responseMsg, iframeWin);
								            });
								        } else messageSandbox.sendServiceMsg(responseMsg, iframeWin);
								    };

								    MoveAutomation.onMoveOutRequest = function onMoveOutRequest(e) {
								        var parentWin = e.source;

								        var iframeRectangle = {
								            left: e.message.left,
								            right: e.message.right,
								            top: e.message.top,
								            bottom: e.message.bottom
								        };

								        if (!e.message.iframeUnderCursor) {
								            var _e$message = e.message,
								                startX = _e$message.startX,
								                startY = _e$message.startY;


								            var clientX = startX - iframeRectangle.left;
								            var clientY = startY - iframeRectangle.top;

								            // NOTE: We should not emulate mouseout and mouseleave if iframe was reloaded.
								            if (lastHoveredElement) {
								                eventSimulator.mouseout(lastHoveredElement, { clientX: clientX, clientY: clientY, relatedTarget: null });
								                eventSimulator.mouseleave(lastHoveredElement, { clientX: clientX, clientY: clientY, relatedTarget: null });
								            }

								            messageSandbox.sendServiceMsg({ cmd: MOVE_RESPONSE_CMD }, parentWin);

								            return;
								        }

								        var cursorPosition = _cursor2.default.position;

								        var startPoint = {
								            x: iframeRectangle.left + cursorPosition.x,
								            y: iframeRectangle.top + cursorPosition.y
								        };

								        var endPoint = { x: e.message.endX, y: e.message.endY };
								        var intersectionPoint = (0, _getLineRectIntersection2.default)(startPoint, endPoint, iframeRectangle);

								        // NOTE: We should not move the cursor out of the iframe if
								        // the cursor path does not intersect with the iframe borders.
								        if (!intersectionPoint) {
								            messageSandbox.sendServiceMsg({
								                cmd: MOVE_RESPONSE_CMD,
								                x: iframeRectangle.left,
								                y: iframeRectangle.top
								            }, parentWin);

								            return;
								        }

								        var moveOptions = new _options.MoveOptions({
								            modifiers: e.message.modifiers,
								            offsetX: intersectionPoint.x - iframeRectangle.left,
								            offsetY: intersectionPoint.y - iframeRectangle.top,
								            speed: e.message.speed,

								            // NOTE: we should not perform scrolling because the active window was
								            // already scrolled to the target element before the request (GH-847)
								            skipScrolling: true
								        }, false);

								        var moveAutomation = new MoveAutomation(document.documentElement, moveOptions);

								        moveAutomation.run().then(function () {
								            var responseMsg = {
								                cmd: MOVE_RESPONSE_CMD,
								                x: intersectionPoint.x,
								                y: intersectionPoint.y
								            };

								            _cursor2.default.activeWindow = parentWin;
								            messageSandbox.sendServiceMsg(responseMsg, parentWin);
								        });
								    };

								    MoveAutomation.prototype._getTargetClientPoint = function _getTargetClientPoint() {
								        var scroll = styleUtils.getElementScroll(this.element);

								        if (domUtils.isHtmlElement(this.element)) {
								            return {
								                x: Math.floor(this.offsetX - scroll.left),
								                y: Math.floor(this.offsetY - scroll.top)
								            };
								        }

								        var clientPosition = positionUtils.getClientPosition(this.element);
								        var isDocumentBody = this.element.tagName && domUtils.isBodyElement(this.element);

								        return {
								            x: Math.floor(isDocumentBody ? clientPosition.x + this.offsetX : clientPosition.x + this.offsetX - scroll.left),
								            y: Math.floor(isDocumentBody ? clientPosition.y + this.offsetY : clientPosition.y + this.offsetY - scroll.top)
								        };
								    };

								    MoveAutomation.prototype._emulateEvents = function _emulateEvents(currentElement) {
								        var button = this.holdLeftButton ? eventUtils.BUTTONS_PARAMETER.leftButton : eventUtils.BUTTONS_PARAMETER.noButton;
								        var devicePoint = (0, _getDevicePoint2.default)({ x: this.x, y: this.y });

								        var eventOptions = {
								            clientX: this.x,
								            clientY: this.y,
								            screenX: devicePoint.x,
								            screenY: devicePoint.y,
								            buttons: button,
								            ctrl: this.modifiers.ctrl,
								            alt: this.modifiers.alt,
								            shift: this.modifiers.shift,
								            meta: this.modifiers.meta,
								            dataTransfer: this.dragAndDropState.dataTransfer
								        };

								        var eventSequence = null;

								        if (this.dragAndDropState.enabled) eventSequence = this.firstMovingStepOccured ? _dragAndDropMove2.default : _dragAndDropFirstMove2.default;else eventSequence = _eventSequence2.default;

								        var _eventSequence$run = eventSequence.run(currentElement, lastHoveredElement, eventOptions, this.moveEvent, this.dragElement, this.dragAndDropState.dataStore),
								            dragAndDropMode = _eventSequence$run.dragAndDropMode,
								            dropAllowed = _eventSequence$run.dropAllowed;

								        this.firstMovingStepOccured = true;
								        this.dragAndDropState.enabled = dragAndDropMode;
								        this.dragAndDropState.dropAllowed = dropAllowed;

								        lastHoveredElement = currentElement;
								    };

								    MoveAutomation.prototype._movingStep = function _movingStep() {
								        var _this = this;

								        if (this.touchMode && !this.holdLeftButton) {
								            this.x = this.endPoint.x;
								            this.y = this.endPoint.y;
								        } else if (!this.startTime) {
								            this.startTime = nativeMethods.dateNow();
								            this.endTime = this.startTime + this.movingTime;

								            // NOTE: the mousemove event can't be simulated at the point where the cursor
								            // was located at the start. Therefore, we add a minimal distance 1 px.
								            this.x += this.distanceX > 0 ? 1 : -1;
								            this.y += this.distanceY > 0 ? 1 : -1;
								        } else {
								            var currentTime = Math.min(nativeMethods.dateNow(), this.endTime);
								            var progress = (currentTime - this.startTime) / (this.endTime - this.startTime);

								            this.x = Math.floor(this.startPoint.x + this.distanceX * progress);
								            this.y = Math.floor(this.startPoint.y + this.distanceY * progress);
								        }

								        return _cursor2.default.move(this.x, this.y).then(_getElement.underCursor)
								        // NOTE: in touch mode, events are simulated for the element for which mousedown was simulated (GH-372)
								        .then(function (topElement) {
								            var currentElement = _this.holdLeftButton && _this.touchMode ? _this.dragElement : topElement;

								            // NOTE: it can be null in IE
								            if (!currentElement) return null;

								            return _this._emulateEvents(currentElement);
								        }).then(_nextTick2.default);
								    };

								    MoveAutomation.prototype._isMovingFinished = function _isMovingFinished() {
								        return this.x === this.endPoint.x && this.y === this.endPoint.y;
								    };

								    MoveAutomation.prototype._move = function _move() {
								        var _this2 = this;

								        this.startPoint = _cursor2.default.position;
								        this.x = this.startPoint.x;
								        this.y = this.startPoint.y;

								        this.distanceX = this.endPoint.x - this.startPoint.x;
								        this.distanceY = this.endPoint.y - this.startPoint.y;

								        this.movingTime = Math.max(Math.abs(this.distanceX), Math.abs(this.distanceY)) / this.cursorSpeed;

								        if (this.minMovingTime) this.movingTime = Math.max(this.movingTime, this.minMovingTime);

								        return promiseUtils.whilst(function () {
								            return !_this2._isMovingFinished();
								        }, function () {
								            return _this2._movingStep();
								        });
								    };

								    MoveAutomation.prototype._scroll = function _scroll() {
								        if (this.skipScrolling) return Promise.resolve();

								        var scrollOptions = new _options.ScrollOptions({ offsetX: this.offsetX, offsetY: this.offsetY }, false);
								        var scrollAutomation = new _scroll3.default(this.element, scrollOptions);

								        return scrollAutomation.run();
								    };

								    MoveAutomation.prototype._moveToCurrentFrame = function _moveToCurrentFrame() {
								        if (_cursor2.default.active) return Promise.resolve();

								        var _cursor$position = _cursor2.default.position,
								            x = _cursor$position.x,
								            y = _cursor$position.y;

								        var activeWindow = _cursor2.default.activeWindow;
								        var iframe = null;
								        var iframeUnderCursor = null;
								        var iframeRectangle = null;

								        var msg = {
								            cmd: MOVE_REQUEST_CMD,
								            startX: x,
								            startY: y,
								            endX: this.endPoint.x,
								            endY: this.endPoint.y,
								            modifiers: this.modifiers,
								            speed: this.speed
								        };

								        if (activeWindow.parent === window) {
								            iframe = domUtils.findIframeByWindow(activeWindow);
								            iframeRectangle = positionUtils.getIframeClientCoordinates(iframe);

								            msg.left = iframeRectangle.left;
								            msg.top = iframeRectangle.top;
								            msg.right = iframeRectangle.right;
								            msg.bottom = iframeRectangle.bottom;
								        }

								        return (0, _getElement.underCursor)().then(function (topElement) {
								            iframeUnderCursor = topElement === iframe;

								            if (activeWindow.parent === window) msg.iframeUnderCursor = iframeUnderCursor;

								            return sendRequestToFrame(msg, MOVE_RESPONSE_CMD, activeWindow);
								        }).then(function (message) {
								            _cursor2.default.activeWindow = window;

								            if (iframeUnderCursor || window.top !== window) return _cursor2.default.move(message.x, message.y);

								            return null;
								        });
								    };

								    MoveAutomation.prototype.run = function run() {
								        var _this3 = this;

								        return (0, _getElement.underCursor)().then(function (topElement) {
								            _this3.dragElement = _this3.holdLeftButton ? topElement : null;

								            var draggable = findDraggableElement(_this3.dragElement);

								            if (draggable && featureDetection.hasDataTransfer) {
								                _this3.dragAndDropState.enabled = true;
								                _this3.dragElement = draggable;
								                _this3.dragAndDropState.element = _this3.dragElement;
								                _this3.dragAndDropState.dataStore = new DragDataStore();
								                _this3.dragAndDropState.dataTransfer = new DataTransfer(_this3.dragAndDropState.dataStore);

								                var isLink = domUtils.isAnchorElement(_this3.dragElement);

								                if (isLink || domUtils.isImgElement(_this3.dragElement)) {
								                    var srcAttr = isLink ? 'href' : 'src';
								                    var parsedUrl = urlUtils.parseProxyUrl(_this3.dragElement[srcAttr]);
								                    var src = parsedUrl ? parsedUrl.destUrl : _this3.dragElement[srcAttr];
								                    var outerHTML = htmlUtils.cleanUpHtml(nativeMethods.elementOuterHTMLGetter.call(_this3.dragElement));

								                    _this3.dragAndDropState.dataTransfer.setData('text/plain', src);
								                    _this3.dragAndDropState.dataTransfer.setData('text/uri-list', src);
								                    _this3.dragAndDropState.dataTransfer.setData('text/html', outerHTML);
								                }
								            }

								            return _this3._scroll();
								        }).then(function () {
								            var _getTargetClientPoint2 = _this3._getTargetClientPoint(),
								                x = _getTargetClientPoint2.x,
								                y = _getTargetClientPoint2.y;

								            var windowWidth = styleUtils.getWidth(window);
								            var windowHeight = styleUtils.getHeight(window);

								            if (x >= 0 && x <= windowWidth && y >= 0 && y <= windowHeight) {
								                _this3.endPoint = { x: x, y: y };

								                return _this3._moveToCurrentFrame().then(function () {
								                    return _this3._move();
								                });
								            }

								            return null;
								        }).then(function () {
								            return _this3.dragAndDropState;
								        });
								    };

								    return MoveAutomation;
								}();

								exports.default = MoveAutomation;
								module.exports = exports['default'];
							}
						},
						"press": {
							"index.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _keyPressSimulator = require('./key-press-simulator');

								var _keyPressSimulator2 = _interopRequireDefault(_keyPressSimulator);

								var _shortcuts = require('./shortcuts');

								var _shortcuts2 = _interopRequireDefault(_shortcuts);

								var _utils = require('./utils');

								var _settings = require('../../settings');

								var _settings2 = _interopRequireDefault(_settings);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								var Promise = _hammerhead2.default.Promise;
								var browserUtils = _hammerhead2.default.utils.browser;
								var messageSandbox = _hammerhead2.default.eventSandbox.message;

								var PRESS_REQUEST_CMD = 'automation|press|request';
								var PRESS_RESPONSE_CMD = 'automation|press|response';

								// Setup cross-iframe interaction
								messageSandbox.on(messageSandbox.SERVICE_MSG_RECEIVED_EVENT, function (e) {
								    if (e.message.cmd === PRESS_REQUEST_CMD) {
								        _hammerhead2.default.on(_hammerhead2.default.EVENTS.beforeUnload, function () {
								            return messageSandbox.sendServiceMsg({ cmd: PRESS_RESPONSE_CMD }, e.source);
								        });

								        var pressAutomation = new PressAutomation(e.message.keyCombinations, e.message.options);

								        pressAutomation.run().then(function () {
								            return messageSandbox.sendServiceMsg({ cmd: PRESS_RESPONSE_CMD }, e.source);
								        });
								    }
								});

								var PressAutomation = function () {
								    function PressAutomation(keyCombinations, options) {
								        _classCallCheck(this, PressAutomation);

								        this.keyCombinations = keyCombinations;
								        this.isSelectElement = false;
								        this.pressedKeyString = '';
								        this.modifiersState = null;
								        this.shortcutHandlers = null;
								        this.topSameDomainDocument = _testcafeCore.domUtils.getTopSameDomainWindow(window).document;
								        this.automationSettings = new _settings2.default(options.speed);
								        this.options = options;
								    }

								    PressAutomation._getKeyPressSimulators = function _getKeyPressSimulators(keyCombination) {
								        var keysArray = (0, _testcafeCore.getKeyArray)(keyCombination);

								        // NOTE: symbols may have the same keyCode, but their "event.key" will be different, so we
								        // need to get the "event.key" property for each key, and add the 'shift' key where needed.

								        var _getActualKeysAndEven = (0, _utils.getActualKeysAndEventKeyProperties)(keysArray),
								            actualKeys = _getActualKeysAndEven.actualKeys,
								            eventKeyProperties = _getActualKeysAndEven.eventKeyProperties;

								        return _testcafeCore.arrayUtils.map(actualKeys, function (key, index) {
								            return new _keyPressSimulator2.default(key, eventKeyProperties[index]);
								        });
								    };

								    PressAutomation._getShortcuts = function _getShortcuts(keyCombination) {
								        var keys = (0, _testcafeCore.getKeyArray)(keyCombination.toLowerCase());
								        var shortcuts = [];
								        var curFullCombination = [];
								        var curCombination = [];

								        for (var i = 0; i < keys.length; i++) {
								            curFullCombination.push(keys[i]);

								            curCombination = curFullCombination.slice();

								            while (curCombination.length) {
								                var keyString = curCombination.join('+');

								                if (_shortcuts2.default[keyString]) {
								                    shortcuts.push(keyString);
								                    curFullCombination = curCombination = [];
								                } else curCombination.shift();
								            }
								        }

								        return shortcuts;
								    };

								    PressAutomation._getShortcutHandlers = function _getShortcutHandlers(keyCombination) {
								        var shortcuts = PressAutomation._getShortcuts(keyCombination.toLowerCase());
								        var shortcutHandlers = {};
								        var stringWithShortcut = '';
								        var shortcut = null;
								        var shortcutPosition = null;
								        var shortcutLength = null;

								        for (var i = 0; i < shortcuts.length; i++) {
								            shortcut = shortcuts[i];
								            shortcutPosition = keyCombination.indexOf(shortcut);
								            shortcutLength = shortcut.length;

								            stringWithShortcut += keyCombination.substring(0, shortcutPosition + shortcutLength);

								            shortcutHandlers[stringWithShortcut] = _shortcuts2.default[shortcut];

								            keyCombination = keyCombination.substring(shortcutPosition + shortcutLength);
								        }

								        return shortcutHandlers;
								    };

								    PressAutomation.prototype._down = function _down(keyPressSimulator) {
								        this.pressedKeyString += (this.pressedKeyString ? '+' : '') + keyPressSimulator.key;

								        var keyDownPrevented = !keyPressSimulator.down(this.modifiersState);

								        return Promise.resolve(keyDownPrevented);
								    };

								    PressAutomation.prototype._press = function _press(keyPressSimulator, keyEventPrevented) {
								        var _this = this;

								        // NOTE: preventing the 'keydown' and 'keypress' events for the select element does not
								        // affect the assignment of the new selectedIndex. So, we should execute a shortcut
								        // for the select element without taking into account that 'key' events are suppressed
								        if (keyEventPrevented && !this.isSelectElement) return (0, _testcafeCore.delay)(this.automationSettings.keyActionStepDelay);

								        var currentShortcutHandler = this.shortcutHandlers[this.pressedKeyString];
								        var keyPressPrevented = false;

								        // NOTE: B254435
								        if (!currentShortcutHandler || browserUtils.isFirefox || keyPressSimulator.key === 'enter') keyPressPrevented = !keyPressSimulator.press(this.modifiersState);

								        if ((!keyPressPrevented || this.isSelectElement) && currentShortcutHandler) {
								            return currentShortcutHandler((0, _utils.getDeepActiveElement)(this.topSameDomainDocument)).then(function () {
								                return (0, _testcafeCore.delay)(_this.automationSettings.keyActionStepDelay);
								            });
								        }

								        return (0, _testcafeCore.delay)(this.automationSettings.keyActionStepDelay);
								    };

								    PressAutomation.prototype._up = function _up(keyPressSimulator) {
								        keyPressSimulator.up(this.modifiersState);

								        return (0, _testcafeCore.delay)(this.automationSettings.keyActionStepDelay);
								    };

								    PressAutomation.prototype._runCombination = function _runCombination(keyCombination) {
								        var _this2 = this;

								        this.modifiersState = { ctrl: false, alt: false, shift: false, meta: false };
								        this.isSelectElement = _testcafeCore.domUtils.isSelectElement((0, _utils.getDeepActiveElement)(this.topSameDomainDocument));
								        this.pressedKeyString = '';
								        this.shortcutHandlers = PressAutomation._getShortcutHandlers(keyCombination);

								        var keyPressSimulators = PressAutomation._getKeyPressSimulators(keyCombination);

								        return _testcafeCore.promiseUtils.each(keyPressSimulators, function (keySimulator) {
								            return _this2._down(keySimulator).then(function (keyEventPrevented) {
								                return _this2._press(keySimulator, keyEventPrevented);
								            });
								        }).then(function () {
								            _testcafeCore.arrayUtils.reverse(keyPressSimulators);

								            return _testcafeCore.promiseUtils.each(keyPressSimulators, function (keySimulator) {
								                return _this2._up(keySimulator);
								            });
								        });
								    };

								    PressAutomation.prototype.run = function run() {
								        var _this3 = this;

								        var activeElement = _testcafeCore.domUtils.getActiveElement();
								        var activeElementIsIframe = _testcafeCore.domUtils.isIframeElement(activeElement);

								        if (window.top === window && activeElementIsIframe && activeElement.contentWindow) {
								            var msg = {
								                cmd: PRESS_REQUEST_CMD,
								                keyCombinations: this.keyCombinations,
								                options: this.options
								            };

								            return (0, _testcafeCore.sendRequestToFrame)(msg, PRESS_RESPONSE_CMD, activeElement.contentWindow);
								        }

								        return _testcafeCore.promiseUtils.each(this.keyCombinations, function (combination) {
								            return _this3._runCombination(combination).then(function () {
								                return (0, _testcafeCore.delay)(_this3.automationSettings.keyActionStepDelay);
								            });
								        });
								    };

								    return PressAutomation;
								}();

								exports.default = PressAutomation;
								module.exports = exports['default'];
							},
							"key-press-simulator.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _typeText = require('../type/type-text');

								var _typeText2 = _interopRequireDefault(_typeText);

								var _utils = require('./utils');

								var _getKeyCode = require('../../utils/get-key-code');

								var _getKeyCode2 = _interopRequireDefault(_getKeyCode);

								var _getKeyIdentifier = require('../../utils/get-key-identifier');

								var _getKeyIdentifier2 = _interopRequireDefault(_getKeyIdentifier);

								var _isLetter = require('../../utils/is-letter');

								var _isLetter2 = _interopRequireDefault(_isLetter);

								var _keyIdentifierRequiredForEvent = require('../../utils/key-identifier-required-for-event');

								var _keyIdentifierRequiredForEvent2 = _interopRequireDefault(_keyIdentifierRequiredForEvent);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								var browserUtils = _hammerhead2.default.utils.browser;
								var extend = _hammerhead2.default.utils.extend;
								var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;

								var KeyPressSimulator = function () {
								    function KeyPressSimulator(key, eventKeyProperty) {
								        _classCallCheck(this, KeyPressSimulator);

								        this.isLetter = (0, _isLetter2.default)(key);
								        this.isChar = key.length === 1 || key === 'space';
								        this.sanitizedKey = (0, _testcafeCore.getSanitizedKey)(key);
								        this.modifierKeyCode = _testcafeCore.KEY_MAPS.modifiers[this.sanitizedKey];
								        this.specialKeyCode = _testcafeCore.KEY_MAPS.specialKeys[this.sanitizedKey];
								        this.keyCode = null;
								        this.keyIdentifierProperty = (0, _getKeyIdentifier2.default)(eventKeyProperty);
								        this.topSameDomainDocument = _testcafeCore.domUtils.getTopSameDomainWindow(window).document;
								        this.keyProperty = _testcafeCore.KEY_MAPS.keyProperty[eventKeyProperty] || eventKeyProperty;

								        if (this.isChar && key !== 'space') this.keyCode = (0, _getKeyCode2.default)(this.sanitizedKey);else if (this.modifierKeyCode) this.keyCode = this.modifierKeyCode;else if (this.specialKeyCode) this.keyCode = this.specialKeyCode;

								        this.storedActiveElement = null;
								    }

								    KeyPressSimulator._isKeyActivatedInputElement = function _isKeyActivatedInputElement(el) {
								        return _testcafeCore.domUtils.isInputElement(el) && /button|submit|reset|radio|checkbox/.test(el.type);
								    };

								    KeyPressSimulator.prototype._type = function _type(element, char) {
								        var elementChanged = element !== this.storedActiveElement;
								        var shouldType = !elementChanged;
								        var elementForTyping = element;
								        var isActiveElementEditable = _testcafeCore.domUtils.isEditableElement(element);
								        var isStoredElementEditable = _testcafeCore.domUtils.isEditableElement(this.storedActiveElement);

								        // Unnecessary typing happens if an element was changed after the keydown/keypress event (T210448)
								        // In IE, this error may occur when we try to determine if the removed element is in an iframe
								        try {
								            if (elementChanged) {
								                var isActiveElementInIframe = _testcafeCore.domUtils.isElementInIframe(element);
								                var isStoredElementInIframe = _testcafeCore.domUtils.isElementInIframe(this.storedActiveElement);

								                var shouldTypeInWebKit = isActiveElementInIframe === isStoredElementInIframe || isStoredElementEditable;

								                shouldType = (!browserUtils.isFirefox || isStoredElementEditable) && (!browserUtils.isWebKit || shouldTypeInWebKit);
								            }
								        }
								        /*eslint-disable no-empty */
								        catch (err) {}
								        /*eslint-disable no-empty */

								        if (shouldType) {
								            if (!browserUtils.isIE && elementChanged && isStoredElementEditable && isActiveElementEditable) elementForTyping = this.storedActiveElement;

								            (0, _typeText2.default)(elementForTyping, char);
								        }
								    };

								    KeyPressSimulator.prototype._addKeyPropertyToEventOptions = function _addKeyPropertyToEventOptions(eventOptions) {
								        if ((0, _keyIdentifierRequiredForEvent2.default)()) eventOptions.keyIdentifier = eventOptions.type === 'keypress' ? '' : this.keyIdentifierProperty;else eventOptions.key = this.keyProperty;

								        return eventOptions;
								    };

								    KeyPressSimulator.prototype.down = function down(modifiersState) {
								        this.storedActiveElement = (0, _utils.getDeepActiveElement)(this.topSameDomainDocument);

								        if (this.modifierKeyCode) modifiersState[this.sanitizedKey] = true;

								        if (modifiersState.shift && this.isLetter) this.keyProperty = (0, _utils.changeLetterCase)(this.keyProperty);

								        var eventOptions = { keyCode: this.keyCode, type: 'keydown' };

								        this._addKeyPropertyToEventOptions(eventOptions);

								        return eventSimulator.keydown(this.storedActiveElement, extend(eventOptions, modifiersState));
								    };

								    KeyPressSimulator.prototype.press = function press(modifiersState) {
								        if (!(this.isChar || this.specialKeyCode)) return true;

								        var activeElement = (0, _utils.getDeepActiveElement)(this.topSameDomainDocument);

								        var character = this.isChar ? (0, _utils.getChar)(this.sanitizedKey, modifiersState.shift) : null;
								        var charCode = this.specialKeyCode || character.charCodeAt(0);
								        var elementChanged = activeElement !== this.storedActiveElement;

								        if (browserUtils.isWebKit && elementChanged) {
								            var isActiveElementInIframe = _testcafeCore.domUtils.isElementInIframe(activeElement);
								            var isStoredElementInIframe = _testcafeCore.domUtils.isElementInIframe(this.storedActiveElement);

								            if (isActiveElementInIframe !== isStoredElementInIframe) return true;
								        }

								        this.storedActiveElement = activeElement;

								        var eventOptions = { keyCode: charCode, charCode: charCode, type: 'keypress' };

								        this._addKeyPropertyToEventOptions(eventOptions, true);

								        var raiseDefault = eventSimulator.keypress(activeElement, extend(eventOptions, modifiersState));

								        if (!raiseDefault) return raiseDefault;

								        activeElement = (0, _utils.getDeepActiveElement)(this.topSameDomainDocument);

								        if (character && !(modifiersState.ctrl || modifiersState.alt)) this._type(activeElement, character);

								        var isKeyActivatedInput = KeyPressSimulator._isKeyActivatedInputElement(activeElement);
								        var isButton = _testcafeCore.domUtils.isButtonElement(activeElement);

								        var isSafariWithAutoRaisedClick = browserUtils.isSafari && browserUtils.compareVersions([browserUtils.webkitVersion, '603.1.30']) >= 0;

								        var raiseClickOnEnter = !browserUtils.isFirefox && !isSafariWithAutoRaisedClick && (isKeyActivatedInput || isButton);

								        if (raiseClickOnEnter && this.sanitizedKey === 'enter') activeElement.click();

								        return raiseDefault;
								    };

								    KeyPressSimulator.prototype.up = function up(modifiersState) {
								        if (this.modifierKeyCode) modifiersState[this.sanitizedKey] = false;

								        var eventOptions = { keyCode: this.keyCode, type: 'keyup' };

								        this._addKeyPropertyToEventOptions(eventOptions);

								        var raiseDefault = eventSimulator.keyup((0, _utils.getDeepActiveElement)(this.topSameDomainDocument), extend(eventOptions, modifiersState));
								        var activeElement = (0, _utils.getDeepActiveElement)(this.topSameDomainDocument);

								        // NOTE: in some browsers we should emulate click on active input element while pressing "space" key
								        var emulateClick = !browserUtils.isFirefox && !browserUtils.isSafari && (!browserUtils.isChrome || browserUtils.version >= 53);

								        if (emulateClick && raiseDefault && this.sanitizedKey === 'space' && KeyPressSimulator._isKeyActivatedInputElement(activeElement)) activeElement.click();

								        return raiseDefault;
								    };

								    _createClass(KeyPressSimulator, [{
								        key: 'key',
								        get: function get() {
								            return this.sanitizedKey;
								        }
								    }]);

								    return KeyPressSimulator;
								}();

								exports.default = KeyPressSimulator;
								module.exports = exports['default'];
							},
							"shortcuts.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _testcafeUi = require('../../deps/testcafe-ui');

								var _testcafeUi2 = _interopRequireDefault(_testcafeUi);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								var Promise = _hammerhead2.default.Promise;
								var browserUtils = _hammerhead2.default.utils.browser;
								var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;
								var focusBlurSandbox = _hammerhead2.default.eventSandbox.focusBlur;
								var elementEditingWatcher = _hammerhead2.default.eventSandbox.elementEditingWatcher;

								var textSelection = _testcafeCore2.default.textSelection;
								var eventUtils = _testcafeCore2.default.eventUtils;
								var domUtils = _testcafeCore2.default.domUtils;
								var selectElement = _testcafeUi2.default.selectElement;

								var currentTextarea = null;
								var currentTextareaCursorIndent = null;

								function onTextAreaBlur() {
								    currentTextarea = null;
								    currentTextareaCursorIndent = null;

								    eventUtils.unbind(this, 'blur', onTextAreaBlur, true);
								}

								function updateTextAreaIndent(element) {
								    if (domUtils.isTextAreaElement(element)) {
								        if (currentTextarea !== element) {
								            eventUtils.bind(element, 'blur', onTextAreaBlur, true);
								            currentTextarea = element;
								        }

								        currentTextareaCursorIndent = getLineIndentInTextarea(element);
								    }
								}

								function getLineIndentInTextarea(textarea) {
								    var inverseSelection = textSelection.hasInverseSelection(textarea);
								    var textareaValue = domUtils.getTextAreaValue(textarea);

								    var cursorPosition = inverseSelection ? textSelection.getSelectionStart(textarea) : textSelection.getSelectionEnd(textarea);

								    if (!textareaValue || !cursorPosition) return 0;

								    return domUtils.getTextareaIndentInLine(textarea, cursorPosition);
								}

								function moveTextAreaCursorUp(element, withSelection) {
								    var textareaValue = domUtils.getTextAreaValue(element);

								    if (!textareaValue) return;

								    var startPos = textSelection.getSelectionStart(element);
								    var endPos = textSelection.getSelectionEnd(element);
								    var hasInverseSelection = textSelection.hasInverseSelection(element);
								    var partBeforeCursor = textareaValue.substring(0, hasInverseSelection ? startPos : endPos);
								    var lastLineBreakIndex = partBeforeCursor.lastIndexOf('\n');
								    var partBeforeLastLineBreak = partBeforeCursor.substring(0, lastLineBreakIndex);

								    if (currentTextareaCursorIndent === null || currentTextarea !== element) updateTextAreaIndent(element);

								    lastLineBreakIndex = partBeforeLastLineBreak.lastIndexOf('\n');
								    var newPosition = Math.min(lastLineBreakIndex + 1 + currentTextareaCursorIndent, partBeforeLastLineBreak.length);

								    moveTextAreaCursor(element, startPos, endPos, hasInverseSelection, newPosition, withSelection);
								}

								function moveTextAreaCursorDown(element, withSelection) {
								    var textareaValue = domUtils.getTextAreaValue(element);

								    if (!textareaValue) return;

								    var startPos = textSelection.getSelectionStart(element);
								    var endPos = textSelection.getSelectionEnd(element);
								    var hasInverseSelection = textSelection.hasInverseSelection(element);
								    var cursorPosition = hasInverseSelection ? startPos : endPos;
								    var partAfterCursor = textareaValue.substring(cursorPosition);
								    var firstLineBreakIndex = partAfterCursor.indexOf('\n');
								    var nextLineStartIndex = firstLineBreakIndex === -1 ? partAfterCursor.length : firstLineBreakIndex + 1;
								    var partAfterNewIndent = partAfterCursor.substring(nextLineStartIndex);
								    var newPosition = cursorPosition + nextLineStartIndex;

								    firstLineBreakIndex = partAfterNewIndent.indexOf('\n');
								    var maxIndent = firstLineBreakIndex === -1 ? partAfterNewIndent.length : firstLineBreakIndex;

								    if (currentTextareaCursorIndent === null || currentTextarea !== element) updateTextAreaIndent(element);

								    newPosition = Math.min(newPosition + currentTextareaCursorIndent, newPosition + maxIndent);

								    moveTextAreaCursor(element, startPos, endPos, hasInverseSelection, newPosition, withSelection);
								}

								function moveTextAreaCursor(element, startPos, endPos, hasInverseSelection, newPosition, withSelection) {
								    var newStart = null;
								    var newEnd = null;

								    if (withSelection) {
								        if (startPos === endPos) {
								            newStart = startPos;
								            newEnd = newPosition;
								        } else if (!hasInverseSelection) {
								            newStart = startPos;
								            newEnd = newPosition;
								        } else {
								            newStart = endPos;
								            newEnd = newPosition;
								        }
								    } else newEnd = newStart = newPosition;

								    textSelection.select(element, newStart, newEnd);
								}

								function setElementValue(element, value, position) {
								    if (domUtils.isInputElement(element) && element.type === 'number') {
								        if (value.charAt(0) === '-' && value.charAt(1) === '.') value = value.substring(1);

								        if (value.charAt(value.length - 1) === '.') value = value.substring(0, value.length - 1);
								    }

								    domUtils.setElementValue(element, value);

								    textSelection.select(element, position, position);
								    eventSimulator.input(element);
								}

								function submitFormOnEnterPressInInput(form, inputElement) {
								    var buttons = form.querySelectorAll('input, button');
								    var submitButton = null;
								    var i = null;

								    for (i = 0; i < buttons.length; i++) {
								        if (!submitButton && buttons[i].type === 'submit' && !buttons[i].disabled) {
								            submitButton = buttons[i];
								            break;
								        }
								    }

								    if (submitButton) eventSimulator.click(submitButton);else if (domUtils.blocksImplicitSubmission(inputElement)) {
								        var formInputs = form.getElementsByTagName('input');
								        var textInputs = [];

								        for (i = 0; i < formInputs.length; i++) {
								            if (domUtils.blocksImplicitSubmission(formInputs[i])) textInputs.push(formInputs[i]);
								        }

								        // NOTE: the form is submitted on enter press if there is only one input of the following types on it
								        //  and this input is focused (http://www.w3.org/TR/html5/forms.html#implicit-submission)
								        if (textInputs.length === 1 && textInputs[0] === inputElement) {
								            var isInputValid = inputElement.validity.valid;

								            if (isInputValid && eventSimulator.submit(form)) form.submit();
								        }
								    }
								}

								//shortcuts
								function selectAll(element) {
								    if (domUtils.isEditableElement(element)) textSelection.select(element);

								    return Promise.resolve();
								}

								function backspace(element) {
								    if (domUtils.isTextEditableElementAndEditingAllowed(element)) {
								        var startPos = textSelection.getSelectionStart(element);
								        var endPos = textSelection.getSelectionEnd(element);
								        var value = domUtils.getElementValue(element).replace(/\r\n/g, '\n');

								        if (endPos === startPos) {
								            if (startPos > 0) {
								                setElementValue(element, value.substring(0, startPos - 1) + value.substring(endPos, value.length), startPos - 1);
								            }
								        } else setElementValue(element, value.substring(0, startPos) + value.substring(endPos, value.length), startPos);
								    }

								    if (domUtils.isContentEditableElement(element)) textSelection.deleteSelectionContents(element);

								    return Promise.resolve();
								}

								function del(element) {
								    if (domUtils.isTextEditableElementAndEditingAllowed(element)) {
								        var startPos = textSelection.getSelectionStart(element);
								        var endPos = textSelection.getSelectionEnd(element);
								        var value = domUtils.getElementValue(element).replace(/\r\n/g, '\n');

								        if (endPos === startPos) {
								            if (startPos < value.length) {
								                setElementValue(element, value.substring(0, startPos) + value.substring(endPos + 1, value.length), startPos);
								            }
								        } else {
								            setElementValue(element, value.substring(0, startPos) + value.substring(endPos, value.length), startPos);
								        }
								    }

								    if (domUtils.isContentEditableElement(element)) textSelection.deleteSelectionContents(element);

								    return Promise.resolve();
								}

								function left(element) {
								    var startPosition = null;
								    var endPosition = null;

								    if (domUtils.isSelectElement(element)) selectElement.switchOptionsByKeys(element, 'left');

								    if (domUtils.isTextEditableElement(element)) {
								        startPosition = textSelection.getSelectionStart(element) || 0;
								        endPosition = textSelection.getSelectionEnd(element);

								        var newPosition = startPosition === endPosition ? startPosition - 1 : startPosition;

								        textSelection.select(element, newPosition, newPosition);
								        updateTextAreaIndent(element);
								    }

								    if (domUtils.isContentEditableElement(element)) {
								        startPosition = textSelection.getSelectionStart(element);
								        endPosition = textSelection.getSelectionEnd(element);

								        // NOTE: we only remove selection
								        if (startPosition !== endPosition) {
								            var selection = textSelection.getSelectionByElement(element);
								            var inverseSelection = textSelection.hasInverseSelectionContentEditable(element);
								            var startNode = inverseSelection ? selection.focusNode : selection.anchorNode;
								            var startOffset = inverseSelection ? selection.focusOffset : selection.anchorOffset;
								            var startPos = { node: startNode, offset: startOffset };

								            textSelection.selectByNodesAndOffsets(startPos, startPos, true);
								        }
								    }

								    return Promise.resolve();
								}

								function right(element) {
								    var startPosition = null;
								    var endPosition = null;

								    if (domUtils.isSelectElement(element)) selectElement.switchOptionsByKeys(element, 'right');

								    if (domUtils.isTextEditableElement(element)) {
								        startPosition = textSelection.getSelectionStart(element);
								        endPosition = textSelection.getSelectionEnd(element);

								        var newPosition = startPosition === endPosition ? endPosition + 1 : endPosition;

								        if (startPosition === domUtils.getElementValue(element).length) newPosition = startPosition;

								        textSelection.select(element, newPosition, newPosition);
								        updateTextAreaIndent(element);
								    }

								    if (domUtils.isContentEditableElement(element)) {
								        startPosition = textSelection.getSelectionStart(element);
								        endPosition = textSelection.getSelectionEnd(element);

								        //NOTE: we only remove selection
								        if (startPosition !== endPosition) {
								            var selection = textSelection.getSelectionByElement(element);
								            var inverseSelection = textSelection.hasInverseSelectionContentEditable(element);
								            var endNode = inverseSelection ? selection.anchorNode : selection.focusNode;
								            var endOffset = inverseSelection ? selection.anchorOffset : selection.focusOffset;
								            var startPos = { node: endNode, offset: endOffset };

								            textSelection.selectByNodesAndOffsets(startPos, startPos, true);
								        }
								    }

								    return Promise.resolve();
								}

								function up(element) {
								    if (domUtils.isSelectElement(element)) selectElement.switchOptionsByKeys(element, 'up');

								    if (browserUtils.isWebKit && domUtils.isInputElement(element)) return home(element);

								    if (domUtils.isTextAreaElement(element)) moveTextAreaCursorUp(element, false);

								    return Promise.resolve();
								}

								function down(element) {
								    if (domUtils.isSelectElement(element)) selectElement.switchOptionsByKeys(element, 'down');

								    if (browserUtils.isWebKit && domUtils.isInputElement(element)) return end(element);

								    if (domUtils.isTextAreaElement(element)) moveTextAreaCursorDown(element, false);

								    return Promise.resolve();
								}

								function home(element, withSelection) {
								    if (domUtils.isTextEditableElement(element)) {
								        var startPos = textSelection.getSelectionStart(element);
								        var endPos = textSelection.getSelectionEnd(element);
								        var inverseSelection = textSelection.hasInverseSelection(element);
								        var referencePosition = null;

								        var isSingleLineSelection = !domUtils.isTextAreaElement(element) ? true : domUtils.getTextareaLineNumberByPosition(element, startPos) === domUtils.getTextareaLineNumberByPosition(element, endPos);

								        if (isSingleLineSelection) referencePosition = inverseSelection ? endPos : startPos;else referencePosition = inverseSelection ? startPos : endPos;

								        var valueBeforeCursor = domUtils.getElementValue(element).substring(0, referencePosition);
								        var lastLineBreakIndex = valueBeforeCursor.lastIndexOf('\n');
								        var newPosition = lastLineBreakIndex === -1 ? 0 : lastLineBreakIndex + 1;
								        var newStartPos = null;
								        var newEndPos = null;

								        if (isSingleLineSelection) {
								            newStartPos = newPosition;
								            newEndPos = withSelection ? referencePosition : newPosition;

								            textSelection.select(element, newEndPos, newStartPos);
								        } else if (!inverseSelection) textSelection.select(element, startPos, newPosition);else textSelection.select(element, endPos, newPosition);
								    }

								    return Promise.resolve();
								}

								function end(element, withSelection) {
								    if (domUtils.isTextEditableElement(element)) {
								        var startPos = textSelection.getSelectionStart(element);
								        var endPos = textSelection.getSelectionEnd(element);
								        var inverseSelection = textSelection.hasInverseSelection(element);
								        var referencePosition = null;

								        var isSingleLineSelection = !domUtils.isTextAreaElement(element) ? true : domUtils.getTextareaLineNumberByPosition(element, startPos) === domUtils.getTextareaLineNumberByPosition(element, endPos);

								        if (isSingleLineSelection) referencePosition = inverseSelection ? endPos : startPos;else referencePosition = inverseSelection ? startPos : endPos;

								        var valueAsterCursor = domUtils.getElementValue(element).substring(referencePosition);
								        var firstLineBreakIndex = valueAsterCursor.indexOf('\n');
								        var newPosition = referencePosition;
								        var newStartPos = null;
								        var newEndPos = null;

								        newPosition += firstLineBreakIndex === -1 ? valueAsterCursor.length : firstLineBreakIndex;

								        if (isSingleLineSelection) {
								            newStartPos = withSelection ? referencePosition : newPosition;
								            newEndPos = newPosition;

								            textSelection.select(element, newStartPos, newEndPos);
								        } else if (!inverseSelection) textSelection.select(element, startPos, newPosition);else textSelection.select(element, endPos, newPosition);
								    }

								    return Promise.resolve();
								}

								function esc(element) {
								    if (domUtils.isSelectElement(element)) selectElement.collapseOptionList();

								    return Promise.resolve();
								}

								function shiftUp(element) {
								    if (browserUtils.isWebKit && domUtils.isInputElement(element)) return shiftHome(element);

								    if (domUtils.isTextAreaElement(element)) moveTextAreaCursorUp(element, true);

								    return Promise.resolve();
								}

								function shiftDown(element) {
								    if (browserUtils.isWebKit && domUtils.isInputElement(element)) return shiftEnd(element);

								    if (domUtils.isTextAreaElement(element)) moveTextAreaCursorDown(element, true);

								    return Promise.resolve();
								}

								function shiftLeft(element) {
								    if (domUtils.isTextEditableElement(element)) {
								        var startPos = textSelection.getSelectionStart(element);
								        var endPos = textSelection.getSelectionEnd(element);

								        if (startPos === endPos || textSelection.hasInverseSelection(element)) textSelection.select(element, endPos, Math.max(startPos - 1, 0));else textSelection.select(element, startPos, Math.max(endPos - 1, 0));

								        updateTextAreaIndent(element);
								    }

								    return Promise.resolve();
								}

								function shiftRight(element) {
								    if (domUtils.isTextEditableElement(element)) {
								        var startPos = textSelection.getSelectionStart(element);
								        var endPos = textSelection.getSelectionEnd(element);
								        var valueLength = domUtils.getElementValue(element).length;

								        if (startPos === endPos || !textSelection.hasInverseSelection(element)) textSelection.select(element, startPos, Math.min(endPos + 1, valueLength));else textSelection.select(element, endPos, Math.min(startPos + 1, valueLength));

								        updateTextAreaIndent(element);
								    }

								    return Promise.resolve();
								}

								function shiftHome(element) {
								    return home(element, true);
								}

								function shiftEnd(element) {
								    return end(element, true);
								}

								function enter(element) {
								    if (domUtils.isSelectElement(element)) selectElement.collapseOptionList();

								    //submit form on enter pressed
								    if (domUtils.isInputElement(element)) {
								        if (!browserUtils.isIE) elementEditingWatcher.processElementChanging(element);

								        var form = domUtils.getParents(element, 'form')[0];

								        // NOTE: if a user presses enter when a form input is focused and the form has
								        // a submit button, the browser sends the click event to the submit button
								        if (form) submitFormOnEnterPressInInput(form, element);
								    } else if (domUtils.isTextAreaElement(element)) {
								        var startPos = textSelection.getSelectionStart(element);
								        var value = domUtils.getTextAreaValue(element);
								        var valueBeforeCursor = value.substring(0, startPos);
								        var valueAfterCursor = value.substring(startPos);
								        var newPosition = startPos + 1;

								        setElementValue(element, valueBeforeCursor + String.fromCharCode(10) + valueAfterCursor, newPosition);
								    }
								    //S173120
								    else if (element.tagName && domUtils.isAnchorElement(element)) eventSimulator.click(element);

								    return Promise.resolve();
								}

								function focusNextElement(element) {
								    return new Promise(function (resolve) {
								        if (domUtils.isSelectElement(element)) {
								            selectElement.collapseOptionList();
								            resolve();
								        }

								        var nextElement = domUtils.getNextFocusableElement(element);

								        if (!nextElement) resolve();

								        focusBlurSandbox.focus(nextElement, function () {
								            if (domUtils.isTextEditableInput(nextElement)) textSelection.select(nextElement);

								            resolve();
								        });
								    });
								}

								function focusPrevElement(element) {
								    return new Promise(function (resolve) {
								        if (domUtils.isSelectElement(element)) {
								            selectElement.collapseOptionList();
								            resolve();
								        }

								        var prevElement = domUtils.getNextFocusableElement(element, true);

								        if (!prevElement) resolve();

								        focusBlurSandbox.focus(prevElement, function () {
								            if (domUtils.isTextEditableInput(prevElement)) textSelection.select(prevElement);

								            resolve();
								        });
								    });
								}

								exports.default = {
								    'ctrl+a': selectAll,
								    'backspace': backspace,
								    'delete': del,
								    'left': left,
								    'right': right,
								    'up': up,
								    'down': down,
								    'shift+left': shiftLeft,
								    'shift+right': shiftRight,
								    'shift+up': shiftUp,
								    'shift+down': shiftDown,
								    'shift+home': shiftHome,
								    'shift+end': shiftEnd,
								    'home': home,
								    'end': end,
								    'enter': enter,
								    'tab': focusNextElement,
								    'shift+tab': focusPrevElement,
								    'esc': esc
								};
								module.exports = exports['default'];
							},
							"utils.js": function (exports, module, require) {
								

								exports.__esModule = true;
								exports.changeLetterCase = changeLetterCase;
								exports.getActualKeysAndEventKeyProperties = getActualKeysAndEventKeyProperties;
								exports.getChar = getChar;
								exports.getDeepActiveElement = getDeepActiveElement;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _isLetter = require('../../utils/is-letter');

								var _isLetter2 = _interopRequireDefault(_isLetter);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								var nativeMethods = _hammerhead2.default.nativeMethods;

								function changeLetterCase(letter) {
								    var isLowCase = letter === letter.toLowerCase();

								    return isLowCase ? letter.toUpperCase() : letter.toLowerCase();
								}

								function getActualKeysAndEventKeyProperties(keyArray) {
								    var eventKeyProperties = keyArray.slice();

								    //NOTE: check 'shift' modifier in keys
								    for (var i = 0; i < keyArray.length; i++) {
								        var key = keyArray[i];

								        if (key.toLowerCase() === 'shift') {
								            var nextKey = keyArray[i + 1];

								            if (!nextKey) continue;

								            if (_testcafeCore.KEY_MAPS.shiftMap[nextKey]) keyArray[i + 1] = _testcafeCore.KEY_MAPS.shiftMap[nextKey];else if (_testcafeCore.KEY_MAPS.reversedShiftMap[nextKey]) eventKeyProperties[i + 1] = _testcafeCore.KEY_MAPS.reversedShiftMap[nextKey];
								        }

								        if (_testcafeCore.KEY_MAPS.shiftMap[key] && (!keyArray[i - 1] || keyArray[i - 1].toLowerCase() !== 'shift')) {
								            keyArray[i] = _testcafeCore.KEY_MAPS.shiftMap[key];
								            keyArray.splice(i, 0, 'shift');
								            eventKeyProperties.splice(i, 0, 'shift');
								            i++;
								        }
								    }

								    return { actualKeys: keyArray, eventKeyProperties: eventKeyProperties };
								}

								function getChar(key, shiftModified) {
								    if (key === 'space') return ' ';

								    if (shiftModified) {
								        if ((0, _isLetter2.default)(key)) return changeLetterCase(key);

								        if (_testcafeCore.KEY_MAPS.reversedShiftMap[key]) return _testcafeCore.KEY_MAPS.reversedShiftMap[key];
								    }

								    return key;
								}

								function getDeepActiveElement(currentDocument) {
								    var doc = currentDocument || document;
								    var activeElementInIframe = null;
								    var activeElement = nativeMethods.documentActiveElementGetter.call(doc);

								    if (!activeElement || !_testcafeCore.domUtils.isDomElement(activeElement)) activeElement = doc.body;

								    if (activeElement && _testcafeCore.domUtils.isIframeElement(activeElement) && activeElement.contentDocument) {
								        try {
								            activeElementInIframe = getDeepActiveElement(activeElement.contentDocument);
								        }
								        /*eslint-disable no-empty */
								        catch (e) {}
								        /*eslint-enable no-empty */
								    }

								    return activeElementInIframe || activeElement;
								}
							}
						},
						"rclick.js": function (exports, module, require) {
							

							exports.__esModule = true;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _testcafeCore = require('../deps/testcafe-core');

							var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

							var _visibleElementAutomation = require('./visible-element-automation');

							var _visibleElementAutomation2 = _interopRequireDefault(_visibleElementAutomation);

							var _utils = require('../utils/utils');

							var _cursor = require('../cursor');

							var _cursor2 = _interopRequireDefault(_cursor);

							var _nextTick = require('../utils/next-tick');

							var _nextTick2 = _interopRequireDefault(_nextTick);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

							function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

							function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

							var Promise = _hammerhead2.default.Promise;

							var extend = _hammerhead2.default.utils.extend;
							var browserUtils = _hammerhead2.default.utils.browser;
							var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;

							var domUtils = _testcafeCore2.default.domUtils;
							var eventUtils = _testcafeCore2.default.eventUtils;
							var delay = _testcafeCore2.default.delay;

							var RClickAutomation = function (_VisibleElementAutoma) {
							    _inherits(RClickAutomation, _VisibleElementAutoma);

							    function RClickAutomation(element, clickOptions) {
							        _classCallCheck(this, RClickAutomation);

							        var _this = _possibleConstructorReturn(this, _VisibleElementAutoma.call(this, element, clickOptions));

							        _this.modifiers = clickOptions.modifiers;
							        _this.caretPos = clickOptions.caretPos;

							        _this.eventState = {
							            simulateDefaultBehavior: true,
							            activeElementBeforeMouseDown: null
							        };
							        return _this;
							    }

							    RClickAutomation.prototype._mousedown = function _mousedown(eventArgs) {
							        var _this2 = this;

							        return _cursor2.default.rightButtonDown().then(function () {
							            _this2.eventState.activeElementBeforeMouseDown = domUtils.getActiveElement();
							            _this2.eventState.simulateDefaultBehavior = eventSimulator.mousedown(eventArgs.element, eventArgs.options);
							        }).then(function () {
							            return _this2._focus(eventArgs);
							        });
							    };

							    RClickAutomation.prototype._focus = function _focus(eventArgs) {
							        if (this.simulateDefaultBehavior === false) return (0, _nextTick2.default)();

							        // NOTE: If a target element is a contentEditable element, we need to call focusAndSetSelection directly for
							        // this element. Otherwise, if the element obtained by elementFromPoint is a child of the contentEditable
							        // element, a selection position may be calculated incorrectly (by using the caretPos option).
							        var elementForFocus = domUtils.isContentEditableElement(this.element) ? this.element : eventArgs.element;

							        // NOTE: IE doesn't perform focus if active element has been changed while executing mousedown
							        var simulateFocus = !browserUtils.isIE || this.eventState.activeElementBeforeMouseDown === domUtils.getActiveElement();

							        return (0, _utils.focusAndSetSelection)(elementForFocus, simulateFocus, this.caretPos).then(function () {
							            return (0, _nextTick2.default)();
							        });
							    };

							    RClickAutomation.prototype._mouseup = function _mouseup(eventArgs) {
							        var _this3 = this;

							        return _cursor2.default.buttonUp().then(function () {
							            return _this3._getElementForEvent(eventArgs);
							        }).then(function (element) {
							            return eventSimulator.mouseup(element, eventArgs.options);
							        });
							    };

							    RClickAutomation.prototype._contextmenu = function _contextmenu(eventArgs) {
							        return this._getElementForEvent(eventArgs).then(function (element) {
							            eventSimulator.contextmenu(element, eventArgs.options);

							            if (!domUtils.isElementFocusable(element)) (0, _utils.focusByRelatedElement)(element);
							        });
							    };

							    RClickAutomation.prototype.run = function run(useStrictElementCheck) {
							        var _this4 = this;

							        var eventArgs = null;

							        return this._ensureElement(useStrictElementCheck).then(function (_ref) {
							            var element = _ref.element,
							                clientPoint = _ref.clientPoint,
							                devicePoint = _ref.devicePoint;

							            eventArgs = {
							                point: clientPoint,
							                element: element,
							                options: extend({
							                    clientX: clientPoint.x,
							                    clientY: clientPoint.y,
							                    screenX: devicePoint.x,
							                    screenY: devicePoint.y,
							                    button: eventUtils.BUTTON.right
							                }, _this4.modifiers)
							            };

							            // NOTE: we should raise mouseup event with 'mouseActionStepDelay' after we trigger
							            // mousedown event regardless of how long mousedown event handlers were executing
							            return Promise.all([delay(_this4.automationSettings.mouseActionStepDelay), _this4._mousedown(eventArgs)]);
							        }).then(function () {
							            return _this4._mouseup(eventArgs);
							        }).then(function () {
							            return _this4._contextmenu(eventArgs);
							        });
							    };

							    return RClickAutomation;
							}(_visibleElementAutomation2.default);

							exports.default = RClickAutomation;
							module.exports = exports['default'];
						},
						"scroll.js": function (exports, module, require) {
							

							exports.__esModule = true;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _testcafeCore = require('../deps/testcafe-core');

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

							var Promise = _hammerhead2.default.Promise;
							var messageSandbox = _hammerhead2.default.eventSandbox.message;

							var DEFAULT_MAX_SCROLL_MARGIN = 50;
							var SCROLL_MARGIN_INCREASE_STEP = 20;

							var SCROLL_REQUEST_CMD = 'automation|scroll|request';
							var SCROLL_RESPONSE_CMD = 'automation|scroll|response';

							// Setup cross-iframe interaction
							messageSandbox.on(messageSandbox.SERVICE_MSG_RECEIVED_EVENT, function (e) {
							    if (e.message.cmd === SCROLL_REQUEST_CMD) {
							        var element = _testcafeCore.domUtils.findIframeByWindow(e.source);
							        var offsetX = e.message.offsetX;
							        var offsetY = e.message.offsetY;
							        var maxScrollMargin = e.message.maxScrollMargin;

							        var scroll = new ScrollAutomation(element, { offsetX: offsetX, offsetY: offsetY });

							        scroll.maxScrollMargin = maxScrollMargin;

							        scroll.run().then(function () {
							            return messageSandbox.sendServiceMsg({ cmd: SCROLL_RESPONSE_CMD }, e.source);
							        });
							    }
							});

							var ScrollAutomation = function () {
							    function ScrollAutomation(element, scrollOptions) {
							        _classCallCheck(this, ScrollAutomation);

							        this.element = element;
							        this.offsetX = scrollOptions.offsetX;
							        this.offsetY = scrollOptions.offsetY;
							        this.scrollToCenter = scrollOptions.scrollToCenter;
							        this.skipParentFrames = scrollOptions.skipParentFrames;

							        this.maxScrollMargin = DEFAULT_MAX_SCROLL_MARGIN;
							    }

							    ScrollAutomation.prototype._isScrollValuesChanged = function _isScrollValuesChanged(scrollElement, originalScroll) {
							        return _testcafeCore.styleUtils.getScrollLeft(scrollElement) !== originalScroll.left || _testcafeCore.styleUtils.getScrollTop(scrollElement) !== originalScroll.top;
							    };

							    ScrollAutomation.prototype._setScroll = function _setScroll(element, _ref) {
							        var left = _ref.left,
							            top = _ref.top;

							        var scrollElement = _testcafeCore.domUtils.isHtmlElement(element) ? _testcafeCore.domUtils.findDocument(element) : element;

							        var originalScroll = {
							            left: _testcafeCore.styleUtils.getScrollLeft(scrollElement),
							            top: _testcafeCore.styleUtils.getScrollTop(scrollElement)
							        };

							        left = Math.max(left, 0);
							        top = Math.max(top, 0);

							        var scrollPromise = _testcafeCore.scrollController.waitForScroll();

							        _testcafeCore.styleUtils.setScrollLeft(scrollElement, left);
							        _testcafeCore.styleUtils.setScrollTop(scrollElement, top);

							        if (!this._isScrollValuesChanged(scrollElement, originalScroll)) {
							            scrollPromise.cancel();

							            return Promise.resolve();
							        }

							        return scrollPromise;
							    };

							    ScrollAutomation.prototype._getScrollToPoint = function _getScrollToPoint(elementDimensions, _ref2) {
							        var x = _ref2.x,
							            y = _ref2.y;

							        var horizontalCenter = Math.floor(elementDimensions.width / 2);
							        var verticalCenter = Math.floor(Math.floor(elementDimensions.height / 2));
							        var leftScrollMargin = this.scrollToCenter ? horizontalCenter : Math.min(this.maxScrollMargin, horizontalCenter);
							        var topScrollMargin = this.scrollToCenter ? verticalCenter : Math.min(this.maxScrollMargin, verticalCenter);

							        var needForwardScrollLeft = x >= elementDimensions.scroll.left + elementDimensions.width - leftScrollMargin;
							        var needBackwardScrollLeft = x <= elementDimensions.scroll.left + leftScrollMargin;

							        var needForwardScrollTop = y >= elementDimensions.scroll.top + elementDimensions.height - topScrollMargin;
							        var needBackwardScrollTop = y <= elementDimensions.scroll.top + topScrollMargin;

							        var left = elementDimensions.scroll.left;
							        var top = elementDimensions.scroll.top;

							        if (needForwardScrollLeft) left = x - elementDimensions.width + leftScrollMargin;else if (needBackwardScrollLeft) left = x - leftScrollMargin;

							        if (needForwardScrollTop) top = y - elementDimensions.height + topScrollMargin;else if (needBackwardScrollTop) top = y - topScrollMargin;

							        return { left: left, top: top };
							    };

							    ScrollAutomation.prototype._getScrollToFullChildView = function _getScrollToFullChildView(parentDimensions, childDimensions) {
							        var fullViewScrollLeft = null;
							        var fullViewScrollTop = null;

							        var canShowFullElementWidth = parentDimensions.width >= childDimensions.width;
							        var canShowFullElementHeight = parentDimensions.height >= childDimensions.height;

							        var relativePosition = _testcafeCore.positionUtils.calcRelativePosition(childDimensions, parentDimensions);

							        if (canShowFullElementWidth) {
							            var availableLeftScrollMargin = Math.floor((parentDimensions.width - childDimensions.width) / 2);
							            var leftScrollMargin = this.scrollToCenter ? availableLeftScrollMargin : Math.min(this.maxScrollMargin, availableLeftScrollMargin);

							            if (relativePosition.left < leftScrollMargin) {
							                fullViewScrollLeft = Math.round(parentDimensions.scroll.left + relativePosition.left - leftScrollMargin);
							            } else if (relativePosition.right < leftScrollMargin) {
							                fullViewScrollLeft = Math.round(parentDimensions.scroll.left + Math.min(relativePosition.left, -relativePosition.right) + leftScrollMargin);
							            }
							        }

							        if (canShowFullElementHeight) {
							            var availableTopScrollMargin = Math.floor((parentDimensions.height - childDimensions.height) / 2);
							            var topScrollMargin = this.scrollToCenter ? availableTopScrollMargin : Math.min(this.maxScrollMargin, availableTopScrollMargin);

							            if (relativePosition.top < topScrollMargin) fullViewScrollTop = Math.round(parentDimensions.scroll.top + relativePosition.top - topScrollMargin);else if (relativePosition.bottom < topScrollMargin) {
							                fullViewScrollTop = Math.round(parentDimensions.scroll.top + Math.min(relativePosition.top, -relativePosition.bottom) + topScrollMargin);
							            }
							        }

							        return {
							            left: fullViewScrollLeft,
							            top: fullViewScrollTop
							        };
							    };

							    ScrollAutomation.prototype._scrollToChild = function _scrollToChild(parent, child, _ref3) {
							        var offsetX = _ref3.offsetX,
							            offsetY = _ref3.offsetY;

							        var parentDimensions = _testcafeCore.positionUtils.getClientDimensions(parent);
							        var childDimensions = _testcafeCore.positionUtils.getClientDimensions(child);

							        var childPoint = {
							            x: childDimensions.left - parentDimensions.left + parentDimensions.scroll.left + childDimensions.border.left + offsetX,
							            y: childDimensions.top - parentDimensions.top + parentDimensions.scroll.top + childDimensions.border.top + offsetY
							        };

							        var scrollToFullView = this._getScrollToFullChildView(parentDimensions, childDimensions);
							        var scrollToPoint = this._getScrollToPoint(parentDimensions, childPoint);

							        var left = scrollToFullView.left === null ? scrollToPoint.left : scrollToFullView.left;
							        var top = scrollToFullView.top === null ? scrollToPoint.top : scrollToFullView.top;

							        return this._setScroll(parent, { left: left, top: top });
							    };

							    ScrollAutomation.prototype._scrollElement = function _scrollElement() {
							        if (!_testcafeCore.styleUtils.hasScroll(this.element)) return Promise.resolve();

							        var elementDimensions = _testcafeCore.positionUtils.getClientDimensions(this.element);
							        var scroll = this._getScrollToPoint(elementDimensions, {
							            x: this.offsetX,
							            y: this.offsetY
							        });

							        return this._setScroll(this.element, scroll);
							    };

							    ScrollAutomation.prototype._scrollParents = function _scrollParents() {
							        var _this = this;

							        var parents = _testcafeCore.styleUtils.getScrollableParents(this.element);

							        var currentChild = this.element;
							        var currentOffsetX = this.offsetX - Math.round(_testcafeCore.styleUtils.getScrollLeft(currentChild));
							        var currentOffsetY = this.offsetY - Math.round(_testcafeCore.styleUtils.getScrollTop(currentChild));

							        var childDimensions = null;
							        var parentDimensions = null;

							        var scrollParentsPromise = _testcafeCore.promiseUtils.times(parents.length, function (i) {
							            return _this._scrollToChild(parents[i], currentChild, {
							                offsetX: currentOffsetX,
							                offsetY: currentOffsetY
							            }).then(function () {
							                childDimensions = _testcafeCore.positionUtils.getClientDimensions(currentChild);
							                parentDimensions = _testcafeCore.positionUtils.getClientDimensions(parents[i]);

							                currentOffsetX += childDimensions.left - parentDimensions.left + parentDimensions.border.left;
							                currentOffsetY += childDimensions.top - parentDimensions.top + parentDimensions.border.top;

							                currentChild = parents[i];
							            });
							        });

							        return scrollParentsPromise.then(function () {
							            if (window.top !== window && !_this.skipParentFrames) {
							                return (0, _testcafeCore.sendRequestToFrame)({
							                    cmd: SCROLL_REQUEST_CMD,
							                    offsetX: currentOffsetX,
							                    offsetY: currentOffsetY,
							                    maxScrollMargin: _this.maxScrollMargin
							                }, SCROLL_RESPONSE_CMD, window.parent);
							            }

							            return Promise.resolve();
							        });
							    };

							    ScrollAutomation.prototype._isElementHiddenByFixed = function _isElementHiddenByFixed() {
							        var clientDimensions = _testcafeCore.positionUtils.getClientDimensions(this.element);
							        var elementInPoint = _testcafeCore.positionUtils.getElementFromPoint(clientDimensions.left + this.offsetX, clientDimensions.top + this.offsetY);

							        var el = elementInPoint;
							        var fixedElement = null;

							        while (el && !fixedElement) {
							            if (_testcafeCore.styleUtils.isFixedElement(el)) fixedElement = el;

							            el = el.parentNode;
							        }

							        return elementInPoint && fixedElement && !fixedElement.contains(this.element);
							    };

							    ScrollAutomation.prototype._isScrollMarginTooBig = function _isScrollMarginTooBig() {
							        var minWindowDimension = Math.min(_testcafeCore.styleUtils.getInnerWidth(window), _testcafeCore.styleUtils.getInnerHeight(window));

							        return this.maxScrollMargin >= minWindowDimension / 2;
							    };

							    ScrollAutomation.prototype.run = function run() {
							        var _this2 = this;

							        return this._scrollElement().then(function () {
							            return _this2._scrollParents();
							        }).then(function () {
							            return _testcafeCore.promiseUtils.whilst(function () {
							                return !_this2._isScrollMarginTooBig() && _this2._isElementHiddenByFixed();
							            }, function () {
							                _this2.maxScrollMargin += SCROLL_MARGIN_INCREASE_STEP;

							                return _this2._scrollParents();
							            });
							        });
							    };

							    return ScrollAutomation;
							}();

							exports.default = ScrollAutomation;
							module.exports = exports['default'];
						},
						"select": {
							"base.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _visibleElementAutomation = require('../visible-element-automation');

								var _visibleElementAutomation2 = _interopRequireDefault(_visibleElementAutomation);

								var _getElement = require('../../get-element');

								var _utils = require('./utils');

								var selectUtils = _interopRequireWildcard(_utils);

								var _move2 = require('../move');

								var _move3 = _interopRequireDefault(_move2);

								var _options = require('../../../../test-run/commands/options');

								var _cursor = require('../../cursor');

								var _cursor2 = _interopRequireDefault(_cursor);

								var _errors = require('../../errors');

								var _errors2 = _interopRequireDefault(_errors);

								function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

								function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

								var Promise = _hammerhead2.default.Promise;
								var browserUtils = _hammerhead2.default.utils.browser;
								var featureDetection = _hammerhead2.default.utils.featureDetection;
								var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;
								var focusBlurSandbox = _hammerhead2.default.eventSandbox.focusBlur;

								var contentEditable = _testcafeCore2.default.contentEditable;
								var domUtils = _testcafeCore2.default.domUtils;
								var positionUtils = _testcafeCore2.default.positionUtils;
								var eventUtils = _testcafeCore2.default.eventUtils;
								var delay = _testcafeCore2.default.delay;

								var SelectBaseAutomation = function (_VisibleElementAutoma) {
								    _inherits(SelectBaseAutomation, _VisibleElementAutoma);

								    function SelectBaseAutomation(element, actionOptions) {
								        _classCallCheck(this, SelectBaseAutomation);

								        var _this = _possibleConstructorReturn(this, _VisibleElementAutoma.call(this, element, actionOptions));

								        _this.absoluteStartPoint = null;
								        _this.absoluteEndPoint = null;
								        _this.clientPoint = null;

								        _this.speed = actionOptions.speed;

								        _this.downEvent = featureDetection.isTouchDevice ? 'touchstart' : 'mousedown';
								        _this.upEvent = featureDetection.isTouchDevice ? 'touchend' : 'mouseup';

								        _this.eventArgs = {
								            options: null,
								            element: null
								        };

								        _this.eventState = {
								            mousedownPrevented: false,
								            simulateDefaultBehavior: true
								        };
								        return _this;
								    }

								    SelectBaseAutomation._calculateEventArguments = function _calculateEventArguments(point) {
								        var clientPoint = positionUtils.offsetToClientCoords(point);

								        return (0, _getElement.fromPoint)(clientPoint.x, clientPoint.y).then(function (_ref) {
								            var element = _ref.element;

								            if (!element) throw new Error(_errors2.default.elementIsInvisibleError);

								            return {
								                element: element,
								                options: {
								                    clientX: clientPoint.x,
								                    clientY: clientPoint.y
								                }
								            };
								        });
								    };

								    SelectBaseAutomation.prototype._move = function _move(_ref2) {
								        var _this2 = this;

								        var element = _ref2.element,
								            offsetX = _ref2.offsetX,
								            offsetY = _ref2.offsetY,
								            speed = _ref2.speed;

								        var moveOptions = new _options.MoveOptions({ offsetX: offsetX, offsetY: offsetY, speed: speed }, false);
								        var moveAutomation = new _move3.default(element, moveOptions);

								        return moveAutomation.run().then(function () {
								            return delay(_this2.automationSettings.mouseActionStepDelay);
								        });
								    };

								    SelectBaseAutomation.prototype._bindMousedownHandler = function _bindMousedownHandler() {
								        var _this3 = this;

								        var onmousedown = function onmousedown(e) {
								            _this3.eventState.mousedownPrevented = e.defaultPrevented;
								            eventUtils.preventDefault(e);
								            eventUtils.unbind(_this3.element, 'mousedown', onmousedown);
								        };

								        eventUtils.bind(this.element, 'mousedown', onmousedown);
								    };

								    SelectBaseAutomation.prototype._calculateAbsoluteStartPoint = function _calculateAbsoluteStartPoint() {
								        throw new Error('Not implemented');
								    };

								    SelectBaseAutomation.prototype._calculateAbsoluteEndPoint = function _calculateAbsoluteEndPoint() {
								        throw new Error('Not implemented');
								    };

								    SelectBaseAutomation.prototype._moveToPoint = function _moveToPoint(point) {
								        selectUtils.scrollEditableElementByPoint(this.element, point);

								        this.clientPoint = selectUtils.excludeElementScroll(this.element, point);

								        var moveArguments = {
								            element: document.documentElement,
								            offsetX: this.clientPoint.x,
								            offsetY: this.clientPoint.y,
								            speed: this.speed
								        };

								        return this._move(moveArguments);
								    };

								    SelectBaseAutomation.prototype._mousedown = function _mousedown() {
								        var _this4 = this;

								        return _cursor2.default.leftButtonDown().then(function () {
								            return SelectBaseAutomation._calculateEventArguments(_this4.clientPoint);
								        }).then(function (args) {
								            _this4.eventArgs = args;

								            // NOTE: In WebKit and IE, the mousedown event opens the select element's dropdown;
								            // therefore, we should prevent mousedown and hide the dropdown (B236416).
								            var needCloseSelectDropDown = (browserUtils.isWebKit || browserUtils.isIE) && domUtils.isSelectElement(_this4.element);

								            if (needCloseSelectDropDown) _this4._bindMousedownHandler();

								            _this4.eventState.simulateDefaultBehavior = eventSimulator[_this4.downEvent](_this4.eventArgs.element, _this4.eventArgs.options);

								            if (_this4.eventState.simulateDefaultBehavior === false) _this4.eventState.simulateDefaultBehavior = needCloseSelectDropDown && !_this4.eventState.mousedownPrevented;

								            return _this4._focus();
								        });
								    };

								    SelectBaseAutomation.prototype._focus = function _focus() {
								        var _this5 = this;

								        return new Promise(function (resolve) {
								            // NOTE: If the target element is a child of a contentEditable element, we need to call focus for its parent
								            var elementForFocus = domUtils.isContentEditableElement(_this5.element) ? contentEditable.findContentEditableParent(_this5.element) : _this5.element;

								            focusBlurSandbox.focus(elementForFocus, resolve, false, true);
								        });
								    };

								    SelectBaseAutomation.prototype._setSelection = function _setSelection() {
								        throw new Error('Not implemented');
								    };

								    SelectBaseAutomation.prototype._mouseup = function _mouseup() {
								        var _this6 = this;

								        return _cursor2.default.buttonUp().then(function () {
								            _this6._setSelection();

								            return SelectBaseAutomation._calculateEventArguments(_this6.clientPoint);
								        }).then(function (args) {
								            _this6.eventArgs = args;

								            eventSimulator[_this6.upEvent](_this6.eventArgs.element, _this6.eventArgs.options);
								        });
								    };

								    SelectBaseAutomation.prototype.run = function run() {
								        var _this7 = this;

								        this.absoluteStartPoint = this._calculateAbsoluteStartPoint();
								        this.absoluteEndPoint = this._calculateAbsoluteEndPoint();

								        return this._moveToPoint(this.absoluteStartPoint).then(function () {
								            return _this7._mousedown();
								        }).then(function () {
								            return _this7._moveToPoint(_this7.absoluteEndPoint);
								        }).then(function () {
								            return _this7._mouseup();
								        });
								    };

								    return SelectBaseAutomation;
								}(_visibleElementAutomation2.default);

								exports.default = SelectBaseAutomation;
								module.exports = exports['default'];
							},
							"calculate-select-text-arguments.js": function (exports, module, require) {
								

								exports.__esModule = true;

								exports.default = function (element) {
								    var argumentsObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

								    var isTextEditable = domUtils.isTextEditableElement(element);
								    var firstPos = isTextEditable ? 0 : contentEditable.getFirstVisiblePosition(element);
								    var lastPos = isTextEditable ? domUtils.getElementValue(element).length : contentEditable.getLastVisiblePosition(element);
								    var startPos = !argumentsObject.startPos ? firstPos : Math.min(argumentsObject.startPos, lastPos);
								    var endPos = argumentsObject.endPos === void 0 || argumentsObject.endPos === null ? lastPos : Math.min(argumentsObject.endPos, lastPos);

								    if (argumentsObject.offset !== void 0) {
								        if (argumentsObject.offset >= 0) endPos = Math.min(argumentsObject.offset, endPos);else {
								            startPos = endPos;
								            endPos = Math.max(0, endPos + argumentsObject.offset);
								        }

								        return { startPos: startPos, endPos: endPos };
								    }

								    if (argumentsObject.startLine !== void 0) return getSelectTextAreaContentArguments(element, argumentsObject);

								    return { startPos: startPos, endPos: endPos };
								};

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								var domUtils = _testcafeCore2.default.domUtils;
								var contentEditable = _testcafeCore2.default.contentEditable;

								function getSelectTextAreaContentArguments(element, argumentsObject) {
								    var value = domUtils.getTextAreaValue(element);
								    var linesArray = value && value.length ? value.split('\n') : [];
								    var lastLineIndex = linesArray.length - 1;

								    var startLineIndex = !argumentsObject.startLine ? 0 : Math.min(argumentsObject.startLine, lastLineIndex);
								    var startLineLength = linesArray[startLineIndex] ? linesArray[startLineIndex].length : 0;
								    var startPos = !argumentsObject.startPos ? 0 : Math.min(argumentsObject.startPos, startLineLength);

								    var endLineIndex = argumentsObject.endLine === void 0 || argumentsObject.endLine === null ? lastLineIndex : Math.min(argumentsObject.endLine, lastLineIndex);

								    var endLineLength = linesArray[endLineIndex] ? linesArray[endLineIndex].length : 0;
								    var endPos = argumentsObject.endPos === void 0 || argumentsObject.endPos === null ? endLineLength : Math.min(argumentsObject.endPos, endLineLength);

								    var startLinePosition = domUtils.getTextareaPositionByLineAndOffset(element, startLineIndex, 0);
								    var endLinePosition = domUtils.getTextareaPositionByLineAndOffset(element, endLineIndex, 0);

								    return {
								        startPos: startLinePosition + startPos,
								        endPos: endLinePosition + endPos
								    };
								}

								module.exports = exports['default'];
							},
							"select-editable-content.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _utils = require('./utils');

								var selectUtils = _interopRequireWildcard(_utils);

								var _base = require('./base');

								var _base2 = _interopRequireDefault(_base);

								function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

								function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

								var textSelection = _testcafeCore2.default.textSelection;
								var contentEditable = _testcafeCore2.default.contentEditable;
								var positionUtils = _testcafeCore2.default.positionUtils;

								var SelectEditableContentAutomation = function (_SelectBaseAutomation) {
								    _inherits(SelectEditableContentAutomation, _SelectBaseAutomation);

								    function SelectEditableContentAutomation(startNode, endNode, actionOptions) {
								        _classCallCheck(this, SelectEditableContentAutomation);

								        var _this = _possibleConstructorReturn(this, _SelectBaseAutomation.call(this, contentEditable.getNearestCommonAncestor(startNode, endNode), actionOptions));

								        var startOffset = contentEditable.getFirstVisiblePosition(startNode);
								        var endOffset = contentEditable.getLastVisiblePosition(endNode);

								        var startPos = { node: startNode, offset: startOffset };
								        var endPos = { node: endNode, offset: endOffset };
								        var startPosition = contentEditable.calculatePositionByNodeAndOffset(_this.element, startPos);
								        var endPosition = contentEditable.calculatePositionByNodeAndOffset(_this.element, endPos);

								        if (startPosition > endPosition) {
								            startOffset = contentEditable.getLastVisiblePosition(startNode);
								            endOffset = contentEditable.getFirstVisiblePosition(endNode);
								        }

								        // NOTE: We should recalculate nodes and offsets for selection because we
								        // may have to select children of expectedStartNode and expectedEndNode
								        startPos = contentEditable.calculateNodeAndOffsetByPosition(startNode, startOffset);
								        endPos = contentEditable.calculateNodeAndOffsetByPosition(endNode, endOffset);

								        _this.startNode = startPos.node;
								        _this.startOffset = startPos.offset;
								        _this.endNode = endPos.node;
								        _this.endOffset = endPos.offset;
								        return _this;
								    }

								    SelectEditableContentAutomation.prototype._calculateAbsoluteStartPoint = function _calculateAbsoluteStartPoint() {
								        var point = selectUtils.getSelectionCoordinatesByNodeAndOffset(this.element, this.startNode, this.startOffset);

								        return point || positionUtils.findCenter(this.element);
								    };

								    SelectEditableContentAutomation.prototype._calculateAbsoluteEndPoint = function _calculateAbsoluteEndPoint() {
								        var point = selectUtils.getSelectionCoordinatesByNodeAndOffset(this.element, this.endNode, this.endOffset);

								        return point || positionUtils.findCenter(this.element);
								    };

								    SelectEditableContentAutomation.prototype._setSelection = function _setSelection() {
								        if (this.eventState.simulateDefaultBehavior === false) return;

								        // NOTE: The same cursor position may correspond to different nodes, so, if we
								        // know which nodes should be selected eventually, we should select them directly.
								        var startPos = { node: this.startNode, offset: this.startOffset };
								        var endPos = { node: this.endNode, offset: this.endOffset };

								        textSelection.selectByNodesAndOffsets(startPos, endPos, true);
								    };

								    return SelectEditableContentAutomation;
								}(_base2.default);

								exports.default = SelectEditableContentAutomation;
								module.exports = exports['default'];
							},
							"select-text.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _hammerhead = require('../../deps/hammerhead');

								var _base = require('./base');

								var _base2 = _interopRequireDefault(_base);

								var _utils = require('./utils');

								var selectUtils = _interopRequireWildcard(_utils);

								function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

								function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

								var textSelection = _testcafeCore2.default.textSelection;
								var domUtils = _testcafeCore2.default.domUtils;
								var positionUtils = _testcafeCore2.default.positionUtils;

								var SelectTextAutomation = function (_SelectBaseAutomation) {
								    _inherits(SelectTextAutomation, _SelectBaseAutomation);

								    function SelectTextAutomation(element, startPos, endPos, actionOptions) {
								        _classCallCheck(this, SelectTextAutomation);

								        var _this = _possibleConstructorReturn(this, _SelectBaseAutomation.call(this, element, _hammerhead.utils.extend(actionOptions, { offsetX: 0, offsetY: 0 })));

								        _this.startPos = startPos;
								        _this.endPos = endPos;
								        return _this;
								    }

								    SelectTextAutomation.prototype._calculateAbsoluteStartPoint = function _calculateAbsoluteStartPoint() {
								        var point = selectUtils.getSelectionCoordinatesByPosition(this.element, this.startPos);

								        return point || positionUtils.findCenter(this.element);
								    };

								    SelectTextAutomation.prototype._calculateAbsoluteEndPoint = function _calculateAbsoluteEndPoint() {
								        var point = selectUtils.getSelectionCoordinatesByPosition(this.element, this.endPos);

								        if (point) return point;

								        // NOTE: if selection ends on an invisible symbol, we should try to find the last visible selection position
								        if (domUtils.isContentEditableElement(this.element)) return selectUtils.getLastVisibleSelectionPosition(this.element, this.startPos, this.endPos);

								        return positionUtils.findCenter(this.element);
								    };

								    SelectTextAutomation.prototype._setSelection = function _setSelection() {
								        var isTextEditable = domUtils.isTextEditableElement(this.element);
								        var isContentEditable = domUtils.isContentEditableElement(this.element);

								        if (!(isTextEditable || isContentEditable) || this.eventState.simulateDefaultBehavior === false) return;

								        textSelection.select(this.element, this.startPos, this.endPos);
								    };

								    SelectTextAutomation.prototype.run = function run(useStrictElementCheck) {
								        var _this2 = this;

								        return this._ensureElement(useStrictElementCheck).then(function () {
								            return _SelectBaseAutomation.prototype.run.call(_this2);
								        });
								    };

								    return SelectTextAutomation;
								}(_base2.default);

								exports.default = SelectTextAutomation;
								module.exports = exports['default'];
							},
							"utils.js": function (exports, module, require) {
								

								exports.__esModule = true;
								exports.getSelectionCoordinatesByPosition = getSelectionCoordinatesByPosition;
								exports.getSelectionCoordinatesByNodeAndOffset = getSelectionCoordinatesByNodeAndOffset;
								exports.getLastVisibleSelectionPosition = getLastVisibleSelectionPosition;
								exports.scrollEditableElementByPoint = scrollEditableElementByPoint;
								exports.excludeElementScroll = excludeElementScroll;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								var browserUtils = _hammerhead2.default.utils.browser;

								var domUtils = _testcafeCore2.default.domUtils;
								var positionUtils = _testcafeCore2.default.positionUtils;
								var styleUtils = _testcafeCore2.default.styleUtils;
								var contentEditable = _testcafeCore2.default.contentEditable;
								var arrayUtils = _testcafeCore2.default.arrayUtils;

								var MODIFIERS_LIST = ['direction', 'font-family', 'font-size', 'font-size-adjust', 'font-variant', 'font-weight', 'font-style', 'letter-spacing', 'line-height', 'text-align', 'text-indent', 'text-transform', 'word-wrap', 'word-spacing', 'padding-top', 'padding-left', 'padding-right', 'padding-bottom', 'margin-top', 'margin-left', 'margin-right', 'margin-bottom', 'border-top-width', 'border-left-width', 'border-right-width', 'border-bottom-width'];

								function ensureRectangleInsideElement(element, rect) {
								    var elementBorders = styleUtils.getBordersWidth(element);
								    var elementOffset = positionUtils.getOffsetPosition(element);

								    // NOTE: strange behavior in Chrome - for some elements (e.g., for the 'font' element)
								    // scrollHeight is 0, so we use getBoundingClientRect
								    var elementHeight = element.scrollHeight || element.getBoundingClientRect().height;
								    var left = Math.ceil(rect.left);
								    var top = Math.ceil(rect.top);
								    var bottom = Math.floor(rect.bottom);

								    if (!domUtils.isTextAreaElement(element)) {
								        var clientOffset = positionUtils.offsetToClientCoords({
								            x: elementOffset.left,
								            y: elementOffset.top
								        });

								        var minLeft = clientOffset.x + elementBorders.left + 1;
								        var minTop = clientOffset.y + elementBorders.top + 1;
								        var bottomBound = clientOffset.y + elementBorders.top + elementBorders.bottom + elementHeight;
								        var maxBottom = clientOffset.y + elementBorders.top + elementHeight - 1;

								        left = Math.ceil(left <= clientOffset.x ? minLeft : rect.left);
								        top = Math.ceil(top <= clientOffset.y ? minTop : rect.top);
								        bottom = Math.floor(bottom >= bottomBound ? maxBottom : rect.bottom);
								    }

								    return {
								        left: left,
								        top: top,
								        bottom: bottom
								    };
								}

								function getAbsoluteRect(rect) {
								    var documentScroll = styleUtils.getElementScroll(document);

								    return {
								        left: rect.left + documentScroll.left,
								        top: rect.top + documentScroll.top,
								        bottom: rect.bottom + documentScroll.top
								    };
								}

								function getSelectionRectangleInContentEditableElement(element, position) {
								    var range = domUtils.findDocument(element).createRange();
								    var selectionPosition = contentEditable.calculateNodeAndOffsetByPosition(element, position);

								    range.setStart(selectionPosition.node, Math.min(selectionPosition.offset, selectionPosition.node.length));
								    range.setEnd(selectionPosition.node, Math.min(selectionPosition.offset, selectionPosition.node.length));

								    return range.getClientRects()[0];
								}

								function getTextSelectionRectangle(element, position) {
								    var range = element.createTextRange();

								    range.collapse(true);
								    range.moveStart('character', position);
								    range.moveEnd('character', position);
								    range.collapse(true);

								    return range.getBoundingClientRect();
								}

								function getSelectionRectangle(element, position) {
								    var clientRectBeforeFakeDiv = element.getBoundingClientRect();
								    var fakeDiv = createFakeDiv(element);
								    var rect = null;
								    var clientRectAfterFakeDiv = element.getBoundingClientRect();
								    var topBoundDiff = clientRectAfterFakeDiv.top - clientRectBeforeFakeDiv.top;
								    var leftBoundDiff = clientRectAfterFakeDiv.left - clientRectBeforeFakeDiv.left;
								    var valueLength = domUtils.getElementValue(element).length;

								    try {
								        var range = document.createRange(); //B254723

								        range.setStart(_hammerhead2.default.nativeMethods.nodeFirstChildGetter.call(fakeDiv), Math.min(position, valueLength));
								        // NOTE: The range.getClientRects function returns wrong result if range length is 0 in Safari 11
								        range.setEnd(_hammerhead2.default.nativeMethods.nodeFirstChildGetter.call(fakeDiv), Math.min(position + 1, valueLength + 1));

								        if (domUtils.isTextAreaElement(element)) {
								            rect = range.getBoundingClientRect();

								            if (rect.width === 0 && rect.height === 0) rect = range.getClientRects()[0];
								        } else rect = range.getClientRects()[0];
								    } catch (err) {
								        rect = null;
								    }

								    domUtils.remove(fakeDiv);

								    if (!rect) return null;

								    return {
								        width: rect.width,
								        height: rect.height,
								        top: rect.top - topBoundDiff,
								        bottom: rect.bottom - topBoundDiff,
								        left: rect.left - leftBoundDiff,
								        right: rect.right - leftBoundDiff
								    };
								}

								function createFakeDiv(element) {
								    var body = document.body;
								    var elementOffset = positionUtils.getOffsetPosition(element);
								    var elementMargin = styleUtils.getElementMargin(element);
								    var elementTop = elementOffset.top - elementMargin.top;
								    var elementLeft = elementOffset.left - elementMargin.left;

								    var fakeDiv = document.createElement('div');
								    var fakeDivCssStyles = 'white-space:pre-wrap;border-style:solid;';

								    if (styleUtils.get(body, 'position') === 'absolute') {
								        var bodyMargin = styleUtils.getElementMargin(body);
								        var bodyLeft = styleUtils.get(body, 'left');
								        var bodyTop = styleUtils.get(body, 'top');

								        elementLeft -= bodyMargin.left + (parseInt(bodyLeft.replace('px', ''), 10) || 0);
								        elementTop -= bodyMargin.top + (parseInt(bodyTop.replace('px', ''), 10) || 0);
								    }

								    arrayUtils.forEach(MODIFIERS_LIST, function (modifier) {
								        fakeDivCssStyles += modifier + ':' + styleUtils.get(element, modifier) + ';';
								    });

								    styleUtils.set(fakeDiv, {
								        cssText: fakeDivCssStyles,
								        position: 'absolute',
								        left: elementLeft + 'px',
								        top: elementTop + 'px',
								        width: element.scrollWidth + 'px',
								        height: element.scrollHeight + 'px'
								    });

								    _hammerhead2.default.nativeMethods.nodeTextContentSetter.call(fakeDiv, domUtils.getElementValue(element) + ' ');

								    body.appendChild(fakeDiv);

								    return fakeDiv;
								}

								function getPositionCoordinates(element, position) {
								    var rect = null;

								    if (domUtils.isContentEditableElement(element)) rect = getSelectionRectangleInContentEditableElement(element, position);else if (typeof element.createTextRange === 'function') rect = getTextSelectionRectangle(element, position);else rect = getSelectionRectangle(element, position);

								    if (!rect) return null;

								    rect = ensureRectangleInsideElement(element, rect);
								    rect = getAbsoluteRect(rect);

								    return {
								        x: rect.left,
								        y: Math.floor(rect.top + (rect.bottom - rect.top) / 2)
								    };
								}

								function getSelectionCoordinatesByPosition(element, position) {
								    var isTextEditable = domUtils.isTextEditableElement(element);
								    var isContentEditable = domUtils.isContentEditableElement(element);
								    var hasText = isTextEditable && domUtils.getElementValue(element).length > 0 || isContentEditable && contentEditable.getContentEditableValue(element).length;

								    if (!hasText) return positionUtils.findCenter(element);

								    return getPositionCoordinates(element, position);
								}

								function getSelectionCoordinatesByNodeAndOffset(element, node, offset) {
								    var range = domUtils.findDocument(element).createRange();

								    range.setStart(node, Math.min(offset, node.length));
								    range.setEnd(node, Math.min(offset, node.length));

								    var rect = range.getClientRects()[0];

								    if (!rect) return null;

								    rect = ensureRectangleInsideElement(element, rect);
								    rect = getAbsoluteRect(rect);

								    return {
								        x: rect.left,
								        y: Math.floor(rect.top + (rect.bottom - rect.top) / 2)
								    };
								}

								function getLastVisibleSelectionPosition(element, startPos, endPos) {
								    var backward = startPos > endPos;
								    var inc = backward ? 1 : -1;
								    var currentPos = endPos;
								    var currentPoint = null;

								    while (currentPos !== startPos) {
								        currentPos += inc;
								        currentPoint = getPositionCoordinates(element, currentPos);

								        if (currentPoint) break;
								    }

								    if (!currentPoint) {
								        currentPoint = getPositionCoordinates(element, startPos) || positionUtils.findCenter(element);
								    }

								    return currentPoint;
								}

								function scrollEditableElementByPoint(element, point) {
								    if (!domUtils.isEditableElement(element)) return;

								    var isTextarea = domUtils.isTextAreaElement(element);
								    var isInputElement = domUtils.isInputElement(element);

								    // NOTE: we don't need to scroll input elements in Mozilla and
								    // IE > 10 because it happens automatically on selection setting
								    if (isInputElement && (browserUtils.isFirefox || browserUtils.isIE && browserUtils.version > 10)) return;

								    var elementOffset = positionUtils.getOffsetPosition(element);
								    var elementBorders = styleUtils.getBordersWidth(element);
								    var elementScroll = styleUtils.getElementScroll(element);

								    var offsetX = point.x - elementOffset.left - elementBorders.left;
								    var offsetY = point.y - elementOffset.top - elementBorders.top;
								    var scrollValue = null;

								    if (isTextarea) {
								        if (offsetY < elementScroll.top) scrollValue = offsetY;

								        if (offsetY > element.clientHeight + elementScroll.top) scrollValue = offsetY - element.clientHeight;

								        if (scrollValue !== null) styleUtils.setScrollTop(element, Math.round(scrollValue));

								        return;
								    }

								    if (offsetX < elementScroll.left) scrollValue = offsetX;

								    if (offsetX > element.clientWidth + elementScroll.left) scrollValue = offsetX - element.clientWidth;

								    if (scrollValue !== null) styleUtils.setScrollLeft(element, Math.round(scrollValue));
								}

								function excludeElementScroll(element, point) {
								    var isTextEditable = domUtils.isTextEditableElement(element);
								    var isInputElement = domUtils.isInputElement(element);

								    if (!(isTextEditable || domUtils.isContentEditableElement(element))) return point;

								    var elementOffset = positionUtils.getOffsetPosition(element);
								    var elementBorders = styleUtils.getBordersWidth(element);
								    var elementScroll = styleUtils.getElementScroll(element);
								    var maxLeft = elementOffset.left + elementBorders.left + element.clientWidth;

								    // NOTE: we can't know input elements' scroll value in Mozilla and
								    // IE > 10 (https://bugzilla.mozilla.org/show_bug.cgi?id=293186)
								    if (isInputElement && isTextEditable && (browserUtils.isFirefox || browserUtils.isIE && browserUtils.version > 10)) {
								        return {
								            x: Math.min(point.x, maxLeft),
								            y: point.y
								        };
								    }

								    return {
								        x: point.x - elementScroll.left,
								        y: point.y - elementScroll.top
								    };
								}
							}
						},
						"type": {
							"index.js": function (exports, module, require) {
								

								exports.__esModule = true;

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _options = require('../../../../test-run/commands/options');

								var _click2 = require('../click');

								var _click3 = _interopRequireDefault(_click2);

								var _typeText = require('./type-text');

								var _typeText2 = _interopRequireDefault(_typeText);

								var _getKeyCode = require('../../utils/get-key-code');

								var _getKeyCode2 = _interopRequireDefault(_getKeyCode);

								var _getKeyIdentifier = require('../../utils/get-key-identifier');

								var _getKeyIdentifier2 = _interopRequireDefault(_getKeyIdentifier);

								var _keyIdentifierRequiredForEvent = require('../../utils/key-identifier-required-for-event');

								var _keyIdentifierRequiredForEvent2 = _interopRequireDefault(_keyIdentifierRequiredForEvent);

								var _offsets = require('../../utils/offsets');

								var _settings = require('../../settings');

								var _settings2 = _interopRequireDefault(_settings);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

								var Promise = _hammerhead2.default.Promise;
								var extend = _hammerhead2.default.utils.extend;
								var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;
								var elementEditingWatcher = _hammerhead2.default.eventSandbox.elementEditingWatcher;

								var domUtils = _testcafeCore2.default.domUtils;
								var promiseUtils = _testcafeCore2.default.promiseUtils;
								var contentEditable = _testcafeCore2.default.contentEditable;
								var textSelection = _testcafeCore2.default.textSelection;
								var delay = _testcafeCore2.default.delay;
								var SPECIAL_KEYS = _testcafeCore2.default.KEY_MAPS.specialKeys;

								var TypeAutomation = function () {
								    function TypeAutomation(element, text, typeOptions) {
								        _classCallCheck(this, TypeAutomation);

								        this.element = TypeAutomation.findTextEditableChild(element) || element;
								        this.typingText = text.toString();

								        this.modifiers = typeOptions.modifiers;
								        this.caretPos = typeOptions.caretPos;
								        this.replace = typeOptions.replace;
								        this.paste = typeOptions.paste;
								        this.offsetX = typeOptions.offsetX;
								        this.offsetY = typeOptions.offsetY;
								        this.speed = typeOptions.speed;

								        this.automationSettings = new _settings2.default(this.speed);

								        this.elementChanged = element !== this.element;
								        this.currentPos = 0;
								        this.currentKeyCode = null;
								        this.currentCharCode = null;
								        this.currentKey = null;
								        this.currentKeyIdentifier = null;

								        this.eventArgs = {
								            options: null,
								            element: null
								        };

								        this.eventState = {
								            skipType: false,
								            simulateKeypress: true,
								            simulateTypeChar: true
								        };
								    }

								    TypeAutomation.findTextEditableChild = function findTextEditableChild(element) {
								        var innerElement = null;

								        if (!domUtils.isEditableElement(element)) {
								            var allChildren = element.querySelectorAll('*');

								            for (var i = 0; i < allChildren.length; i++) {
								                if (domUtils.isTextEditableElementAndEditingAllowed(allChildren[i])) {
								                    innerElement = allChildren[i];
								                    break;
								                }
								            }
								        }

								        return innerElement;
								    };

								    TypeAutomation.prototype._calculateEventArguments = function _calculateEventArguments(isPressEvent) {
								        var activeElement = domUtils.getActiveElement();
								        var isContentEditable = domUtils.isContentEditableElement(this.element);
								        var element = this.eventArgs.element || this.element;

								        // T162478: Wrong typing and keys pressing in editor
								        if (!isContentEditable && activeElement !== element) element = TypeAutomation.findTextEditableChild(activeElement) || activeElement;

								        var options = extend({
								            keyCode: isPressEvent ? this.currentCharCode : this.currentKeyCode
								        }, this.modifiers);

								        if (isPressEvent) options.charCode = this.currentCharCode;

								        if ((0, _keyIdentifierRequiredForEvent2.default)()) options.keyIdentifier = isPressEvent ? '' : this.currentKeyIdentifier;else options.key = this.currentKey;

								        return { element: element, options: options };
								    };

								    TypeAutomation.prototype._calculateTargetElement = function _calculateTargetElement() {
								        var activeElement = domUtils.getActiveElement();
								        var isContentEditable = domUtils.isContentEditableElement(this.element);

								        if (isContentEditable) {
								            if (activeElement !== contentEditable.findContentEditableParent(this.element)) {
								                this.eventState.skipType = true;

								                return;
								            }
								        } else if (activeElement !== this.element) {
								            this.eventState.skipType = true;

								            return;
								        }

								        this.element = isContentEditable ? this.element : activeElement;
								    };

								    TypeAutomation.prototype._click = function _click(useStrictElementCheck) {
								        var _this = this;

								        var activeElement = domUtils.getActiveElement();
								        var isTextEditable = domUtils.isTextEditableElementAndEditingAllowed(this.element);
								        var isContentEditable = domUtils.isContentEditableElement(this.element);

								        if (activeElement !== this.element) {
								            var _getDefaultAutomation = (0, _offsets.getDefaultAutomationOffsets)(this.element),
								                offsetX = _getDefaultAutomation.offsetX,
								                offsetY = _getDefaultAutomation.offsetY;

								            var clickOptions = new _options.ClickOptions({
								                offsetX: this.elementChanged ? offsetX : this.offsetX,
								                offsetY: this.elementChanged ? offsetY : this.offsetY,
								                speed: this.speed,
								                caretPos: this.caretPos,
								                modifiers: this.modifiers
								            });

								            var clickAutomation = new _click3.default(this.element, clickOptions);

								            return clickAutomation.run(useStrictElementCheck).then(function () {
								                return delay(_this.automationSettings.mouseActionStepDelay);
								            });
								        }

								        if (isTextEditable) elementEditingWatcher.watchElementEditing(this.element);

								        var isEditableElement = isTextEditable || isContentEditable;

								        if (isEditableElement) {
								            var selectionStart = textSelection.getSelectionStart(this.element);

								            if (!isNaN(parseInt(this.caretPos, 10)) && this.caretPos !== selectionStart) textSelection.select(this.element, this.caretPos, this.caretPos);
								        }

								        return Promise.resolve();
								    };

								    TypeAutomation.prototype._type = function _type() {
								        var _this2 = this;

								        if (this.eventState.skipType) return Promise.resolve();

								        var isContentEditable = domUtils.isContentEditableElement(this.element);

								        if (this.replace) {
								            if (domUtils.isTextEditableElementAndEditingAllowed(this.element)) textSelection.select(this.element);else if (isContentEditable) textSelection.deleteSelectionContents(this.element, true);
								        }

								        return promiseUtils.whilst(function () {
								            return !_this2._isTypingFinished();
								        }, function () {
								            return _this2._typingStep();
								        });
								    };

								    TypeAutomation.prototype._isTypingFinished = function _isTypingFinished() {
								        return this.currentPos === this.typingText.length;
								    };

								    TypeAutomation.prototype._typingStep = function _typingStep() {
								        var char = this.typingText.charAt(this.currentPos);

								        this.currentKeyCode = (0, _getKeyCode2.default)(char);
								        this.currentCharCode = this.typingText.charCodeAt(this.currentPos);
								        this.currentKey = this.currentKeyCode === SPECIAL_KEYS['enter'] ? 'Enter' : char;
								        this.currentKeyIdentifier = (0, _getKeyIdentifier2.default)(this.currentKey);

								        this._keydown();
								        this._keypress();

								        return this._keyup();
								    };

								    TypeAutomation.prototype._keydown = function _keydown() {
								        this.eventArgs = this._calculateEventArguments();

								        this.eventState.simulateKeypress = eventSimulator.keydown(this.eventArgs.element, this.eventArgs.options);
								    };

								    TypeAutomation.prototype._keypress = function _keypress() {
								        if (this.eventState.simulateKeypress === false) return;

								        this.eventArgs = this._calculateEventArguments(true);

								        this.eventState.simulateTypeChar = eventSimulator.keypress(this.eventArgs.element, this.eventArgs.options);
								    };

								    TypeAutomation.prototype._keyup = function _keyup() {
								        var _this3 = this;

								        var elementForTyping = this.eventArgs.element;

								        this.eventArgs = this._calculateEventArguments();

								        var isTextEditableElement = domUtils.isTextEditableElement(this.element);
								        var isContentEditable = domUtils.isContentEditableElement(this.element);

								        var shouldTypeAllText = this.paste || !isTextEditableElement && !isContentEditable;

								        return Promise.resolve().then(function () {
								            return shouldTypeAllText ? _this3._typeAllText(elementForTyping) : _this3._typeChar(elementForTyping);
								        }).then(function () {
								            eventSimulator.keyup(_this3.eventArgs.element, _this3.eventArgs.options);

								            if (shouldTypeAllText) _this3.currentPos = _this3.typingText.length;else _this3.currentPos++;
								        });
								    };

								    TypeAutomation.prototype._typeChar = function _typeChar(element) {
								        // NOTE: change event must not be raised after prevented keydown
								        // or keypress even if element value was changed (B253816)
								        if (this.eventState.simulateKeypress === false || this.eventState.simulateTypeChar === false) {
								            elementEditingWatcher.restartWatchingElementEditing(element);

								            return delay(this.automationSettings.keyActionStepDelay);
								        }

								        var currentChar = this.typingText.charAt(this.currentPos);
								        var isDigit = /^\d$/.test(currentChar);
								        var prevChar = this.currentPos === 0 ? null : this.typingText.charAt(this.currentPos - 1);
								        var isInputTypeNumber = domUtils.isInputElement(element) && element.type === 'number';

								        if (isInputTypeNumber) {
								            var selectionStart = textSelection.getSelectionStart(element);
								            var valueLength = domUtils.getInputValue(element).length;
								            var textHasDigits = /^\d/.test(this.typingText);
								            var isPermissibleSymbol = currentChar === '.' || currentChar === '-' && valueLength;

								            if (!isDigit && (textHasDigits || !isPermissibleSymbol || selectionStart !== 0)) return delay(this.automationSettings.keyActionStepDelay);

								            // NOTE: allow to type '.' or '-' only if it is the first symbol and the input already has
								            // a value, or if '.' or '-' are added to a digit. Otherwise, the value won't be set.
								            if (isDigit && (prevChar === '.' || prevChar === '-' && !valueLength)) currentChar = prevChar + currentChar;
								        }

								        (0, _typeText2.default)(element, currentChar, null);

								        return delay(this.automationSettings.keyActionStepDelay);
								    };

								    TypeAutomation.prototype._typeAllText = function _typeAllText(element) {
								        (0, _typeText2.default)(element, this.typingText, this.caretPos);
								        return delay(this.automationSettings.keyActionStepDelay);
								    };

								    TypeAutomation.prototype.run = function run(useStrictElementCheck) {
								        var _this4 = this;

								        return this._click(useStrictElementCheck).then(function () {
								            return _this4._calculateTargetElement();
								        }).then(function () {
								            return _this4._type();
								        });
								    };

								    return TypeAutomation;
								}();

								exports.default = TypeAutomation;
								module.exports = exports['default'];
							},
							"type-text.js": function (exports, module, require) {
								

								exports.__esModule = true;

								exports.default = function (element, text, caretPos) {
								    if (domUtils.isContentEditableElement(element)) _typeTextToContentEditable(element, text);

								    if (!domUtils.isElementReadOnly(element)) {
								        if (domUtils.isTextEditableElement(element)) _typeTextToTextEditable(element, text);else if (domUtils.isInputElement(element)) _typeTextToNonTextEditable(element, text, caretPos);
								    }
								};

								var _hammerhead = require('../../deps/hammerhead');

								var _hammerhead2 = _interopRequireDefault(_hammerhead);

								var _testcafeCore = require('../../deps/testcafe-core');

								var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

								var _nextTick = require('../../utils/next-tick');

								var _nextTick2 = _interopRequireDefault(_nextTick);

								function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

								var browserUtils = _hammerhead2.default.utils.browser;
								var eventSandbox = _hammerhead2.default.sandbox.event;
								var eventSimulator = _hammerhead2.default.eventSandbox.eventSimulator;
								var listeners = _hammerhead2.default.eventSandbox.listeners;

								var domUtils = _testcafeCore2.default.domUtils;
								var contentEditable = _testcafeCore2.default.contentEditable;
								var textSelection = _testcafeCore2.default.textSelection;

								var WHITE_SPACES_RE = / /g;

								function _getSelectionInElement(element) {
								    var currentSelection = textSelection.getSelectionByElement(element);
								    var isInverseSelection = textSelection.hasInverseSelectionContentEditable(element);

								    if (textSelection.hasElementContainsSelection(element)) return contentEditable.getSelection(element, currentSelection, isInverseSelection);

								    // NOTE: if we type text to an element that doesn't contain selection we
								    // assume the selectionStart and selectionEnd positions are null in this
								    // element. So we calculate the necessary start and end nodes and offsets
								    return {
								        startPos: contentEditable.calculateNodeAndOffsetByPosition(element, 0),
								        endPos: contentEditable.calculateNodeAndOffsetByPosition(element, 0)
								    };
								}

								function _updateSelectionAfterDeletionContent(element, selection) {
								    var startNode = selection.startPos.node;
								    var hasStartParent = startNode.parentNode && startNode.parentElement;

								    var browserRequiresSelectionUpdating = browserUtils.isChrome && browserUtils.version < 58 || browserUtils.isSafari;

								    if (browserRequiresSelectionUpdating || !hasStartParent || !domUtils.isElementContainsNode(element, startNode)) {
								        selection = _getSelectionInElement(element);

								        if (textSelection.hasInverseSelectionContentEditable(element)) {
								            selection = {
								                startPos: selection.endPos,
								                endPos: selection.startPos
								            };
								        }
								    }

								    selection.endPos.offset = selection.startPos.offset;

								    return selection;
								}

								function _typeTextInElementNode(elementNode, text, offset) {
								    var nodeForTyping = document.createTextNode(text);
								    var textLength = text.length;
								    var selectPosition = { node: nodeForTyping, offset: textLength };

								    if (domUtils.getTagName(elementNode) === 'br') elementNode.parentNode.insertBefore(nodeForTyping, elementNode);else if (offset > 0) elementNode.insertBefore(nodeForTyping, elementNode.childNodes[offset]);else elementNode.appendChild(nodeForTyping);

								    textSelection.selectByNodesAndOffsets(selectPosition, selectPosition);
								}

								function _typeTextInChildTextNode(element, selection, text) {
								    var startNode = selection.startPos.node;

								    // NOTE: startNode could be moved or deleted on textInput event. Need ensure startNode.
								    if (!domUtils.isElementContainsNode(element, startNode)) {
								        selection = _excludeInvisibleSymbolsFromSelection(_getSelectionInElement(element));
								        startNode = selection.startPos.node;
								    }

								    var startOffset = selection.startPos.offset;
								    var endOffset = selection.endPos.offset;
								    var nodeValue = startNode.nodeValue;
								    var selectPosition = { node: startNode, offset: startOffset + text.length };

								    startNode.nodeValue = nodeValue.substring(0, startOffset) + text + nodeValue.substring(endOffset, nodeValue.length);

								    textSelection.selectByNodesAndOffsets(selectPosition, selectPosition);
								}

								function _excludeInvisibleSymbolsFromSelection(selection) {
								    var startNode = selection.startPos.node;
								    var startOffset = selection.startPos.offset;
								    var endOffset = selection.endPos.offset;

								    var firstNonWhitespaceSymbolIndex = contentEditable.getFirstNonWhitespaceSymbolIndex(startNode.nodeValue);
								    var lastNonWhitespaceSymbolIndex = contentEditable.getLastNonWhitespaceSymbolIndex(startNode.nodeValue);

								    if (startOffset < firstNonWhitespaceSymbolIndex && startOffset !== 0) {
								        selection.startPos.offset = firstNonWhitespaceSymbolIndex;
								        selection.endPos.offset = endOffset + firstNonWhitespaceSymbolIndex - startOffset;
								    } else if (endOffset > lastNonWhitespaceSymbolIndex && endOffset !== startNode.nodeValue.length) {
								        selection.startPos.offset = startNode.nodeValue.length;
								        selection.endPos.offset = endOffset + startNode.nodeValue.length - startOffset;
								    }

								    return selection;
								}

								// NOTE: Typing can be prevented in Chrome/Edge but can not be prevented in IE11 or Firefox
								// Firefox does not support TextInput event
								// Safari supports the TextInput event but has a bug: e.data is added to the node value.
								// So in Safari we need to call preventDefault in the last textInput handler but not prevent the Input event

								function simulateTextInput(element, text) {
								    var forceInputInSafari = void 0;

								    function onSafariTextInput(e) {
								        e.preventDefault();

								        forceInputInSafari = true;
								    }

								    function onSafariPreventTextInput(e) {
								        if (e.type === 'textInput') forceInputInSafari = false;
								    }

								    if (browserUtils.isSafari) {
								        listeners.addInternalEventListener(window, ['textInput'], onSafariTextInput);
								        eventSandbox.on(eventSandbox.EVENT_PREVENTED_EVENT, onSafariPreventTextInput);
								    }

								    var isInputEventRequired = browserUtils.isFirefox || eventSimulator.textInput(element, text) || forceInputInSafari;

								    if (browserUtils.isSafari) {
								        listeners.removeInternalEventListener(window, ['textInput'], onSafariTextInput);
								        eventSandbox.off(eventSandbox.EVENT_PREVENTED_EVENT, onSafariPreventTextInput);
								    }

								    return isInputEventRequired || browserUtils.isIE11;
								}

								function _typeTextToContentEditable(element, text) {
								    var currentSelection = _getSelectionInElement(element);
								    var startNode = currentSelection.startPos.node;
								    var endNode = currentSelection.endPos.node;
								    var needProcessInput = true;
								    var needRaiseInputEvent = true;
								    var textInputData = text;

								    text = text.replace(WHITE_SPACES_RE, String.fromCharCode(160));

								    // NOTE: some browsers raise the 'input' event after the element
								    // content is changed, but in others we should do it manually.

								    var onInput = function onInput() {
								        needRaiseInputEvent = false;
								    };

								    // NOTE: IE11 raises the 'textinput' event many times after the element changed.
								    // The 'textinput' should be called only once

								    function onTextInput(event, dispatched, preventEvent) {
								        preventEvent();
								    }

								    // NOTE: IE11 does not raise input event when type to contenteditable

								    var beforeContentChanged = function beforeContentChanged() {
								        needProcessInput = simulateTextInput(element, textInputData);
								        needRaiseInputEvent = needProcessInput && !browserUtils.isIE11;

								        listeners.addInternalEventListener(window, ['input'], onInput);
								        listeners.addInternalEventListener(window, ['textinput'], onTextInput);
								    };

								    var afterContentChanged = function afterContentChanged() {
								        (0, _nextTick2.default)().then(function () {
								            if (needRaiseInputEvent) eventSimulator.input(element);

								            listeners.removeInternalEventListener(window, ['input'], onInput);
								            listeners.removeInternalEventListener(window, ['textinput'], onTextInput);
								        });
								    };

								    if (!startNode || !endNode || !domUtils.isContentEditableElement(startNode) || !domUtils.isContentEditableElement(endNode)) return;

								    if (!domUtils.isTheSameNode(startNode, endNode)) {
								        textSelection.deleteSelectionContents(element);

								        // NOTE: after deleting the selection contents we should refresh the stored startNode because
								        // contentEditable element's content could change and we can no longer find parent elements
								        // of the nodes. In MSEdge, 'parentElement' for the deleted element isn't undefined
								        currentSelection = _updateSelectionAfterDeletionContent(element, currentSelection);
								        startNode = currentSelection.startPos.node;
								    }

								    if (!startNode || !domUtils.isContentEditableElement(startNode) || !domUtils.isRenderedNode(startNode)) return;

								    beforeContentChanged();

								    if (needProcessInput) {
								        // NOTE: we can type only to the text nodes; for nodes with the 'element-node' type, we use a special behavior
								        if (domUtils.isElementNode(startNode)) _typeTextInElementNode(startNode, text);else _typeTextInChildTextNode(element, _excludeInvisibleSymbolsFromSelection(currentSelection), text);
								    }

								    afterContentChanged();
								}

								function _typeTextToTextEditable(element, text) {
								    var elementValue = domUtils.getElementValue(element);
								    var textLength = text.length;
								    var startSelection = textSelection.getSelectionStart(element);
								    var endSelection = textSelection.getSelectionEnd(element);
								    var isInputTypeNumber = domUtils.isInputElement(element) && element.type === 'number';
								    var needProcessInput = simulateTextInput(element, text);

								    if (!needProcessInput) return;

								    // NOTE: the 'maxlength' attribute doesn't work in all browsers. IE still doesn't support input with the 'number' type
								    var elementMaxLength = !browserUtils.isIE && isInputTypeNumber ? null : parseInt(element.maxLength, 10);

								    if (elementMaxLength < 0) elementMaxLength = browserUtils.isIE && browserUtils.version < 17 ? 0 : null;

								    if (elementMaxLength === null || isNaN(elementMaxLength) || elementMaxLength > elementValue.length) {
								        // NOTE: B254013
								        if (isInputTypeNumber && browserUtils.isIOS && elementValue[elementValue.length - 1] === '.') {
								            startSelection += 1;
								            endSelection += 1;
								        }

								        domUtils.setElementValue(element, elementValue.substring(0, startSelection) + text + elementValue.substring(endSelection, elementValue.length));

								        textSelection.select(element, startSelection + textLength, startSelection + textLength);
								    }

								    // NOTE: We should simulate the 'input' event after typing a char (B253410, T138385)
								    eventSimulator.input(element);
								}

								function _typeTextToNonTextEditable(element, text, caretPos) {
								    if (caretPos !== null) {
								        var elementValue = domUtils.getElementValue(element);

								        domUtils.setElementValue(element, elementValue.substr(0, caretPos) + text + elementValue.substr(caretPos + text.length));
								    } else domUtils.setElementValue(element, text);

								    eventSimulator.change(element);
								    eventSimulator.input(element);
								}

								module.exports = exports['default'];
							}
						},
						"upload.js": function (exports, module, require) {
							

							exports.__esModule = true;

							var _hammerhead = require('../deps/hammerhead');

							var _testcafeCore = require('../deps/testcafe-core');

							function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

							var UploadAutomation = function () {
							    function UploadAutomation(element, paths, createError) {
							        _classCallCheck(this, UploadAutomation);

							        this.element = element;
							        this.paths = paths;
							        this.createError = createError;
							    }

							    UploadAutomation.prototype.run = function run() {
							        var _this = this;

							        return (0, _hammerhead.doUpload)(this.element, this.paths).then(function (errs) {
							            if (errs.length) throw _this.createError(_testcafeCore.arrayUtils.map(errs, function (err) {
							                return err.path;
							            }));
							        });
							    };

							    return UploadAutomation;
							}();

							exports.default = UploadAutomation;
							module.exports = exports['default'];
						},
						"visible-element-automation.js": function (exports, module, require) {
							

							exports.__esModule = true;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _testcafeCore = require('../deps/testcafe-core');

							var _getAutomationPoint = require('../utils/get-automation-point');

							var _getAutomationPoint2 = _interopRequireDefault(_getAutomationPoint);

							var _screenPointToClient = require('../utils/screen-point-to-client');

							var _screenPointToClient2 = _interopRequireDefault(_screenPointToClient);

							var _getDevicePoint = require('../utils/get-device-point');

							var _getDevicePoint2 = _interopRequireDefault(_getDevicePoint);

							var _getElement = require('../get-element');

							var _errors = require('../errors');

							var _errors2 = _interopRequireDefault(_errors);

							var _settings = require('../settings');

							var _settings2 = _interopRequireDefault(_settings);

							var _scroll = require('./scroll');

							var _scroll2 = _interopRequireDefault(_scroll);

							var _move = require('./move');

							var _move2 = _interopRequireDefault(_move);

							var _options = require('../../../test-run/commands/options');

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

							function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

							function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

							var extend = _hammerhead2.default.utils.extend;

							var ElementState = function ElementState(_ref) {
							    var _ref$element = _ref.element,
							        element = _ref$element === undefined ? null : _ref$element,
							        _ref$clientPoint = _ref.clientPoint,
							        clientPoint = _ref$clientPoint === undefined ? null : _ref$clientPoint,
							        _ref$screenPoint = _ref.screenPoint,
							        screenPoint = _ref$screenPoint === undefined ? null : _ref$screenPoint,
							        _ref$isTarget = _ref.isTarget,
							        isTarget = _ref$isTarget === undefined ? false : _ref$isTarget,
							        _ref$inMoving = _ref.inMoving,
							        inMoving = _ref$inMoving === undefined ? false : _ref$inMoving;

							    _classCallCheck(this, ElementState);

							    this.element = element;
							    this.clientPoint = clientPoint;
							    this.screenPoint = screenPoint;
							    this.isTarget = isTarget;
							    this.inMoving = inMoving;
							    this.devicePoint = (0, _getDevicePoint2.default)(clientPoint);
							};

							var VisibleElementAutomation = function (_serviceUtils$EventEm) {
							    _inherits(VisibleElementAutomation, _serviceUtils$EventEm);

							    function VisibleElementAutomation(element, offsetOptions) {
							        _classCallCheck(this, VisibleElementAutomation);

							        var _this = _possibleConstructorReturn(this, _serviceUtils$EventEm.call(this));

							        _this.TARGET_ELEMENT_FOUND_EVENT = 'automation|target-element-found-event';

							        _this.element = element;
							        _this.options = offsetOptions;
							        _this.automationSettings = new _settings2.default(offsetOptions.speed);
							        return _this;
							    }

							    VisibleElementAutomation.prototype._getElementForEvent = function _getElementForEvent(eventArgs) {
							        var _eventArgs$point = eventArgs.point,
							            x = _eventArgs$point.x,
							            y = _eventArgs$point.y;

							        var expectedElement = _testcafeCore.positionUtils.containsOffset(this.element, this.options.offsetX, this.options.offsetY) ? this.element : null;

							        return (0, _getElement.fromPoint)(x, y, expectedElement).then(function (_ref2) {
							            var element = _ref2.element;
							            return element;
							        });
							    };

							    VisibleElementAutomation.prototype._moveToElement = function _moveToElement() {
							        var _this2 = this;

							        var moveOptions = new _options.MoveOptions(extend({ skipScrolling: true }, this.options), false);
							        var moveAutomation = new _move2.default(this.element, moveOptions);

							        return moveAutomation.run().then(function () {
							            return (0, _testcafeCore.delay)(_this2.automationSettings.mouseActionStepDelay);
							        });
							    };

							    VisibleElementAutomation.prototype._scrollToElement = function _scrollToElement() {
							        var _this3 = this;

							        var scrollAutomation = new _scroll2.default(this.element, new _options.ScrollOptions(this.options));

							        return scrollAutomation.run().then(function () {
							            return (0, _testcafeCore.delay)(_this3.automationSettings.mouseActionStepDelay);
							        });
							    };

							    VisibleElementAutomation.prototype._wrapAction = function _wrapAction(action) {
							        var _this4 = this;

							        var offsetX = this.options.offsetX;
							        var offsetY = this.options.offsetY;
							        var screenPointBeforeAction = (0, _getAutomationPoint2.default)(this.element, offsetX, offsetY);
							        var clientPositionBeforeAction = _testcafeCore.positionUtils.getClientPosition(this.element);

							        return action().then(function () {
							            var screenPointAfterAction = (0, _getAutomationPoint2.default)(_this4.element, offsetX, offsetY);
							            var clientPositionAfterAction = _testcafeCore.positionUtils.getClientPosition(_this4.element);
							            var clientPoint = (0, _screenPointToClient2.default)(_this4.element, screenPointAfterAction);
							            var expectedElement = _testcafeCore.positionUtils.containsOffset(_this4.element, offsetX, offsetY) ? _this4.element : null;

							            return (0, _getElement.fromPoint)(clientPoint.x, clientPoint.y, expectedElement).then(function (_ref3) {
							                var element = _ref3.element,
							                    corrected = _ref3.corrected;

							                var foundElement = element;

							                if (!foundElement) return new ElementState({});

							                var isTarget = !expectedElement || corrected || foundElement === _this4.element;

							                if (!isTarget) {
							                    // NOTE: perform an operation with searching in dom only if necessary
							                    isTarget = _testcafeCore.arrayUtils.indexOf(_testcafeCore.domUtils.getParents(foundElement), _this4.element) > -1;
							                }

							                var offsetPositionChanged = screenPointBeforeAction.x !== screenPointAfterAction.x || screenPointBeforeAction.y !== screenPointAfterAction.y;
							                var clientPositionChanged = clientPositionBeforeAction.x !== clientPositionAfterAction.x || clientPositionBeforeAction.y !== clientPositionAfterAction.y;

							                // NOTE: We consider the element moved if its offset position and client position
							                // are changed both. If only client position was changed it means the page was
							                // scrolled and the element keeps its position on the page. If only offset position was
							                // changed it means the element is fixed on the page (it can be implemented via script).
							                var targetElementIsMoving = offsetPositionChanged && clientPositionChanged;

							                return new ElementState({
							                    element: element,
							                    clientPoint: clientPoint,
							                    screenPoint: screenPointAfterAction,
							                    isTarget: isTarget,
							                    inMoving: targetElementIsMoving
							                });
							            });
							        });
							    };

							    VisibleElementAutomation._checkElementState = function _checkElementState(state, useStrictElementCheck) {
							        if (!state.element) throw new Error(_errors2.default.elementIsInvisibleError);

							        if (useStrictElementCheck && (!state.isTarget || state.inMoving)) throw new Error(_errors2.default.foundElementIsNotTarget);
							    };

							    VisibleElementAutomation.prototype._ensureElement = function _ensureElement(useStrictElementCheck, skipCheckAfterMoving) {
							        var _this5 = this;

							        return this._wrapAction(function () {
							            return _this5._scrollToElement();
							        }).then(function (state) {
							            return VisibleElementAutomation._checkElementState(state, useStrictElementCheck);
							        }).then(function () {
							            return _this5._wrapAction(function () {
							                return _this5._moveToElement();
							            });
							        }).then(function (state) {
							            if (!skipCheckAfterMoving) VisibleElementAutomation._checkElementState(state, useStrictElementCheck);

							            return state;
							        }).then(function (state) {
							            _this5.emit(_this5.TARGET_ELEMENT_FOUND_EVENT, {});

							            return {
							                element: state.element,
							                clientPoint: state.clientPoint,
							                screenPoint: state.screenPoint,
							                devicePoint: state.devicePoint
							            };
							        });
							    };

							    return VisibleElementAutomation;
							}(_testcafeCore.serviceUtils.EventEmitter);

							exports.default = VisibleElementAutomation;
							module.exports = exports['default'];
						}
					},
					"settings.js": function (exports, module, require) {
						

						exports.__esModule = true;

						var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

						var ACTION_STEP_DELAY_DEFAULT = 10;
						var MAX_MOUSE_ACTION_STEP_DELAY = 400;
						var MAX_KEY_ACTION_STEP_DELAY = 200;

						// We use an exponential function to calculate the cursor
						// speed according to general test speed
						// cursorSpeed = (maxSpeed * k) ^ speed / k
						var MAX_CURSOR_SPEED = 100; // pixels/ms
						var MAX_DRAGGING_SPEED = 4; // pixels/ms
						var CURSOR_FACTOR = 4;

						var AutomationSettings = function () {
						    function AutomationSettings(speed) {
						        _classCallCheck(this, AutomationSettings);

						        this.speedFactor = speed || 1;
						    }

						    _createClass(AutomationSettings, [{
						        key: "mouseActionStepDelay",
						        get: function get() {
						            return this.speedFactor === 1 ? ACTION_STEP_DELAY_DEFAULT : (1 - this.speedFactor) * MAX_MOUSE_ACTION_STEP_DELAY;
						        }
						    }, {
						        key: "keyActionStepDelay",
						        get: function get() {
						            return this.speedFactor === 1 ? ACTION_STEP_DELAY_DEFAULT : (1 - this.speedFactor) * MAX_KEY_ACTION_STEP_DELAY;
						        }
						    }, {
						        key: "cursorSpeed",
						        get: function get() {
						            return Math.pow(MAX_CURSOR_SPEED * CURSOR_FACTOR, this.speedFactor) / CURSOR_FACTOR;
						        }
						    }, {
						        key: "draggingSpeed",
						        get: function get() {
						            return Math.pow(MAX_DRAGGING_SPEED * CURSOR_FACTOR, this.speedFactor) / CURSOR_FACTOR;
						        }
						    }]);

						    return AutomationSettings;
						}();

						exports.default = AutomationSettings;
						module.exports = exports["default"];
					},
					"utils": {
						"get-automation-point.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = getAutomationPoint;

							var _testcafeCore = require('../deps/testcafe-core');

							function getAutomationPoint(element, offsetX, offsetY) {
							    var elementOffset = _testcafeCore.positionUtils.getOffsetPosition(element);
							    var left = element === document.documentElement ? 0 : elementOffset.left;
							    var top = element === document.documentElement ? 0 : elementOffset.top;

							    return {
							        x: left + offsetX,
							        y: top + offsetY
							    };
							}
							module.exports = exports['default'];
						},
						"get-device-point.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = getDevicePoint;
							function getDevicePoint(clientPoint) {
							    if (!clientPoint) return null;

							    var screenLeft = window.screenLeft || window.screenX;
							    var screenTop = window.screenTop || window.screenY;
							    var x = screenLeft + clientPoint.x;
							    var y = screenTop + clientPoint.y;

							    return { x: x, y: y };
							}
							module.exports = exports["default"];
						},
						"get-key-code.js": function (exports, module, require) {
							

							exports.__esModule = true;

							exports.default = function (char) {
							    if ((0, _isLetter2.default)(char)) return char.toUpperCase().charCodeAt(0);

							    var res = _testcafeCore.KEY_MAPS.shiftMap[char] ? _testcafeCore.KEY_MAPS.shiftMap[char].charCodeAt(0) : char.charCodeAt(0);

							    return _testcafeCore.KEY_MAPS.symbolCharCodeToKeyCode[res] || res;
							};

							var _testcafeCore = require('../deps/testcafe-core');

							var _isLetter = require('./is-letter');

							var _isLetter2 = _interopRequireDefault(_isLetter);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							module.exports = exports['default'];
						},
						"get-key-identifier.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = getKeyIdentifier;

							var _keyIdentifierMaps = require('./key-identifier-maps');

							var _keyIdentifierMaps2 = _interopRequireDefault(_keyIdentifierMaps);

							var _isLetter = require('./is-letter');

							var _isLetter2 = _interopRequireDefault(_isLetter);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function getKeyIdentifier(char) {
							    if ((0, _isLetter2.default)(char)) return _keyIdentifierMaps2.default.LETTERS[char.toLowerCase()];

							    return _keyIdentifierMaps2.default.SYMBOLS[char] || _keyIdentifierMaps2.default.SPECIAL_KEYS[char] || char;
							}
							module.exports = exports['default'];
						},
						"get-line-rect-intersection.js": function (exports, module, require) {
							

							exports.__esModule = true;

							exports.default = function (startLinePoint, endLinePoint, rect) {
							    var res = [];
							    var intersection = null;

							    var rectLines = [{ x1: rect.left, y1: rect.top, x2: rect.left, y2: rect.bottom, isHorizontal: false }, // left-side
							    { x1: rect.right, y1: rect.top, x2: rect.right, y2: rect.bottom, isHorizontal: false }, // right-side
							    { x1: rect.left, y1: rect.top, x2: rect.right, y2: rect.top, isHorizontal: true }, // top-side
							    { x1: rect.left, y1: rect.bottom, x2: rect.right, y2: rect.bottom, isHorizontal: true // bottom-side
							    }];

							    for (var i = 0; i < rectLines.length; i++) {
							        intersection = findLineAndRectSideIntersection(startLinePoint, endLinePoint, rectLines[i]);

							        if (intersection) res.push(intersection);
							    }

							    if (!res.length) return null;

							    if (res.length === 1) return res[0];

							    // NOTE: if a line and rect have two intersection points, we return the nearest to startLinePoint
							    return getPointsDistance(startLinePoint, res[0]) < getPointsDistance(startLinePoint, res[1]) ? res[0] : res[1];
							};

							var _testcafeCore = require('../deps/testcafe-core');

							function getPointsDistance(start, end) {
							    return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
							}

							function findLineAndRectSideIntersection(startLinePoint, endLinePoint, rectSide) {
							    var intersectionX = null;
							    var haveIntersectionInBounds = null;

							    if (rectSide.isHorizontal) {
							        intersectionX = _testcafeCore.positionUtils.getLineXByYCoord(startLinePoint, endLinePoint, rectSide.y1);
							        haveIntersectionInBounds = intersectionX && intersectionX >= rectSide.x1 && intersectionX <= rectSide.x2;

							        return haveIntersectionInBounds ? { x: intersectionX, y: rectSide.y1 } : null;
							    }

							    var intersectionY = _testcafeCore.positionUtils.getLineYByXCoord(startLinePoint, endLinePoint, rectSide.x1);

							    haveIntersectionInBounds = intersectionY && intersectionY >= rectSide.y1 && intersectionY <= rectSide.y2;

							    return haveIntersectionInBounds ? { x: rectSide.x1, y: intersectionY } : null;
							}

							module.exports = exports['default'];
						},
						"is-letter.js": function (exports, module, require) {
							

							exports.__esModule = true;

							exports.default = function (key) {
							    return key.length === 1 && (key >= 'a' && key <= 'z' || key >= 'A' && key <= 'Z');
							};

							module.exports = exports['default'];
						},
						"key-identifier-maps.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = {
							    SPECIAL_KEYS: {
							        capslock: 'CapsLock',
							        delete: 'U+007F',
							        end: 'End',
							        enter: 'Enter',
							        esc: 'U+001B',
							        home: 'Home',
							        ins: 'Insert',
							        pagedown: 'PageDown',
							        pageup: 'PageUp',
							        space: 'U+0020',
							        tab: 'Tab',
							        alt: 'Alt',
							        ctrl: 'Control',
							        meta: 'Meta',
							        shift: 'Shift'
							    },

							    LETTERS: {
							        a: 'U+0041',
							        b: 'U+0042',
							        c: 'U+0043',
							        d: 'U+0044',
							        e: 'U+0045',
							        f: 'U+0046',
							        g: 'U+0047',
							        h: 'U+0048',
							        i: 'U+0049',
							        j: 'U+004A',
							        k: 'U+004B',
							        l: 'U+004C',
							        m: 'U+004D',
							        n: 'U+004E',
							        o: 'U+004F',
							        p: 'U+0050',
							        q: 'U+0051',
							        r: 'U+0052',
							        s: 'U+0053',
							        t: 'U+0054',
							        u: 'U+0055',
							        v: 'U+0056',
							        w: 'U+0057',
							        x: 'U+0058',
							        y: 'U+0059',
							        z: 'U+005A'
							    },

							    SYMBOLS: {
							        '0': 'U+0030',
							        '1': 'U+0031',
							        '2': 'U+0032',
							        '3': 'U+0033',
							        '4': 'U+0034',
							        '5': 'U+0035',
							        '6': 'U+0036',
							        '7': 'U+0037',
							        '8': 'U+0038',
							        '9': 'U+0039',
							        ' ': 'U+0020',
							        '!': 'U+0021',
							        '@': 'U+0040',
							        '#': 'U+0023',
							        '$': 'U+0024',
							        '%': 'U+0025',
							        '^': 'U+005E',
							        '*': 'U+002A',
							        '(': 'U+0028',
							        ')': 'U+0029',
							        '_': 'U+005F',
							        '|': 'U+007C',
							        '\\': 'U+005C',
							        '/': 'U+002F',
							        '?': 'U+003F',
							        '.': 'U+002E',
							        ',': 'U+002C',
							        '<': 'U+003C',
							        '>': 'U+003E',
							        '[': 'U+005B',
							        ']': 'U+005D',
							        '{': 'U+007B',
							        '}': 'U+007D',
							        '': 'U+00A7',
							        '': 'U+00B1',
							        '\'': 'U+0027',
							        '"': 'U+0022',
							        ':': 'U+003A',
							        ';': 'U+003B',
							        '`': 'U+0060',
							        '~': 'U+007E'
							    }
							};
							module.exports = exports['default'];
						},
						"key-identifier-required-for-event.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = keyIdentifierRequiredForEvent;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var browserUtils = _hammerhead2.default.utils.browser;

							function keyIdentifierRequiredForEvent() {
							    return browserUtils.isSafari || browserUtils.isChrome && browserUtils.version < 54;
							}
							module.exports = exports['default'];
						},
						"next-tick.js": function (exports, module, require) {
							

							exports.__esModule = true;

							exports.default = function () {
							    return new Promise(function (resolve) {
							        return nativeMethods.setTimeout.call(window, resolve, 0);
							    });
							};

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var Promise = _hammerhead2.default.Promise;
							var nativeMethods = _hammerhead2.default.nativeMethods;

							module.exports = exports['default'];
						},
						"offsets.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.getDefaultAutomationOffsets = getDefaultAutomationOffsets;
							exports.getOffsetOptions = getOffsetOptions;
							exports.getMoveAutomationOffsets = getMoveAutomationOffsets;

							var _testcafeCore = require('../deps/testcafe-core');

							var _getAutomationPoint = require('./get-automation-point');

							var _getAutomationPoint2 = _interopRequireDefault(_getAutomationPoint);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function calcOffset(size) {
							    var offset = size / 2;

							    return offset < 1 ? 0 : Math.round(offset);
							}

							function getDefaultAutomationOffsets(element) {
							    var rect = _testcafeCore.positionUtils.getElementRectangle(element);
							    var offsetX = calcOffset(rect.width);
							    var offsetY = calcOffset(rect.height);

							    return { offsetX: offsetX, offsetY: offsetY };
							}

							function getOffsetOptions(element, offsetX, offsetY) {
							    var defaultOffsets = getDefaultAutomationOffsets(element);

							    offsetX = typeof offsetX === 'number' ? Math.round(offsetX) : defaultOffsets.offsetX;
							    offsetY = typeof offsetY === 'number' ? Math.round(offsetY) : defaultOffsets.offsetY;

							    if (offsetX > 0 && offsetY > 0) return { offsetX: offsetX, offsetY: offsetY };

							    var dimensions = _testcafeCore.positionUtils.getClientDimensions(element);
							    var width = Math.round(Math.max(element.scrollWidth, dimensions.width));
							    var height = Math.round(Math.max(element.scrollHeight, dimensions.height));
							    var maxX = dimensions.scrollbar.right + dimensions.border.left + dimensions.border.right + width;
							    var maxY = dimensions.scrollbar.bottom + dimensions.border.top + dimensions.border.bottom + height;

							    return {
							        offsetX: offsetX < 0 ? maxX + offsetX : offsetX,
							        offsetY: offsetY < 0 ? maxY + offsetY : offsetY
							    };
							}

							function getMoveAutomationOffsets(element, offsetX, offsetY) {
							    var clickOnElement = _testcafeCore.positionUtils.containsOffset(element, offsetX, offsetY);

							    if (clickOnElement) return { offsetX: offsetX, offsetY: offsetY };

							    var actionPoint = (0, _getAutomationPoint2.default)(element, offsetX, offsetY);

							    return {
							        offsetX: actionPoint.x,
							        offsetY: actionPoint.y
							    };
							}
						},
						"screen-point-to-client.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.default = convertToClient;

							var _testcafeCore = require('../deps/testcafe-core');

							function convertToClient(element, point) {
							    var elementScroll = _testcafeCore.styleUtils.getElementScroll(element);

							    if (!/html/i.test(element.tagName) && _testcafeCore.styleUtils.hasScroll(element)) {
							        point.x -= elementScroll.left;
							        point.y -= elementScroll.top;
							    }

							    return _testcafeCore.positionUtils.offsetToClientCoords(point);
							}
							module.exports = exports['default'];
						},
						"utils.js": function (exports, module, require) {
							

							exports.__esModule = true;
							exports.focusAndSetSelection = focusAndSetSelection;
							exports.focusByRelatedElement = focusByRelatedElement;

							var _hammerhead = require('../deps/hammerhead');

							var _hammerhead2 = _interopRequireDefault(_hammerhead);

							var _testcafeCore = require('../deps/testcafe-core');

							var _testcafeCore2 = _interopRequireDefault(_testcafeCore);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							var Promise = _hammerhead2.default.Promise;
							var nativeMethods = _hammerhead2.default.nativeMethods;
							var browserUtils = _hammerhead2.default.utils.browser;
							var focusBlurSandbox = _hammerhead2.default.eventSandbox.focusBlur;

							var contentEditable = _testcafeCore2.default.contentEditable;
							var textSelection = _testcafeCore2.default.textSelection;
							var domUtils = _testcafeCore2.default.domUtils;

							function setCaretPosition(element, caretPos) {
							    var isTextEditable = domUtils.isTextEditableElement(element);
							    var isContentEditable = domUtils.isContentEditableElement(element);

							    if (isTextEditable || isContentEditable) {
							        if (isContentEditable && isNaN(parseInt(caretPos, 10))) textSelection.setCursorToLastVisiblePosition(element);else {
							            var position = isNaN(parseInt(caretPos, 10)) ? domUtils.getElementValue(element).length : caretPos;

							            textSelection.select(element, position, position);
							        }
							    } else {
							        // NOTE: if focus is called for a non-contentEditable element (like 'img' or 'button') inside
							        // a contentEditable parent, we should try to set the right window selection. Generally, we can't
							        // set the right window selection object because after the selection setup, the window.getSelection
							        // method returns a different object, which depends on the browser.
							        var contentEditableParent = contentEditable.findContentEditableParent(element);

							        if (contentEditableParent) textSelection.setCursorToLastVisiblePosition(contentEditable.findContentEditableParent(contentEditableParent));
							    }
							}

							function focusAndSetSelection(element, simulateFocus, caretPos) {
							    return new Promise(function (resolve) {
							        var activeElement = domUtils.getActiveElement();
							        var isTextEditable = domUtils.isTextEditableElement(element);
							        var labelWithForAttr = domUtils.closest(element, 'label[for]');
							        var isElementFocusable = domUtils.isElementFocusable(element);
							        var shouldFocusByRelatedElement = !domUtils.isElementFocusable(element) && labelWithForAttr;
							        var isContentEditable = domUtils.isContentEditableElement(element);
							        var elementForFocus = isContentEditable ? contentEditable.findContentEditableParent(element) : element;

							        // NOTE: in WebKit, if selection was never set in an input element, the focus method selects all the
							        // text in this element. So, we should call select before focus to set the caret to the first symbol.
							        if (simulateFocus && browserUtils.isWebKit && isTextEditable) textSelection.select(element, 0, 0);

							        // NOTE: we should call focus for the element related with a 'label' that has the 'for' attribute
							        if (shouldFocusByRelatedElement) {
							            if (simulateFocus) focusByRelatedElement(labelWithForAttr);

							            resolve();
							            return;
							        }

							        var focusWithSilentMode = !simulateFocus;
							        var focusForMouseEvent = true;
							        var preventScrolling = false;

							        if (!isElementFocusable && !isContentEditable) {
							            var curDocument = domUtils.findDocument(elementForFocus);
							            var curActiveElement = nativeMethods.documentActiveElementGetter.call(curDocument);
							            var isActiveElementBody = domUtils.isBodyElement(curActiveElement);
							            var focusableParent = domUtils.isBodyElement(elementForFocus) ? elementForFocus : domUtils.getFocusableParent(elementForFocus);

							            // NOTE: we should not call focus or blur if action element is
							            // not focusable and is child of active element (gh-889)
							            var elementChildOfActiveElement = curActiveElement && !isActiveElementBody && domUtils.containsElement(curActiveElement, elementForFocus);

							            if (elementChildOfActiveElement || isActiveElementBody && domUtils.isBodyElement(focusableParent)) {
							                resolve();
							                return;
							            }

							            elementForFocus = focusableParent || curDocument.body;
							            preventScrolling = true;
							        }

							        focusBlurSandbox.focus(elementForFocus, function () {
							            // NOTE: if a different element was focused in the focus event handler, we should not set selection
							            if (simulateFocus && !isContentEditable && element !== domUtils.getActiveElement()) {
							                resolve();
							                return;
							            }

							            setCaretPosition(element, caretPos);

							            // NOTE: we can't avoid the element being focused because the setSelection method leads to focusing.
							            // So, we just focus the previous active element without handlers if we don't need focus here
							            if (!simulateFocus && domUtils.getActiveElement() !== activeElement) focusBlurSandbox.focus(activeElement, resolve, true, true);else resolve();
							        }, focusWithSilentMode, focusForMouseEvent, false, preventScrolling);
							    });
							}

							function focusByRelatedElement(element) {
							    var labelWithForAttr = domUtils.closest(element, 'label[for]');

							    if (!labelWithForAttr) return;

							    var elementForFocus = document.getElementById(labelWithForAttr.getAttribute('for'));

							    if (!elementForFocus || domUtils.getActiveElement() === elementForFocus) return;

							    focusBlurSandbox.focus(elementForFocus, _testcafeCore2.default.noop, false, true);
							}
						}
					}
				}
			},
			"errors": {
				"test-run": {
					"index.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.SetNativeDialogHandlerCodeWrongTypeError = exports.UncaughtErrorInNativeDialogHandler = exports.NativeDialogNotHandledError = exports.CurrentIframeIsInvisibleError = exports.CurrentIframeNotFoundError = exports.CurrentIframeIsNotLoadedError = exports.ActionIframeIsNotLoadedError = exports.ActionElementNotIframeError = exports.RoleSwitchInRoleInitializerError = exports.InvalidElementScreenshotDimensionsError = exports.WindowDimensionsOverflowError = exports.ActionInvalidScrollTargetError = exports.ActionElementIsNotFileInputError = exports.ActionCanNotFindFileToUploadError = exports.ActionIncorrectKeysError = exports.ActionRootContainerNotFoundError = exports.ActionElementNonContentEditableError = exports.ActionElementNotTextAreaError = exports.ActionElementNonEditableError = exports.ActionAdditionalSelectorMatchesWrongNodeTypeError = exports.ActionAdditionalElementIsInvisibleError = exports.ActionAdditionalElementNotFoundError = exports.ActionSelectorMatchesWrongNodeTypeError = exports.ActionElementIsInvisibleError = exports.ActionElementNotFoundError = exports.ActionSelectorError = exports.ActionUnsupportedDeviceTypeError = exports.SetTestSpeedArgumentError = exports.ActionStringArrayElementError = exports.ActionStringOrStringArrayArgumentError = exports.ActionPositiveIntegerArgumentError = exports.ActionRoleArgumentError = exports.ActionIntegerArgumentError = exports.ActionNullableStringArgumentError = exports.ActionStringArgumentError = exports.ActionOptionsTypeError = exports.ActionSpeedOptionError = exports.ActionBooleanOptionError = exports.ActionPositiveIntegerOptionError = exports.ActionIntegerOptionError = exports.AssertionUnawaitedPromiseError = exports.AssertionExecutableArgumentError = exports.ExternalAssertionLibraryError = exports.UncaughtErrorInCustomDOMPropertyCode = exports.UncaughtErrorInClientFunctionCode = exports.UncaughtNonErrorObjectInTestCode = exports.UncaughtErrorInTestCode = exports.UncaughtErrorOnPage = exports.PageLoadError = exports.CantObtainInfoForElementSpecifiedBySelectorError = exports.InvalidSelectorResultError = exports.DomNodeClientFunctionResultError = exports.ClientFunctionExecutionInterruptionError = exports.MissingAwaitError = undefined;

						var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

						var _type = require('./type');

						var _type2 = _interopRequireDefault(_type);

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

						function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------


						// Base
						//--------------------------------------------------------------------
						var TestRunErrorBase = function TestRunErrorBase(type) {
						    _classCallCheck(this, TestRunErrorBase);

						    this.type = type;
						    this.isTestCafeError = true;
						    this.callsite = null;
						};

						var ActionOptionErrorBase = function (_TestRunErrorBase) {
						    _inherits(ActionOptionErrorBase, _TestRunErrorBase);

						    function ActionOptionErrorBase(type, optionName, actualValue) {
						        _classCallCheck(this, ActionOptionErrorBase);

						        var _this = _possibleConstructorReturn(this, _TestRunErrorBase.call(this, type));

						        _this.optionName = optionName;
						        _this.actualValue = actualValue;
						        return _this;
						    }

						    return ActionOptionErrorBase;
						}(TestRunErrorBase);

						var ActionArgumentErrorBase = function (_TestRunErrorBase2) {
						    _inherits(ActionArgumentErrorBase, _TestRunErrorBase2);

						    function ActionArgumentErrorBase(type, argumentName, actualValue) {
						        _classCallCheck(this, ActionArgumentErrorBase);

						        var _this2 = _possibleConstructorReturn(this, _TestRunErrorBase2.call(this, type));

						        _this2.argumentName = argumentName;
						        _this2.actualValue = actualValue;
						        return _this2;
						    }

						    return ActionArgumentErrorBase;
						}(TestRunErrorBase);

						// Synchronization errors
						//--------------------------------------------------------------------


						var MissingAwaitError = exports.MissingAwaitError = function (_TestRunErrorBase3) {
						    _inherits(MissingAwaitError, _TestRunErrorBase3);

						    function MissingAwaitError(callsite) {
						        _classCallCheck(this, MissingAwaitError);

						        var _this3 = _possibleConstructorReturn(this, _TestRunErrorBase3.call(this, _type2.default.missingAwaitError));

						        _this3.callsite = callsite;
						        return _this3;
						    }

						    return MissingAwaitError;
						}(TestRunErrorBase);

						// Client function errors
						//--------------------------------------------------------------------


						var ClientFunctionExecutionInterruptionError = exports.ClientFunctionExecutionInterruptionError = function (_TestRunErrorBase4) {
						    _inherits(ClientFunctionExecutionInterruptionError, _TestRunErrorBase4);

						    function ClientFunctionExecutionInterruptionError(instantiationCallsiteName) {
						        _classCallCheck(this, ClientFunctionExecutionInterruptionError);

						        var _this4 = _possibleConstructorReturn(this, _TestRunErrorBase4.call(this, _type2.default.clientFunctionExecutionInterruptionError));

						        _this4.instantiationCallsiteName = instantiationCallsiteName;
						        return _this4;
						    }

						    return ClientFunctionExecutionInterruptionError;
						}(TestRunErrorBase);

						var DomNodeClientFunctionResultError = exports.DomNodeClientFunctionResultError = function (_TestRunErrorBase5) {
						    _inherits(DomNodeClientFunctionResultError, _TestRunErrorBase5);

						    function DomNodeClientFunctionResultError(instantiationCallsiteName) {
						        _classCallCheck(this, DomNodeClientFunctionResultError);

						        var _this5 = _possibleConstructorReturn(this, _TestRunErrorBase5.call(this, _type2.default.domNodeClientFunctionResultError));

						        _this5.instantiationCallsiteName = instantiationCallsiteName;
						        return _this5;
						    }

						    return DomNodeClientFunctionResultError;
						}(TestRunErrorBase);

						// Selector errors
						//--------------------------------------------------------------------


						var InvalidSelectorResultError = exports.InvalidSelectorResultError = function (_TestRunErrorBase6) {
						    _inherits(InvalidSelectorResultError, _TestRunErrorBase6);

						    function InvalidSelectorResultError() {
						        _classCallCheck(this, InvalidSelectorResultError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase6.call(this, _type2.default.invalidSelectorResultError));
						    }

						    return InvalidSelectorResultError;
						}(TestRunErrorBase);

						var CantObtainInfoForElementSpecifiedBySelectorError = exports.CantObtainInfoForElementSpecifiedBySelectorError = function (_TestRunErrorBase7) {
						    _inherits(CantObtainInfoForElementSpecifiedBySelectorError, _TestRunErrorBase7);

						    function CantObtainInfoForElementSpecifiedBySelectorError(callsite) {
						        _classCallCheck(this, CantObtainInfoForElementSpecifiedBySelectorError);

						        var _this7 = _possibleConstructorReturn(this, _TestRunErrorBase7.call(this, _type2.default.cantObtainInfoForElementSpecifiedBySelectorError));

						        _this7.callsite = callsite;
						        return _this7;
						    }

						    return CantObtainInfoForElementSpecifiedBySelectorError;
						}(TestRunErrorBase);

						// Page errors
						//--------------------------------------------------------------------


						var PageLoadError = exports.PageLoadError = function (_TestRunErrorBase8) {
						    _inherits(PageLoadError, _TestRunErrorBase8);

						    function PageLoadError(errMsg) {
						        _classCallCheck(this, PageLoadError);

						        var _this8 = _possibleConstructorReturn(this, _TestRunErrorBase8.call(this, _type2.default.pageLoadError));

						        _this8.errMsg = errMsg;
						        return _this8;
						    }

						    return PageLoadError;
						}(TestRunErrorBase);

						// Uncaught errors
						//--------------------------------------------------------------------


						var UncaughtErrorOnPage = exports.UncaughtErrorOnPage = function (_TestRunErrorBase9) {
						    _inherits(UncaughtErrorOnPage, _TestRunErrorBase9);

						    function UncaughtErrorOnPage(errMsg, pageDestUrl) {
						        _classCallCheck(this, UncaughtErrorOnPage);

						        var _this9 = _possibleConstructorReturn(this, _TestRunErrorBase9.call(this, _type2.default.uncaughtErrorOnPage));

						        _this9.errMsg = errMsg;
						        _this9.pageDestUrl = pageDestUrl;
						        return _this9;
						    }

						    return UncaughtErrorOnPage;
						}(TestRunErrorBase);

						var UncaughtErrorInTestCode = exports.UncaughtErrorInTestCode = function (_TestRunErrorBase10) {
						    _inherits(UncaughtErrorInTestCode, _TestRunErrorBase10);

						    function UncaughtErrorInTestCode(err, callsite) {
						        _classCallCheck(this, UncaughtErrorInTestCode);

						        var _this10 = _possibleConstructorReturn(this, _TestRunErrorBase10.call(this, _type2.default.uncaughtErrorInTestCode));

						        _this10.errMsg = String(err);
						        _this10.callsite = callsite;
						        return _this10;
						    }

						    return UncaughtErrorInTestCode;
						}(TestRunErrorBase);

						var UncaughtNonErrorObjectInTestCode = exports.UncaughtNonErrorObjectInTestCode = function (_TestRunErrorBase11) {
						    _inherits(UncaughtNonErrorObjectInTestCode, _TestRunErrorBase11);

						    function UncaughtNonErrorObjectInTestCode(obj) {
						        _classCallCheck(this, UncaughtNonErrorObjectInTestCode);

						        var _this11 = _possibleConstructorReturn(this, _TestRunErrorBase11.call(this, _type2.default.uncaughtNonErrorObjectInTestCode));

						        _this11.objType = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
						        _this11.objStr = String(obj);
						        return _this11;
						    }

						    return UncaughtNonErrorObjectInTestCode;
						}(TestRunErrorBase);

						var UncaughtErrorInClientFunctionCode = exports.UncaughtErrorInClientFunctionCode = function (_TestRunErrorBase12) {
						    _inherits(UncaughtErrorInClientFunctionCode, _TestRunErrorBase12);

						    function UncaughtErrorInClientFunctionCode(instantiationCallsiteName, err) {
						        _classCallCheck(this, UncaughtErrorInClientFunctionCode);

						        var _this12 = _possibleConstructorReturn(this, _TestRunErrorBase12.call(this, _type2.default.uncaughtErrorInClientFunctionCode));

						        _this12.errMsg = String(err);
						        _this12.instantiationCallsiteName = instantiationCallsiteName;
						        return _this12;
						    }

						    return UncaughtErrorInClientFunctionCode;
						}(TestRunErrorBase);

						var UncaughtErrorInCustomDOMPropertyCode = exports.UncaughtErrorInCustomDOMPropertyCode = function (_TestRunErrorBase13) {
						    _inherits(UncaughtErrorInCustomDOMPropertyCode, _TestRunErrorBase13);

						    function UncaughtErrorInCustomDOMPropertyCode(instantiationCallsiteName, err, prop) {
						        _classCallCheck(this, UncaughtErrorInCustomDOMPropertyCode);

						        var _this13 = _possibleConstructorReturn(this, _TestRunErrorBase13.call(this, _type2.default.uncaughtErrorInCustomDOMPropertyCode, err, prop));

						        _this13.errMsg = String(err);
						        _this13.property = prop;
						        _this13.instantiationCallsiteName = instantiationCallsiteName;
						        return _this13;
						    }

						    return UncaughtErrorInCustomDOMPropertyCode;
						}(TestRunErrorBase);

						// Assertion errors
						//--------------------------------------------------------------------


						var ExternalAssertionLibraryError = exports.ExternalAssertionLibraryError = function (_TestRunErrorBase14) {
						    _inherits(ExternalAssertionLibraryError, _TestRunErrorBase14);

						    function ExternalAssertionLibraryError(err, callsite) {
						        _classCallCheck(this, ExternalAssertionLibraryError);

						        var _this14 = _possibleConstructorReturn(this, _TestRunErrorBase14.call(this, _type2.default.externalAssertionLibraryError));

						        _this14.errMsg = String(err);
						        _this14.callsite = callsite;
						        return _this14;
						    }

						    return ExternalAssertionLibraryError;
						}(TestRunErrorBase);

						var AssertionExecutableArgumentError = exports.AssertionExecutableArgumentError = function (_ActionArgumentErrorB) {
						    _inherits(AssertionExecutableArgumentError, _ActionArgumentErrorB);

						    function AssertionExecutableArgumentError(argumentName, argumentValue, errMsg) {
						        _classCallCheck(this, AssertionExecutableArgumentError);

						        var _this15 = _possibleConstructorReturn(this, _ActionArgumentErrorB.call(this, _type2.default.assertionExecutableArgumentError, argumentName, argumentValue));

						        _this15.errMsg = errMsg;
						        return _this15;
						    }

						    return AssertionExecutableArgumentError;
						}(ActionArgumentErrorBase);

						var AssertionUnawaitedPromiseError = exports.AssertionUnawaitedPromiseError = function (_TestRunErrorBase15) {
						    _inherits(AssertionUnawaitedPromiseError, _TestRunErrorBase15);

						    function AssertionUnawaitedPromiseError(callsite) {
						        _classCallCheck(this, AssertionUnawaitedPromiseError);

						        var _this16 = _possibleConstructorReturn(this, _TestRunErrorBase15.call(this, _type2.default.assertionUnawaitedPromiseError));

						        _this16.callsite = callsite;
						        return _this16;
						    }

						    return AssertionUnawaitedPromiseError;
						}(TestRunErrorBase);

						// Action parameters errors
						//--------------------------------------------------------------------
						// Options errors


						var ActionIntegerOptionError = exports.ActionIntegerOptionError = function (_ActionOptionErrorBas) {
						    _inherits(ActionIntegerOptionError, _ActionOptionErrorBas);

						    function ActionIntegerOptionError(optionName, actualValue) {
						        _classCallCheck(this, ActionIntegerOptionError);

						        return _possibleConstructorReturn(this, _ActionOptionErrorBas.call(this, _type2.default.actionIntegerOptionError, optionName, actualValue));
						    }

						    return ActionIntegerOptionError;
						}(ActionOptionErrorBase);

						var ActionPositiveIntegerOptionError = exports.ActionPositiveIntegerOptionError = function (_ActionOptionErrorBas2) {
						    _inherits(ActionPositiveIntegerOptionError, _ActionOptionErrorBas2);

						    function ActionPositiveIntegerOptionError(optionName, actualValue) {
						        _classCallCheck(this, ActionPositiveIntegerOptionError);

						        return _possibleConstructorReturn(this, _ActionOptionErrorBas2.call(this, _type2.default.actionPositiveIntegerOptionError, optionName, actualValue));
						    }

						    return ActionPositiveIntegerOptionError;
						}(ActionOptionErrorBase);

						var ActionBooleanOptionError = exports.ActionBooleanOptionError = function (_ActionOptionErrorBas3) {
						    _inherits(ActionBooleanOptionError, _ActionOptionErrorBas3);

						    function ActionBooleanOptionError(optionName, actualValue) {
						        _classCallCheck(this, ActionBooleanOptionError);

						        return _possibleConstructorReturn(this, _ActionOptionErrorBas3.call(this, _type2.default.actionBooleanOptionError, optionName, actualValue));
						    }

						    return ActionBooleanOptionError;
						}(ActionOptionErrorBase);

						var ActionSpeedOptionError = exports.ActionSpeedOptionError = function (_ActionOptionErrorBas4) {
						    _inherits(ActionSpeedOptionError, _ActionOptionErrorBas4);

						    function ActionSpeedOptionError(optionName, actualValue) {
						        _classCallCheck(this, ActionSpeedOptionError);

						        return _possibleConstructorReturn(this, _ActionOptionErrorBas4.call(this, _type2.default.actionSpeedOptionError, optionName, actualValue));
						    }

						    return ActionSpeedOptionError;
						}(ActionOptionErrorBase);

						var ActionOptionsTypeError = exports.ActionOptionsTypeError = function (_TestRunErrorBase16) {
						    _inherits(ActionOptionsTypeError, _TestRunErrorBase16);

						    function ActionOptionsTypeError(actualType) {
						        _classCallCheck(this, ActionOptionsTypeError);

						        var _this21 = _possibleConstructorReturn(this, _TestRunErrorBase16.call(this, _type2.default.actionOptionsTypeError));

						        _this21.actualType = actualType;
						        return _this21;
						    }

						    return ActionOptionsTypeError;
						}(TestRunErrorBase);

						// Arguments errors


						var ActionStringArgumentError = exports.ActionStringArgumentError = function (_ActionArgumentErrorB2) {
						    _inherits(ActionStringArgumentError, _ActionArgumentErrorB2);

						    function ActionStringArgumentError(argumentName, actualValue) {
						        _classCallCheck(this, ActionStringArgumentError);

						        return _possibleConstructorReturn(this, _ActionArgumentErrorB2.call(this, _type2.default.actionStringArgumentError, argumentName, actualValue));
						    }

						    return ActionStringArgumentError;
						}(ActionArgumentErrorBase);

						var ActionNullableStringArgumentError = exports.ActionNullableStringArgumentError = function (_ActionArgumentErrorB3) {
						    _inherits(ActionNullableStringArgumentError, _ActionArgumentErrorB3);

						    function ActionNullableStringArgumentError(argumentName, actualValue) {
						        _classCallCheck(this, ActionNullableStringArgumentError);

						        return _possibleConstructorReturn(this, _ActionArgumentErrorB3.call(this, _type2.default.actionNullableStringArgumentError, argumentName, actualValue));
						    }

						    return ActionNullableStringArgumentError;
						}(ActionArgumentErrorBase);

						var ActionIntegerArgumentError = exports.ActionIntegerArgumentError = function (_ActionArgumentErrorB4) {
						    _inherits(ActionIntegerArgumentError, _ActionArgumentErrorB4);

						    function ActionIntegerArgumentError(argumentName, actualValue) {
						        _classCallCheck(this, ActionIntegerArgumentError);

						        return _possibleConstructorReturn(this, _ActionArgumentErrorB4.call(this, _type2.default.actionIntegerArgumentError, argumentName, actualValue));
						    }

						    return ActionIntegerArgumentError;
						}(ActionArgumentErrorBase);

						var ActionRoleArgumentError = exports.ActionRoleArgumentError = function (_ActionArgumentErrorB5) {
						    _inherits(ActionRoleArgumentError, _ActionArgumentErrorB5);

						    function ActionRoleArgumentError(argumentName, actualValue) {
						        _classCallCheck(this, ActionRoleArgumentError);

						        return _possibleConstructorReturn(this, _ActionArgumentErrorB5.call(this, _type2.default.actionRoleArgumentError, argumentName, actualValue));
						    }

						    return ActionRoleArgumentError;
						}(ActionArgumentErrorBase);

						var ActionPositiveIntegerArgumentError = exports.ActionPositiveIntegerArgumentError = function (_ActionArgumentErrorB6) {
						    _inherits(ActionPositiveIntegerArgumentError, _ActionArgumentErrorB6);

						    function ActionPositiveIntegerArgumentError(argumentName, actualValue) {
						        _classCallCheck(this, ActionPositiveIntegerArgumentError);

						        return _possibleConstructorReturn(this, _ActionArgumentErrorB6.call(this, _type2.default.actionPositiveIntegerArgumentError, argumentName, actualValue));
						    }

						    return ActionPositiveIntegerArgumentError;
						}(ActionArgumentErrorBase);

						var ActionStringOrStringArrayArgumentError = exports.ActionStringOrStringArrayArgumentError = function (_ActionArgumentErrorB7) {
						    _inherits(ActionStringOrStringArrayArgumentError, _ActionArgumentErrorB7);

						    function ActionStringOrStringArrayArgumentError(argumentName, actualValue) {
						        _classCallCheck(this, ActionStringOrStringArrayArgumentError);

						        return _possibleConstructorReturn(this, _ActionArgumentErrorB7.call(this, _type2.default.actionStringOrStringArrayArgumentError, argumentName, actualValue));
						    }

						    return ActionStringOrStringArrayArgumentError;
						}(ActionArgumentErrorBase);

						var ActionStringArrayElementError = exports.ActionStringArrayElementError = function (_ActionArgumentErrorB8) {
						    _inherits(ActionStringArrayElementError, _ActionArgumentErrorB8);

						    function ActionStringArrayElementError(argumentName, actualValue, elementIndex) {
						        _classCallCheck(this, ActionStringArrayElementError);

						        var _this28 = _possibleConstructorReturn(this, _ActionArgumentErrorB8.call(this, _type2.default.actionStringArrayElementError, argumentName, actualValue));

						        _this28.elementIndex = elementIndex;
						        return _this28;
						    }

						    return ActionStringArrayElementError;
						}(ActionArgumentErrorBase);

						var SetTestSpeedArgumentError = exports.SetTestSpeedArgumentError = function (_ActionArgumentErrorB9) {
						    _inherits(SetTestSpeedArgumentError, _ActionArgumentErrorB9);

						    function SetTestSpeedArgumentError(argumentName, actualValue) {
						        _classCallCheck(this, SetTestSpeedArgumentError);

						        return _possibleConstructorReturn(this, _ActionArgumentErrorB9.call(this, _type2.default.setTestSpeedArgumentError, argumentName, actualValue));
						    }

						    return SetTestSpeedArgumentError;
						}(ActionArgumentErrorBase);

						var ActionUnsupportedDeviceTypeError = exports.ActionUnsupportedDeviceTypeError = function (_ActionArgumentErrorB10) {
						    _inherits(ActionUnsupportedDeviceTypeError, _ActionArgumentErrorB10);

						    function ActionUnsupportedDeviceTypeError(argumentName, argumentValue) {
						        _classCallCheck(this, ActionUnsupportedDeviceTypeError);

						        return _possibleConstructorReturn(this, _ActionArgumentErrorB10.call(this, _type2.default.actionUnsupportedDeviceTypeError, argumentName, argumentValue));
						    }

						    return ActionUnsupportedDeviceTypeError;
						}(ActionArgumentErrorBase);

						// Selector errors


						var ActionSelectorError = exports.ActionSelectorError = function (_TestRunErrorBase17) {
						    _inherits(ActionSelectorError, _TestRunErrorBase17);

						    function ActionSelectorError(selectorName, errMsg) {
						        _classCallCheck(this, ActionSelectorError);

						        var _this31 = _possibleConstructorReturn(this, _TestRunErrorBase17.call(this, _type2.default.actionSelectorError));

						        _this31.selectorName = selectorName;
						        _this31.errMsg = errMsg;
						        return _this31;
						    }

						    return ActionSelectorError;
						}(TestRunErrorBase);

						// Action execution errors
						//--------------------------------------------------------------------


						var ActionElementNotFoundError = exports.ActionElementNotFoundError = function (_TestRunErrorBase18) {
						    _inherits(ActionElementNotFoundError, _TestRunErrorBase18);

						    function ActionElementNotFoundError() {
						        _classCallCheck(this, ActionElementNotFoundError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase18.call(this, _type2.default.actionElementNotFoundError));
						    }

						    return ActionElementNotFoundError;
						}(TestRunErrorBase);

						var ActionElementIsInvisibleError = exports.ActionElementIsInvisibleError = function (_TestRunErrorBase19) {
						    _inherits(ActionElementIsInvisibleError, _TestRunErrorBase19);

						    function ActionElementIsInvisibleError() {
						        _classCallCheck(this, ActionElementIsInvisibleError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase19.call(this, _type2.default.actionElementIsInvisibleError));
						    }

						    return ActionElementIsInvisibleError;
						}(TestRunErrorBase);

						var ActionSelectorMatchesWrongNodeTypeError = exports.ActionSelectorMatchesWrongNodeTypeError = function (_TestRunErrorBase20) {
						    _inherits(ActionSelectorMatchesWrongNodeTypeError, _TestRunErrorBase20);

						    function ActionSelectorMatchesWrongNodeTypeError(nodeDescription) {
						        _classCallCheck(this, ActionSelectorMatchesWrongNodeTypeError);

						        var _this34 = _possibleConstructorReturn(this, _TestRunErrorBase20.call(this, _type2.default.actionSelectorMatchesWrongNodeTypeError));

						        _this34.nodeDescription = nodeDescription;
						        return _this34;
						    }

						    return ActionSelectorMatchesWrongNodeTypeError;
						}(TestRunErrorBase);

						var ActionAdditionalElementNotFoundError = exports.ActionAdditionalElementNotFoundError = function (_TestRunErrorBase21) {
						    _inherits(ActionAdditionalElementNotFoundError, _TestRunErrorBase21);

						    function ActionAdditionalElementNotFoundError(argumentName) {
						        _classCallCheck(this, ActionAdditionalElementNotFoundError);

						        var _this35 = _possibleConstructorReturn(this, _TestRunErrorBase21.call(this, _type2.default.actionAdditionalElementNotFoundError));

						        _this35.argumentName = argumentName;
						        return _this35;
						    }

						    return ActionAdditionalElementNotFoundError;
						}(TestRunErrorBase);

						var ActionAdditionalElementIsInvisibleError = exports.ActionAdditionalElementIsInvisibleError = function (_TestRunErrorBase22) {
						    _inherits(ActionAdditionalElementIsInvisibleError, _TestRunErrorBase22);

						    function ActionAdditionalElementIsInvisibleError(argumentName) {
						        _classCallCheck(this, ActionAdditionalElementIsInvisibleError);

						        var _this36 = _possibleConstructorReturn(this, _TestRunErrorBase22.call(this, _type2.default.actionAdditionalElementIsInvisibleError));

						        _this36.argumentName = argumentName;
						        return _this36;
						    }

						    return ActionAdditionalElementIsInvisibleError;
						}(TestRunErrorBase);

						var ActionAdditionalSelectorMatchesWrongNodeTypeError = exports.ActionAdditionalSelectorMatchesWrongNodeTypeError = function (_TestRunErrorBase23) {
						    _inherits(ActionAdditionalSelectorMatchesWrongNodeTypeError, _TestRunErrorBase23);

						    function ActionAdditionalSelectorMatchesWrongNodeTypeError(argumentName, nodeDescription) {
						        _classCallCheck(this, ActionAdditionalSelectorMatchesWrongNodeTypeError);

						        var _this37 = _possibleConstructorReturn(this, _TestRunErrorBase23.call(this, _type2.default.actionAdditionalSelectorMatchesWrongNodeTypeError));

						        _this37.argumentName = argumentName;
						        _this37.nodeDescription = nodeDescription;
						        return _this37;
						    }

						    return ActionAdditionalSelectorMatchesWrongNodeTypeError;
						}(TestRunErrorBase);

						var ActionElementNonEditableError = exports.ActionElementNonEditableError = function (_TestRunErrorBase24) {
						    _inherits(ActionElementNonEditableError, _TestRunErrorBase24);

						    function ActionElementNonEditableError() {
						        _classCallCheck(this, ActionElementNonEditableError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase24.call(this, _type2.default.actionElementNonEditableError));
						    }

						    return ActionElementNonEditableError;
						}(TestRunErrorBase);

						var ActionElementNotTextAreaError = exports.ActionElementNotTextAreaError = function (_TestRunErrorBase25) {
						    _inherits(ActionElementNotTextAreaError, _TestRunErrorBase25);

						    function ActionElementNotTextAreaError() {
						        _classCallCheck(this, ActionElementNotTextAreaError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase25.call(this, _type2.default.actionElementNotTextAreaError));
						    }

						    return ActionElementNotTextAreaError;
						}(TestRunErrorBase);

						var ActionElementNonContentEditableError = exports.ActionElementNonContentEditableError = function (_TestRunErrorBase26) {
						    _inherits(ActionElementNonContentEditableError, _TestRunErrorBase26);

						    function ActionElementNonContentEditableError(argumentName) {
						        _classCallCheck(this, ActionElementNonContentEditableError);

						        var _this40 = _possibleConstructorReturn(this, _TestRunErrorBase26.call(this, _type2.default.actionElementNonContentEditableError));

						        _this40.argumentName = argumentName;
						        return _this40;
						    }

						    return ActionElementNonContentEditableError;
						}(TestRunErrorBase);

						var ActionRootContainerNotFoundError = exports.ActionRootContainerNotFoundError = function (_TestRunErrorBase27) {
						    _inherits(ActionRootContainerNotFoundError, _TestRunErrorBase27);

						    function ActionRootContainerNotFoundError() {
						        _classCallCheck(this, ActionRootContainerNotFoundError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase27.call(this, _type2.default.actionRootContainerNotFoundError));
						    }

						    return ActionRootContainerNotFoundError;
						}(TestRunErrorBase);

						var ActionIncorrectKeysError = exports.ActionIncorrectKeysError = function (_TestRunErrorBase28) {
						    _inherits(ActionIncorrectKeysError, _TestRunErrorBase28);

						    function ActionIncorrectKeysError(argumentName) {
						        _classCallCheck(this, ActionIncorrectKeysError);

						        var _this42 = _possibleConstructorReturn(this, _TestRunErrorBase28.call(this, _type2.default.actionIncorrectKeysError));

						        _this42.argumentName = argumentName;
						        return _this42;
						    }

						    return ActionIncorrectKeysError;
						}(TestRunErrorBase);

						var ActionCanNotFindFileToUploadError = exports.ActionCanNotFindFileToUploadError = function (_TestRunErrorBase29) {
						    _inherits(ActionCanNotFindFileToUploadError, _TestRunErrorBase29);

						    function ActionCanNotFindFileToUploadError(filePaths) {
						        _classCallCheck(this, ActionCanNotFindFileToUploadError);

						        var _this43 = _possibleConstructorReturn(this, _TestRunErrorBase29.call(this, _type2.default.actionCanNotFindFileToUploadError));

						        _this43.filePaths = filePaths;
						        return _this43;
						    }

						    return ActionCanNotFindFileToUploadError;
						}(TestRunErrorBase);

						var ActionElementIsNotFileInputError = exports.ActionElementIsNotFileInputError = function (_TestRunErrorBase30) {
						    _inherits(ActionElementIsNotFileInputError, _TestRunErrorBase30);

						    function ActionElementIsNotFileInputError() {
						        _classCallCheck(this, ActionElementIsNotFileInputError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase30.call(this, _type2.default.actionElementIsNotFileInputError));
						    }

						    return ActionElementIsNotFileInputError;
						}(TestRunErrorBase);

						var ActionInvalidScrollTargetError = exports.ActionInvalidScrollTargetError = function (_TestRunErrorBase31) {
						    _inherits(ActionInvalidScrollTargetError, _TestRunErrorBase31);

						    function ActionInvalidScrollTargetError(scrollTargetXValid, scrollTargetYValid) {
						        _classCallCheck(this, ActionInvalidScrollTargetError);

						        var _this45 = _possibleConstructorReturn(this, _TestRunErrorBase31.call(this, _type2.default.actionInvalidScrollTargetError));

						        if (!scrollTargetXValid) {
						            if (!scrollTargetYValid) _this45.properties = 'scrollTargetX and scrollTargetY properties';else _this45.properties = 'scrollTargetX property';
						        } else _this45.properties = 'scrollTargetY property';
						        return _this45;
						    }

						    return ActionInvalidScrollTargetError;
						}(TestRunErrorBase);

						var WindowDimensionsOverflowError = exports.WindowDimensionsOverflowError = function (_TestRunErrorBase32) {
						    _inherits(WindowDimensionsOverflowError, _TestRunErrorBase32);

						    function WindowDimensionsOverflowError(callsite) {
						        _classCallCheck(this, WindowDimensionsOverflowError);

						        var _this46 = _possibleConstructorReturn(this, _TestRunErrorBase32.call(this, _type2.default.windowDimensionsOverflowError));

						        _this46.callsite = callsite;
						        return _this46;
						    }

						    return WindowDimensionsOverflowError;
						}(TestRunErrorBase);

						var InvalidElementScreenshotDimensionsError = exports.InvalidElementScreenshotDimensionsError = function (_TestRunErrorBase33) {
						    _inherits(InvalidElementScreenshotDimensionsError, _TestRunErrorBase33);

						    function InvalidElementScreenshotDimensionsError(width, height) {
						        _classCallCheck(this, InvalidElementScreenshotDimensionsError);

						        var _this47 = _possibleConstructorReturn(this, _TestRunErrorBase33.call(this, _type2.default.invalidElementScreenshotDimensionsError));

						        var widthIsInvalid = width <= 0;
						        var heightIsInvalid = height <= 0;

						        if (widthIsInvalid) {
						            if (heightIsInvalid) {
						                _this47.verb = 'are';
						                _this47.dimensions = 'width and height';
						            } else {
						                _this47.verb = 'is';
						                _this47.dimensions = 'width';
						            }
						        } else {
						            _this47.verb = 'is';
						            _this47.dimensions = 'height';
						        }
						        return _this47;
						    }

						    return InvalidElementScreenshotDimensionsError;
						}(TestRunErrorBase);

						var RoleSwitchInRoleInitializerError = exports.RoleSwitchInRoleInitializerError = function (_TestRunErrorBase34) {
						    _inherits(RoleSwitchInRoleInitializerError, _TestRunErrorBase34);

						    function RoleSwitchInRoleInitializerError(callsite) {
						        _classCallCheck(this, RoleSwitchInRoleInitializerError);

						        var _this48 = _possibleConstructorReturn(this, _TestRunErrorBase34.call(this, _type2.default.roleSwitchInRoleInitializerError));

						        _this48.callsite = callsite;
						        return _this48;
						    }

						    return RoleSwitchInRoleInitializerError;
						}(TestRunErrorBase);

						// Iframe errors


						var ActionElementNotIframeError = exports.ActionElementNotIframeError = function (_TestRunErrorBase35) {
						    _inherits(ActionElementNotIframeError, _TestRunErrorBase35);

						    function ActionElementNotIframeError() {
						        _classCallCheck(this, ActionElementNotIframeError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase35.call(this, _type2.default.actionElementNotIframeError));
						    }

						    return ActionElementNotIframeError;
						}(TestRunErrorBase);

						var ActionIframeIsNotLoadedError = exports.ActionIframeIsNotLoadedError = function (_TestRunErrorBase36) {
						    _inherits(ActionIframeIsNotLoadedError, _TestRunErrorBase36);

						    function ActionIframeIsNotLoadedError() {
						        _classCallCheck(this, ActionIframeIsNotLoadedError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase36.call(this, _type2.default.actionIframeIsNotLoadedError));
						    }

						    return ActionIframeIsNotLoadedError;
						}(TestRunErrorBase);

						var CurrentIframeIsNotLoadedError = exports.CurrentIframeIsNotLoadedError = function (_TestRunErrorBase37) {
						    _inherits(CurrentIframeIsNotLoadedError, _TestRunErrorBase37);

						    function CurrentIframeIsNotLoadedError() {
						        _classCallCheck(this, CurrentIframeIsNotLoadedError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase37.call(this, _type2.default.currentIframeIsNotLoadedError));
						    }

						    return CurrentIframeIsNotLoadedError;
						}(TestRunErrorBase);

						var CurrentIframeNotFoundError = exports.CurrentIframeNotFoundError = function (_TestRunErrorBase38) {
						    _inherits(CurrentIframeNotFoundError, _TestRunErrorBase38);

						    function CurrentIframeNotFoundError() {
						        _classCallCheck(this, CurrentIframeNotFoundError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase38.call(this, _type2.default.currentIframeNotFoundError));
						    }

						    return CurrentIframeNotFoundError;
						}(TestRunErrorBase);

						var CurrentIframeIsInvisibleError = exports.CurrentIframeIsInvisibleError = function (_TestRunErrorBase39) {
						    _inherits(CurrentIframeIsInvisibleError, _TestRunErrorBase39);

						    function CurrentIframeIsInvisibleError() {
						        _classCallCheck(this, CurrentIframeIsInvisibleError);

						        return _possibleConstructorReturn(this, _TestRunErrorBase39.call(this, _type2.default.currentIframeIsInvisibleError));
						    }

						    return CurrentIframeIsInvisibleError;
						}(TestRunErrorBase);

						// Native dialog errors


						var NativeDialogNotHandledError = exports.NativeDialogNotHandledError = function (_TestRunErrorBase40) {
						    _inherits(NativeDialogNotHandledError, _TestRunErrorBase40);

						    function NativeDialogNotHandledError(dialogType, url) {
						        _classCallCheck(this, NativeDialogNotHandledError);

						        var _this54 = _possibleConstructorReturn(this, _TestRunErrorBase40.call(this, _type2.default.nativeDialogNotHandledError));

						        _this54.dialogType = dialogType;
						        _this54.pageUrl = url;
						        return _this54;
						    }

						    return NativeDialogNotHandledError;
						}(TestRunErrorBase);

						var UncaughtErrorInNativeDialogHandler = exports.UncaughtErrorInNativeDialogHandler = function (_TestRunErrorBase41) {
						    _inherits(UncaughtErrorInNativeDialogHandler, _TestRunErrorBase41);

						    function UncaughtErrorInNativeDialogHandler(dialogType, errMsg, url) {
						        _classCallCheck(this, UncaughtErrorInNativeDialogHandler);

						        var _this55 = _possibleConstructorReturn(this, _TestRunErrorBase41.call(this, _type2.default.uncaughtErrorInNativeDialogHandler));

						        _this55.dialogType = dialogType;
						        _this55.errMsg = errMsg;
						        _this55.pageUrl = url;
						        return _this55;
						    }

						    return UncaughtErrorInNativeDialogHandler;
						}(TestRunErrorBase);

						var SetNativeDialogHandlerCodeWrongTypeError = exports.SetNativeDialogHandlerCodeWrongTypeError = function (_TestRunErrorBase42) {
						    _inherits(SetNativeDialogHandlerCodeWrongTypeError, _TestRunErrorBase42);

						    function SetNativeDialogHandlerCodeWrongTypeError(actualType) {
						        _classCallCheck(this, SetNativeDialogHandlerCodeWrongTypeError);

						        var _this56 = _possibleConstructorReturn(this, _TestRunErrorBase42.call(this, _type2.default.setNativeDialogHandlerCodeWrongTypeError));

						        _this56.actualType = actualType;
						        return _this56;
						    }

						    return SetNativeDialogHandlerCodeWrongTypeError;
						}(TestRunErrorBase);
					},
					"type.js": function (exports, module, require) {
						

						exports.__esModule = true;
						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						exports.default = {
						    uncaughtErrorOnPage: 'uncaughtErrorOnPage',
						    uncaughtErrorInTestCode: 'uncaughtErrorInTestCode',
						    uncaughtNonErrorObjectInTestCode: 'uncaughtNonErrorObjectInTestCode',
						    uncaughtErrorInClientFunctionCode: 'uncaughtErrorInClientFunctionCode',
						    uncaughtErrorInCustomDOMPropertyCode: 'uncaughtErrorInCustomDOMPropertyCode',
						    missingAwaitError: 'missingAwaitError',
						    actionIntegerOptionError: 'actionIntegerOptionError',
						    actionPositiveIntegerOptionError: 'actionPositiveIntegerOptionError',
						    actionBooleanOptionError: 'actionBooleanOptionError',
						    actionSpeedOptionError: 'actionSpeedOptionError',
						    actionOptionsTypeError: 'actionOptionsTypeError',
						    actionStringArgumentError: 'actionStringArgumentError',
						    actionNullableStringArgumentError: 'actionNullableStringArgumentError',
						    actionStringOrStringArrayArgumentError: 'actionStringOrStringArrayArgumentError',
						    actionStringArrayElementError: 'actionStringArrayElementError',
						    actionIntegerArgumentError: 'actionIntegerArgumentError',
						    actionRoleArgumentError: 'actionRoleArgumentError',
						    actionPositiveIntegerArgumentError: 'actionPositiveIntegerArgumentError',
						    actionSelectorError: 'actionSelectorError',
						    actionElementNotFoundError: 'actionElementNotFoundError',
						    actionElementIsInvisibleError: 'actionElementIsInvisibleError',
						    actionSelectorMatchesWrongNodeTypeError: 'actionSelectorMatchesWrongNodeTypeError',
						    actionAdditionalElementNotFoundError: 'actionAdditionalElementNotFoundError',
						    actionAdditionalElementIsInvisibleError: 'actionAdditionalElementIsInvisibleError',
						    actionAdditionalSelectorMatchesWrongNodeTypeError: 'actionAdditionalSelectorMatchesWrongNodeTypeError',
						    actionElementNonEditableError: 'actionElementNonEditableError',
						    actionElementNotTextAreaError: 'actionElementNotTextAreaError',
						    actionElementNonContentEditableError: 'actionElementNonContentEditableError',
						    actionElementIsNotFileInputError: 'actionElementIsNotFileInputError',
						    actionRootContainerNotFoundError: 'actionRootContainerNotFoundError',
						    actionIncorrectKeysError: 'actionIncorrectKeysError',
						    actionCanNotFindFileToUploadError: 'actionCanNotFindFileToUploadError',
						    actionUnsupportedDeviceTypeError: 'actionUnsupportedDeviceTypeError',
						    actionIframeIsNotLoadedError: 'actionIframeIsNotLoadedError',
						    actionElementNotIframeError: 'actionElementNotIframeError',
						    actionInvalidScrollTargetError: 'actionInvalidScrollTargetError',
						    currentIframeIsNotLoadedError: 'currentIframeIsNotLoadedError',
						    currentIframeNotFoundError: 'currentIframeNotFoundError',
						    currentIframeIsInvisibleError: 'currentIframeIsInvisibleError',
						    nativeDialogNotHandledError: 'nativeDialogNotHandledError',
						    uncaughtErrorInNativeDialogHandler: 'uncaughtErrorInNativeDialogHandler',
						    setTestSpeedArgumentError: 'setTestSpeedArgumentError',
						    setNativeDialogHandlerCodeWrongTypeError: 'setNativeDialogHandlerCodeWrongTypeError',
						    clientFunctionExecutionInterruptionError: 'clientFunctionExecutionInterruptionError',
						    domNodeClientFunctionResultError: 'domNodeClientFunctionResultError',
						    invalidSelectorResultError: 'invalidSelectorResultError',
						    cantObtainInfoForElementSpecifiedBySelectorError: 'cantObtainInfoForElementSpecifiedBySelectorError',
						    externalAssertionLibraryError: 'externalAssertionLibraryError',
						    pageLoadError: 'pageLoadError',
						    windowDimensionsOverflowError: 'windowDimensionsOverflowError',
						    invalidElementScreenshotDimensionsError: 'invalidElementScreenshotDimensionsError',
						    roleSwitchInRoleInitializerError: 'roleSwitchInRoleInitializerError',
						    assertionExecutableArgumentError: 'assertionExecutableArgumentError',
						    assertionUnawaitedPromiseError: 'assertionUnawaitedPromiseError'
						};
						module.exports = exports['default'];
					}
				}
			},
			"test-run": {
				"commands": {
					"options.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.AssertionOptions = exports.ResizeToFitDeviceOptions = exports.DragToElementOptions = exports.TypeOptions = exports.MoveOptions = exports.ClickOptions = exports.MouseOptions = exports.ElementScreenshotOptions = exports.ScrollOptions = exports.OffsetOptions = exports.ActionOptions = exports.speedOption = exports.booleanOption = exports.positiveIntegerOption = exports.integerOption = undefined;

						var _assignable = require('../../utils/assignable');

						var _assignable2 = _interopRequireDefault(_assignable);

						var _factories = require('./validations/factories');

						var _testRun = require('../../errors/test-run');

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

						function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

						function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						var integerOption = exports.integerOption = (0, _factories.createIntegerValidator)(_testRun.ActionIntegerOptionError);
						var positiveIntegerOption = exports.positiveIntegerOption = (0, _factories.createPositiveIntegerValidator)(_testRun.ActionPositiveIntegerOptionError);
						var booleanOption = exports.booleanOption = (0, _factories.createBooleanValidator)(_testRun.ActionBooleanOptionError);
						var speedOption = exports.speedOption = (0, _factories.createSpeedValidator)(_testRun.ActionSpeedOptionError);

						// Acitons

						var ActionOptions = exports.ActionOptions = function (_Assignable) {
						    _inherits(ActionOptions, _Assignable);

						    function ActionOptions(obj, validate) {
						        _classCallCheck(this, ActionOptions);

						        var _this = _possibleConstructorReturn(this, _Assignable.call(this));

						        _this.speed = null;

						        _this._assignFrom(obj, validate);
						        return _this;
						    }

						    ActionOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return [{ name: 'speed', type: speedOption }];
						    };

						    return ActionOptions;
						}(_assignable2.default);

						// Offset


						var OffsetOptions = exports.OffsetOptions = function (_ActionOptions) {
						    _inherits(OffsetOptions, _ActionOptions);

						    function OffsetOptions(obj, validate) {
						        _classCallCheck(this, OffsetOptions);

						        var _this2 = _possibleConstructorReturn(this, _ActionOptions.call(this));

						        _this2.offsetX = null;
						        _this2.offsetY = null;

						        _this2._assignFrom(obj, validate);
						        return _this2;
						    }

						    OffsetOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return _ActionOptions.prototype._getAssignableProperties.call(this).concat([{ name: 'offsetX', type: integerOption }, { name: 'offsetY', type: integerOption }]);
						    };

						    return OffsetOptions;
						}(ActionOptions);

						var ScrollOptions = exports.ScrollOptions = function (_OffsetOptions) {
						    _inherits(ScrollOptions, _OffsetOptions);

						    function ScrollOptions(obj, validate) {
						        _classCallCheck(this, ScrollOptions);

						        var _this3 = _possibleConstructorReturn(this, _OffsetOptions.call(this));

						        _this3.scrollToCenter = false;
						        _this3.skipParentFrames = false;

						        _this3._assignFrom(obj, validate);
						        return _this3;
						    }

						    ScrollOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return _OffsetOptions.prototype._getAssignableProperties.call(this).concat([{ name: 'scrollToCenter', type: booleanOption }, { name: 'skipParentFrames', type: booleanOption }]);
						    };

						    return ScrollOptions;
						}(OffsetOptions);

						// Element Screenshot


						var ElementScreenshotOptions = exports.ElementScreenshotOptions = function (_ActionOptions2) {
						    _inherits(ElementScreenshotOptions, _ActionOptions2);

						    function ElementScreenshotOptions(obj, validate) {
						        _classCallCheck(this, ElementScreenshotOptions);

						        var _this4 = _possibleConstructorReturn(this, _ActionOptions2.call(this));

						        _this4.scrollTargetX = null;
						        _this4.scrollTargetY = null;
						        _this4.includeMargins = false;
						        _this4.includeBorders = true;
						        _this4.includePaddings = true;

						        _this4.crop = {
						            left: null,
						            right: null,
						            top: null,
						            bottom: null
						        };

						        _this4._assignFrom(obj, validate);
						        return _this4;
						    }

						    ElementScreenshotOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return _ActionOptions2.prototype._getAssignableProperties.call(this).concat([{ name: 'scrollTargetX', type: integerOption }, { name: 'scrollTargetY', type: integerOption }, { name: 'crop.left', type: integerOption }, { name: 'crop.right', type: integerOption }, { name: 'crop.top', type: integerOption }, { name: 'crop.bottom', type: integerOption }, { name: 'includeMargins', type: booleanOption }, { name: 'includeBorders', type: booleanOption }, { name: 'includePaddings', type: booleanOption }]);
						    };

						    return ElementScreenshotOptions;
						}(ActionOptions);

						// Mouse


						var MouseOptions = exports.MouseOptions = function (_OffsetOptions2) {
						    _inherits(MouseOptions, _OffsetOptions2);

						    function MouseOptions(obj, validate) {
						        _classCallCheck(this, MouseOptions);

						        var _this5 = _possibleConstructorReturn(this, _OffsetOptions2.call(this));

						        _this5.modifiers = {
						            ctrl: false,
						            alt: false,
						            shift: false,
						            meta: false
						        };

						        _this5._assignFrom(obj, validate);
						        return _this5;
						    }

						    MouseOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return _OffsetOptions2.prototype._getAssignableProperties.call(this).concat([{ name: 'modifiers.ctrl', type: booleanOption }, { name: 'modifiers.alt', type: booleanOption }, { name: 'modifiers.shift', type: booleanOption }, { name: 'modifiers.meta', type: booleanOption }]);
						    };

						    return MouseOptions;
						}(OffsetOptions);

						// Click


						var ClickOptions = exports.ClickOptions = function (_MouseOptions) {
						    _inherits(ClickOptions, _MouseOptions);

						    function ClickOptions(obj, validate) {
						        _classCallCheck(this, ClickOptions);

						        var _this6 = _possibleConstructorReturn(this, _MouseOptions.call(this));

						        _this6.caretPos = null;

						        _this6._assignFrom(obj, validate);
						        return _this6;
						    }

						    ClickOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return _MouseOptions.prototype._getAssignableProperties.call(this).concat([{ name: 'caretPos', type: positiveIntegerOption }]);
						    };

						    return ClickOptions;
						}(MouseOptions);

						// Move


						var MoveOptions = exports.MoveOptions = function (_MouseOptions2) {
						    _inherits(MoveOptions, _MouseOptions2);

						    function MoveOptions(obj, validate) {
						        _classCallCheck(this, MoveOptions);

						        var _this7 = _possibleConstructorReturn(this, _MouseOptions2.call(this));

						        _this7.speed = null;
						        _this7.minMovingTime = null;
						        _this7.holdLeftButton = false;
						        _this7.skipScrolling = false;

						        _this7._assignFrom(obj, validate);
						        return _this7;
						    }

						    MoveOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return _MouseOptions2.prototype._getAssignableProperties.call(this).concat([{ name: 'speed' }, { name: 'minMovingTime' }, { name: 'holdLeftButton' }, { name: 'skipScrolling', type: booleanOption }]);
						    };

						    return MoveOptions;
						}(MouseOptions);

						// Type


						var TypeOptions = exports.TypeOptions = function (_ClickOptions) {
						    _inherits(TypeOptions, _ClickOptions);

						    function TypeOptions(obj, validate) {
						        _classCallCheck(this, TypeOptions);

						        var _this8 = _possibleConstructorReturn(this, _ClickOptions.call(this));

						        _this8.replace = false;
						        _this8.paste = false;

						        _this8._assignFrom(obj, validate);
						        return _this8;
						    }

						    TypeOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return _ClickOptions.prototype._getAssignableProperties.call(this).concat([{ name: 'replace', type: booleanOption }, { name: 'paste', type: booleanOption }]);
						    };

						    return TypeOptions;
						}(ClickOptions);

						// DragToElement


						var DragToElementOptions = exports.DragToElementOptions = function (_MouseOptions3) {
						    _inherits(DragToElementOptions, _MouseOptions3);

						    function DragToElementOptions(obj, validate) {
						        _classCallCheck(this, DragToElementOptions);

						        var _this9 = _possibleConstructorReturn(this, _MouseOptions3.call(this, obj, validate));

						        _this9.destinationOffsetX = null;
						        _this9.destinationOffsetY = null;

						        _this9._assignFrom(obj, validate);
						        return _this9;
						    }

						    DragToElementOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return _MouseOptions3.prototype._getAssignableProperties.call(this).concat([{ name: 'destinationOffsetX', type: integerOption }, { name: 'destinationOffsetY', type: integerOption }]);
						    };

						    return DragToElementOptions;
						}(MouseOptions);

						//ResizeToFitDevice


						var ResizeToFitDeviceOptions = exports.ResizeToFitDeviceOptions = function (_Assignable2) {
						    _inherits(ResizeToFitDeviceOptions, _Assignable2);

						    function ResizeToFitDeviceOptions(obj, validate) {
						        _classCallCheck(this, ResizeToFitDeviceOptions);

						        var _this10 = _possibleConstructorReturn(this, _Assignable2.call(this));

						        _this10.portraitOrientation = false;

						        _this10._assignFrom(obj, validate);
						        return _this10;
						    }

						    ResizeToFitDeviceOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return [{ name: 'portraitOrientation', type: booleanOption }];
						    };

						    return ResizeToFitDeviceOptions;
						}(_assignable2.default);

						//Assertion


						var AssertionOptions = exports.AssertionOptions = function (_Assignable3) {
						    _inherits(AssertionOptions, _Assignable3);

						    function AssertionOptions(obj, validate) {
						        _classCallCheck(this, AssertionOptions);

						        var _this11 = _possibleConstructorReturn(this, _Assignable3.call(this));

						        _this11.timeout = void 0;
						        _this11.allowUnawaitedPromise = false;

						        _this11._assignFrom(obj, validate);
						        return _this11;
						    }

						    AssertionOptions.prototype._getAssignableProperties = function _getAssignableProperties() {
						        return [{ name: 'timeout', type: positiveIntegerOption }, { name: 'allowUnawaitedPromise', type: booleanOption }];
						    };

						    return AssertionOptions;
						}(_assignable2.default);
					},
					"validations": {
						"factories.js": function (exports, module, require) {
							

							exports.__esModule = true;

							var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

							exports.createIntegerValidator = createIntegerValidator;
							exports.createPositiveIntegerValidator = createPositiveIntegerValidator;
							exports.createBooleanValidator = createBooleanValidator;
							exports.createSpeedValidator = createSpeedValidator;
							// -------------------------------------------------------------
							// WARNING: this file is used by both the client and the server.
							// Do not use any browser or node-specific API!
							// -------------------------------------------------------------

							function createIntegerValidator(ErrorCtor) {
							    return function (name, val) {
							        var valType = typeof val === 'undefined' ? 'undefined' : _typeof(val);

							        if (valType !== 'number') throw new ErrorCtor(name, valType);

							        var isInteger = !isNaN(val) && isFinite(val) && val === Math.floor(val);

							        if (!isInteger) throw new ErrorCtor(name, val);
							    };
							}

							function createPositiveIntegerValidator(ErrorCtor) {
							    var integerValidator = createIntegerValidator(ErrorCtor);

							    return function (name, val) {
							        integerValidator(name, val);

							        if (val < 0) throw new ErrorCtor(name, val);
							    };
							}

							function createBooleanValidator(ErrorCtor) {
							    return function (name, val) {
							        var valType = typeof val === 'undefined' ? 'undefined' : _typeof(val);

							        if (valType !== 'boolean') throw new ErrorCtor(name, valType);
							    };
							}

							function createSpeedValidator(ErrorCtor) {
							    return function (name, val) {
							        var valType = typeof val === 'undefined' ? 'undefined' : _typeof(val);

							        if (valType !== 'number') throw new ErrorCtor(name, valType);

							        if (isNaN(val) || val < 0.01 || val > 1) throw new ErrorCtor(name, val);
							    };
							}
						}
					}
				}
			},
			"utils": {
				"assignable.js": function (exports, module, require) {
					

					exports.__esModule = true;

					function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					var Assignable = function () {
					    function Assignable() {
					        _classCallCheck(this, Assignable);
					    }

					    Assignable.prototype._getAssignableProperties = function _getAssignableProperties() {
					        throw new Error('Not implemented');
					    };

					    Assignable.prototype._assignFrom = function _assignFrom(obj, validate) {
					        if (!obj) return;

					        var props = this._getAssignableProperties();

					        for (var i = 0; i < props.length; i++) {
					            var _props$i = props[i],
					                name = _props$i.name,
					                type = _props$i.type,
					                required = _props$i.required,
					                init = _props$i.init;


					            var path = name.split('.');
					            var lastIdx = path.length - 1;
					            var last = path[lastIdx];
					            var srcObj = obj;
					            var destObj = this;

					            for (var j = 0; j < lastIdx && srcObj && destObj; j++) {
					                srcObj = srcObj[path[j]];
					                destObj = destObj[path[j]];
					            }

					            if (srcObj && destObj) {
					                var srcVal = srcObj[last];

					                if (srcVal !== void 0 || required) {
					                    if (validate && type) type(name, srcVal);

					                    destObj[last] = init ? init(name, srcVal) : srcVal;
					                }
					            }
					        }
					    };

					    return Assignable;
					}();

					exports.default = Assignable;
					module.exports = exports['default'];
				}
			}
		}
	}
})("testcafe-phoenix/src/client/automation/index");

    }

    initTestCafeAutomation(window);
})();
