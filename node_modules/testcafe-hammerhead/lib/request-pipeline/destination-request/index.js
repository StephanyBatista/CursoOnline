'use strict';

exports.__esModule = true;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _lodash = require('lodash');

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _agent = require('./agent');

var requestAgent = _interopRequireWildcard(_agent);

var _events = require('events');

var _webauth = require('webauth');

var _connectionResetGuard = require('../connection-reset-guard');

var _connectionResetGuard2 = _interopRequireDefault(_connectionResetGuard);

var _messages = require('../../messages');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// HACK: Ignore SSL auth. The rejectUnauthorized option in the https.request method
// doesn't work (see: https://github.com/mikeal/request/issues/418).
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

var TUNNELING_SOCKET_ERR_RE = /tunneling socket could not be established/i;
var TUNNELING_AUTHORIZE_ERR_RE = /statusCode=407/i;
var SOCKET_HANG_UP_ERR_RE = /socket hang up/i;
var IS_DNS_ERR_MSG_RE = /ECONNREFUSED|ENOTFOUND|EPROTO/;
var IS_DNS_ERR_CODE_RE = /ECONNRESET/;

// NOTE: Starting from 8.6 version, Node.js changes behavior related with sending requests
// to sites using SSL2 and SSL3 protocol versions. It affects the https core module
// and can break a proxying of some sites. This is why, we are forced to use the special hack.
// For details, see https://github.com/nodejs/node/issues/16196
var IS_NODE_VERSION_GREATER_THAN_8_5 = _semver2.default.gt(process.version, '8.5.0');

// DestinationRequest

var DestinationRequest = function (_EventEmitter) {
    _inherits(DestinationRequest, _EventEmitter);

    function DestinationRequest(opts) {
        _classCallCheck(this, DestinationRequest);

        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

        _this.req = null;
        _this.hasResponse = false;
        _this.credentialsSent = false;
        _this.aborted = false;
        _this.opts = opts;
        _this.isHttps = opts.protocol === 'https:';
        _this.protocolInterface = _this.isHttps ? _https2.default : _http2.default;

        // NOTE: Ignore SSL auth.
        if (_this.isHttps) {
            opts.rejectUnauthorized = false;

            if (IS_NODE_VERSION_GREATER_THAN_8_5) opts.ecdhCurve = 'auto';
        }

        requestAgent.assign(_this.opts);
        _this._send();
        return _this;
    }

    DestinationRequest.prototype._send = function _send(waitForData) {
        var _this2 = this;

        (0, _connectionResetGuard2.default)(function () {
            var timeout = _this2.opts.isXhr ? DestinationRequest.XHR_TIMEOUT : DestinationRequest.TIMEOUT;

            _this2.req = _this2.protocolInterface.request(_this2.opts, function (res) {
                if (waitForData) {
                    res.on('data', _lodash.noop);
                    res.once('end', function () {
                        return _this2._onResponse(res);
                    });
                }
            });

            if (!waitForData) _this2.req.on('response', function (res) {
                return _this2._onResponse(res);
            });

            _this2.req.on('error', function (err) {
                return _this2._onError(err);
            });
            _this2.req.on('upgrade', function (res, socket, head) {
                return _this2._onUpgrade(res, socket, head);
            });
            _this2.req.setTimeout(timeout, function () {
                return _this2._onTimeout();
            });
            _this2.req.write(_this2.opts.body);
            _this2.req.end();
        });
    };

    DestinationRequest.prototype._shouldResendWithCredentials = function _shouldResendWithCredentials(res) {
        if (res.statusCode === 401 && this.opts.credentials) {
            var authInfo = (0, _webauth.getAuthInfo)(res);

            // NOTE: If we get 401 status code after credentials are sent, we should stop trying to authenticate.
            if (!authInfo.isChallengeMessage && this.credentialsSent) return false;

            return authInfo.canAuthorize;
        }

        return false;
    };

    DestinationRequest.prototype._onResponse = function _onResponse(res) {
        if (this._shouldResendWithCredentials(res)) this._resendWithCredentials(res);else if (!this.isHttps && this.opts.proxy && res.statusCode === 407) this._fatalError(_messages.MESSAGE.cantAuthorizeToProxy, this.opts.proxy.host);else {
            this.hasResponse = true;
            this.emit('response', res);
        }
    };

    DestinationRequest.prototype._onUpgrade = function _onUpgrade(res, socket, head) {
        if (head && head.length) socket.unshift(head);

        this._onResponse(res);
    };

    DestinationRequest.prototype._resendWithCredentials = function () {
        var _ref = _asyncToGenerator(function* (res) {
            (0, _webauth.addCredentials)(this.opts.credentials, this.opts, res, this.protocolInterface);
            this.credentialsSent = true;

            // NOTE: NTLM authentication requires using the same socket for the "negotiate" and "authenticate" requests.
            // So, before sending the "authenticate" message, we should wait for data from the "challenge" response. It
            // will mean that the socket is free.
            this._send((0, _webauth.requiresResBody)(res));
        });

        function _resendWithCredentials(_x) {
            return _ref.apply(this, arguments);
        }

        return _resendWithCredentials;
    }();

    DestinationRequest.prototype._fatalError = function _fatalError(msg, url) {
        if (!this.aborted) {
            this.aborted = true;
            this.req.abort();
            this.emit('fatalError', (0, _messages.getText)(msg, url || this.opts.url));
        }
    };

    DestinationRequest.prototype._isDNSErr = function _isDNSErr(err) {
        return err.message && IS_DNS_ERR_MSG_RE.test(err.message) || !this.aborted && !this.hasResponse && err.code && IS_DNS_ERR_CODE_RE.test(err.code);
    };

    DestinationRequest.prototype._isTunnelingErr = function _isTunnelingErr(err) {
        return this.isHttps && this.opts.proxy && err.message && TUNNELING_SOCKET_ERR_RE.test(err.message);
    };

    DestinationRequest.prototype._isSocketHangUpErr = function _isSocketHangUpErr(err) {
        return err.message && SOCKET_HANG_UP_ERR_RE.test(err.message) &&
        // NOTE: Only for nodejs 4 error with a same message will be generated for different cases.
        // This is why, we filter a 'SocketHangUpErr' by stack.
        // Remove filtering by stack content after ending support of nodejs 4.
        err.stack && err.stack.includes('createHangUpError');
    };

    DestinationRequest.prototype._onTimeout = function _onTimeout() {
        // NOTE: this handler is also called if we get an error response (for example, 404). So, we should check
        // for the response presence before raising the timeout error.
        if (!this.hasResponse) this._fatalError(_messages.MESSAGE.destRequestTimeout);
    };

    DestinationRequest.prototype._onError = function _onError(err) {
        if (this._isSocketHangUpErr(err)) this.emit('socketHangUp');else if (requestAgent.shouldRegressHttps(err, this.opts)) {
            requestAgent.regressHttps(this.opts);
            this._send();
        } else if (this._isTunnelingErr(err)) {
            if (TUNNELING_AUTHORIZE_ERR_RE.test(err.message)) this._fatalError(_messages.MESSAGE.cantAuthorizeToProxy, this.opts.proxy.host);else this._fatalError(_messages.MESSAGE.cantEstablishTunnelingConnection, this.opts.proxy.host);
        } else if (this._isDNSErr(err)) {
            if (!this.isHttps && this.opts.proxy) this._fatalError(_messages.MESSAGE.cantEstablishProxyConnection, this.opts.proxy.host);else this._fatalError(_messages.MESSAGE.cantResolveUrl);
        } else this.emit('error');
    };

    return DestinationRequest;
}(_events.EventEmitter);

// NOTE: Exposed for testing purposes.


exports.default = DestinationRequest;
DestinationRequest.TIMEOUT = 25 * 1000;
DestinationRequest.XHR_TIMEOUT = 2 * 60 * 1000;
module.exports = exports['default'];