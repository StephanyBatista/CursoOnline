'use strict';

exports.__esModule = true;

var _headers = require('./xhr/headers');

var _headers2 = _interopRequireDefault(_headers);

var _charset = require('../processing/encoding/charset');

var _charset2 = _interopRequireDefault(_charset);

var _url = require('../utils/url');

var urlUtils = _interopRequireWildcard(_url);

var _contentType = require('../utils/content-type');

var contentTypeUtils = _interopRequireWildcard(_contentType);

var _generateUniqueId = require('../utils/generate-unique-id');

var _generateUniqueId2 = _interopRequireDefault(_generateUniqueId);

var _sameOriginPolicy = require('./xhr/same-origin-policy');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308];

var RequestPipelineContext = function () {
    function RequestPipelineContext(req, res, serverInfo) {
        _classCallCheck(this, RequestPipelineContext);

        this.serverInfo = serverInfo;
        this.session = null;

        this.req = req;
        this.reqBody = null;
        this.res = res;

        this.dest = null;
        this.destRes = null;
        this.destResBody = null;
        this.hasDestReqErr = false;

        this.isXhr = false;
        this.isFetch = false;
        this.isPage = false;
        this.isHtmlImport = false;
        this.isWebSocket = false;
        this.isIframe = false;
        this.isSpecialPage = false;
        this.contentInfo = null;

        var acceptHeader = req.headers['accept'];

        this.isXhr = !!req.headers[_headers2.default.requestMarker];
        this.isFetch = !!req.headers[_headers2.default.fetchRequestCredentials];
        this.isPage = !this.isXhr && !this.isFetch && acceptHeader && contentTypeUtils.isPage(acceptHeader);

        this.restoringStorages = null;

        this.requestId = (0, _generateUniqueId2.default)();
        this.requestFilterRules = [];
        this.onResponseEventDataWithoutBody = [];

        this.reqOpts = null;
    }

    // TODO: Rewrite parseProxyUrl instead.


    RequestPipelineContext.prototype._flattenParsedProxyUrl = function _flattenParsedProxyUrl(parsed) {
        if (parsed) {
            var parsedResourceType = urlUtils.parseResourceType(parsed.resourceType);

            var dest = {
                url: parsed.destUrl,
                protocol: parsed.destResourceInfo.protocol,
                host: parsed.destResourceInfo.host,
                hostname: parsed.destResourceInfo.hostname,
                port: parsed.destResourceInfo.port,
                partAfterHost: parsed.destResourceInfo.partAfterHost,
                isIframe: parsedResourceType.isIframe,
                isForm: parsedResourceType.isForm,
                isScript: parsedResourceType.isScript,
                isEventSource: parsedResourceType.isEventSource,
                isHtmlImport: parsedResourceType.isHtmlImport,
                isWebSocket: parsedResourceType.isWebSocket,
                charset: parsed.charset,
                reqOrigin: parsed.reqOrigin
            };

            return {
                dest: dest,
                sessionId: parsed.sessionId
            };
        }

        return null;
    };

    RequestPipelineContext.prototype._getDestFromReferer = function _getDestFromReferer(parsedReferer) {
        var dest = parsedReferer.dest;

        dest.partAfterHost = this.req.url;
        dest.url = urlUtils.formatUrl(dest);

        return {
            dest: dest,
            sessionId: parsedReferer.sessionId
        };
    };

    RequestPipelineContext.prototype._isFileDownload = function _isFileDownload() {
        var contentDisposition = this.destRes.headers['content-disposition'];

        return contentDisposition && contentDisposition.includes('attachment') && contentDisposition.includes('filename');
    };

    RequestPipelineContext.prototype._getInjectable = function _getInjectable(injectable) {
        var _this = this;

        return injectable.map(function (url) {
            return _this.serverInfo.domain + url;
        });
    };

    RequestPipelineContext.prototype._initRequestNatureInfo = function _initRequestNatureInfo() {
        var acceptHeader = this.req.headers['accept'];

        this.isWebSocket = this.dest.isWebSocket;
        this.isHtmlImport = this.dest.isHtmlImport;
        this.isPage = !this.isXhr && !this.isFetch && !this.isWebSocket && acceptHeader && contentTypeUtils.isPage(acceptHeader) || this.isHtmlImport;
        this.isIframe = this.dest.isIframe;
        this.isSpecialPage = urlUtils.isSpecialPage(this.dest.url);
        this.isFileProtocol = this.dest.protocol === 'file:';
    };

    // API


    RequestPipelineContext.prototype.dispatch = function dispatch(openSessions) {
        var parsedReqUrl = urlUtils.parseProxyUrl(this.req.url);
        var referer = this.req.headers['referer'];
        var parsedReferer = referer && urlUtils.parseProxyUrl(referer);

        // TODO: Remove it after parseProxyURL is rewritten.
        parsedReqUrl = this._flattenParsedProxyUrl(parsedReqUrl);
        parsedReferer = this._flattenParsedProxyUrl(parsedReferer);

        // NOTE: Try to extract the destination from the 'referer' header.
        if (!parsedReqUrl && parsedReferer) parsedReqUrl = this._getDestFromReferer(parsedReferer);

        if (parsedReqUrl) {
            this.session = openSessions[parsedReqUrl.sessionId];

            if (!this.session) return false;

            this.dest = parsedReqUrl.dest;

            // Browsers add a leading slash to the pathname part of url (GH-608)
            // For example: url http://www.example.com?gd=GID12082014 will be converted
            // to http://www.example.com/?gd=GID12082014
            this.dest.partAfterHost = (this.dest.partAfterHost[0] === '/' ? '' : '/') + this.dest.partAfterHost;

            this.dest.domain = urlUtils.getDomain(this.dest);

            if (parsedReferer) {
                this.dest.referer = parsedReferer.dest.url;
                this.dest.reqOrigin = parsedReferer.dest.protocol === 'file:' ? parsedReferer.dest.url : urlUtils.getDomain(parsedReferer.dest);
            } else if (this.req.headers[_headers2.default.origin]) this.dest.reqOrigin = this.req.headers[_headers2.default.origin];

            this._initRequestNatureInfo();

            return true;
        }

        return false;
    };

    RequestPipelineContext.prototype.buildContentInfo = function buildContentInfo() {
        var contentType = this.destRes.headers['content-type'] || '';
        var accept = this.req.headers['accept'] || '';
        var encoding = this.destRes.headers['content-encoding'];

        if (this.isPage && contentType) this.isPage = !this.isXhr && !this.isFetch && contentTypeUtils.isPage(contentType);

        var isCSS = contentTypeUtils.isCSSResource(contentType, accept);
        var isManifest = contentTypeUtils.isManifest(contentType);
        var isScript = this.dest.isScript || contentTypeUtils.isScriptResource(contentType, accept);
        var isForm = this.dest.isForm;
        var isFormWithEmptyResponse = isForm && this.destRes.statusCode === 204;

        var isRedirect = this.destRes.headers['location'] && REDIRECT_STATUS_CODES.includes(this.destRes.statusCode);
        var requireAssetsProcessing = (isCSS || isScript || isManifest) && this.destRes.statusCode !== 204;
        var isNotModified = this.req.method === 'GET' && this.destRes.statusCode === 304 && (this.req.headers['if-modified-since'] || this.req.headers['if-none-match']);
        var requireProcessing = !this.isXhr && !this.isFetch && !isFormWithEmptyResponse && !isRedirect && !isNotModified && (this.isPage || this.isIframe || requireAssetsProcessing);
        var isFileDownload = this._isFileDownload() && !this.dest.isScript;
        var isIframeWithImageSrc = this.isIframe && !this.isPage && /^\s*image\//.test(contentType);

        var charset = null;
        var contentTypeUrlToken = urlUtils.getResourceTypeString({
            isIframe: this.isIframe,
            isForm: isForm,
            isScript: isScript
        });

        // NOTE: We need charset information if we are going to process the resource.
        if (requireProcessing) {
            charset = new _charset2.default();

            if (!charset.fromContentType(contentType)) charset.fromUrl(this.dest.charset);
        }

        if (isFileDownload) this.session.handleFileDownload();

        this.contentInfo = {
            charset,
            requireProcessing,
            isIframeWithImageSrc,
            isCSS,
            isScript,
            isManifest,
            encoding,
            contentTypeUrlToken,
            isFileDownload,
            isNotModified,
            isRedirect
        };
    };

    RequestPipelineContext.prototype.getInjectableScripts = function getInjectableScripts() {
        var taskScript = this.isIframe ? '/iframe-task.js' : '/task.js';
        var scripts = this.session.injectable.scripts.concat(taskScript);

        return this._getInjectable(scripts);
    };

    RequestPipelineContext.prototype.getInjectableStyles = function getInjectableStyles() {
        return this._getInjectable(this.session.injectable.styles);
    };

    RequestPipelineContext.prototype.redirect = function redirect(url) {
        this.res.statusCode = 302;
        this.res.setHeader('location', url);
        this.res.end();
    };

    RequestPipelineContext.prototype.saveNonProcessedDestResBody = function saveNonProcessedDestResBody(value) {
        this.nonProcessedDestResBody = value;
    };

    RequestPipelineContext.prototype.closeWithError = function closeWithError(statusCode, resBody) {
        this.res.statusCode = statusCode;

        if (resBody && !this.res.headersSent && this.res.setHeader) {
            this.res.setHeader('content-type', 'text/html');
            this.res.end(resBody);
        } else this.res.end();
    };

    RequestPipelineContext.prototype.toProxyUrl = function toProxyUrl(url, isCrossDomain, resourceType, charset) {
        var proxyHostname = this.serverInfo.hostname;
        var proxyProtocol = this.serverInfo.protocol;
        var proxyPort = isCrossDomain ? this.serverInfo.crossDomainPort : this.serverInfo.port;
        var sessionId = this.session.id;

        return urlUtils.getProxyUrl(url, {
            proxyHostname,
            proxyProtocol,
            proxyPort,
            sessionId,
            resourceType,
            charset
        });
    };

    RequestPipelineContext.prototype.isKeepSameOriginPolicy = function isKeepSameOriginPolicy() {
        var isAjaxRequest = this.isXhr || this.isFetch;
        var shouldPerformCORSCheck = isAjaxRequest && !this.contentInfo.isNotModified;

        return shouldPerformCORSCheck ? (0, _sameOriginPolicy.check)(this) : true;
    };

    return RequestPipelineContext;
}();

exports.default = RequestPipelineContext;
module.exports = exports['default'];